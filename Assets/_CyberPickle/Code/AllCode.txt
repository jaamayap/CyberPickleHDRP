// File: Achievements/AchievementManager.cs
// Size: 349 characters
// ---
using CyberPickle.Core.Management;
using CyberPickle.Core.Interfaces;
using UnityEngine;

namespace CyberPickle.Achievements
{
    public class AchievementManager : Manager<AchievementManager>, IInitializable
    {
        public void Initialize()
        {
            Debug.Log("Initializing Achievement Manager");
        }
    }
}

// --- END FILE ---

// File: Characters/CharacterDisplayManager.cs
// Size: 13775 characters
// ---
// File: Assets/_CyberPickle/Code/Characters/CharacterDisplayManager.cs
//
// Purpose: Handles the visual presentation of characters in the selection screen,
// including model instantiation, animation control, material management, and 
// interaction setup. Responsible for all display-related functionality and pointer
// interaction infrastructure.
//
// Created: 2024-02-11
// Updated: 2024-02-11

using UnityEngine;
using System;
using System.Threading.Tasks;
using System.Collections.Generic;
using CyberPickle.Core.Management;
using CyberPickle.Core.Events;
using CyberPickle.Characters.Data;
using DG.Tweening;
using UnityEngine.EventSystems;

namespace CyberPickle.Characters
{
    /// <summary>
    /// Manages character visualization and interaction infrastructure in the selection screen.
    /// </summary>
    public class CharacterDisplayManager : Manager<CharacterDisplayManager>
    {
        #region Serialized Fields

        [Header("Animation Settings")]
        [SerializeField] private float transitionDuration = 0.5f;
        [SerializeField] private float idleAnimationSpeed = 1f;
        [SerializeField] private float hoverAnimationSpeed = 1.2f;

        [Header("Visual Effects")]
        [SerializeField] private float highlightIntensity = 1.5f;
        [SerializeField] private float dimmedIntensity = 0.5f;
        [SerializeField] private Material lockedMaterial;

        [Header("Spotlight Settings")]
        [SerializeField] private float spotlightIntensity = 5000f;
        [SerializeField] private float spotlightRange = 10f;
        [SerializeField] private float spotlightAngle = 30f;

        #endregion

        #region Private Fields

        // Component caches for performance
        private Dictionary<GameObject, Animator> characterAnimators = new Dictionary<GameObject, Animator>();
        private Dictionary<GameObject, Material[]> originalMaterials = new Dictionary<GameObject, Material[]>();
        private Dictionary<GameObject, SkinnedMeshRenderer> characterRenderers = new Dictionary<GameObject, SkinnedMeshRenderer>();
        private bool isInitialized;

        #endregion

        #region Initialization

        protected override void OnManagerAwake()
        {
            base.OnManagerAwake();
            ValidateReferences();
        }

        /// <summary>
        /// Initializes the display manager and sets up interaction infrastructure
        /// </summary>
        public void Initialize()
        {
            if (isInitialized) return;

            SetupPointerInteraction();
            isInitialized = true;
            Debug.Log("[CharacterDisplayManager] Initialized successfully");
        }

        private void ValidateReferences()
        {
            if (lockedMaterial == null)
            {
                Debug.LogError("[CharacterDisplayManager] Locked material is not assigned!");
            }
        }

        /// <summary>
        /// Sets up the required components for pointer interaction with characters
        /// </summary>
        private void SetupPointerInteraction()
        {
            // Setup Physics Raycaster
            var camera = Camera.main;
            if (camera != null && camera.GetComponent<PhysicsRaycaster>() == null)
            {
                var raycaster = camera.gameObject.AddComponent<PhysicsRaycaster>();
                raycaster.eventMask = LayerMask.GetMask("Character");
                Debug.Log("[CharacterDisplayManager] Added PhysicsRaycaster to main camera");
            }

            // Setup Event System if needed
            if (FindObjectOfType<EventSystem>() == null)
            {
                var eventSystem = new GameObject("Event System");
                eventSystem.AddComponent<EventSystem>();
                eventSystem.AddComponent<StandaloneInputModule>();
                Debug.Log("[CharacterDisplayManager] Created EventSystem");
            }
        }

        #endregion

        #region Character Spawning and Setup

        /// <summary>
        /// Spawns and initializes a character model with visual components
        /// </summary>
        /// <param name="characterData">Data containing character configuration</param>
        /// <param name="position">World position for spawning</param>
        /// <param name="rotation">Initial rotation (will be adjusted to face camera)</param>
        /// <returns>The instantiated character GameObject, or null if spawning fails</returns>
        public async Task<GameObject> SpawnCharacter(CharacterData characterData, Vector3 position, Quaternion rotation)
        {
            if (characterData == null || characterData.characterPrefab == null)
            {
                Debug.LogError($"[CharacterDisplayManager] Invalid character data for spawning!");
                return null;
            }

            try
            {
                // Handle the actual instantiation and setup
                Quaternion targetRotation = Quaternion.Euler(0, 180, 0);
                GameObject characterInstance = Instantiate(characterData.characterPrefab, position, targetRotation);
                characterInstance.name = $"Character_{characterData.characterId}";

                // Cache components for performance
                CacheCharacterComponents(characterInstance);

                // Initialize visual state
                await InitializeCharacterVisuals(characterInstance, characterData);

                Debug.Log($"[CharacterDisplayManager] Successfully spawned character: {characterData.characterId}");
                return characterInstance;
            }
            catch (Exception e)
            {
                Debug.LogError($"[CharacterDisplayManager] Failed to spawn character: {e.Message}");
                return null;
            }
        }

        private void CacheCharacterComponents(GameObject character)
        {
            var animator = character.GetComponent<Animator>();
            if (animator != null)
            {
                characterAnimators[character] = animator;
            }

            var renderer = character.GetComponentInChildren<SkinnedMeshRenderer>();
            if (renderer != null)
            {
                characterRenderers[character] = renderer;
                originalMaterials[character] = renderer.materials;
            }
        }

        private async Task InitializeCharacterVisuals(GameObject character, CharacterData characterData)
        {
            if (characterAnimators.TryGetValue(character, out var animator))
            {
                animator.SetTrigger(characterData.idleAnimationTrigger);
                animator.speed = idleAnimationSpeed;
            }

            await Task.Yield();
        }

        #endregion

        #region Visual State Management

        /// <summary>
        /// Updates the visual state of a character based on its display state
        /// </summary>
        public void UpdateCharacterState(GameObject character, CharacterDisplayState state)
        {
            if (character == null) return;

            UpdateAnimation(character, state);
            UpdateMaterials(character, state);
            UpdateLighting(character, state);
        }

        private void UpdateAnimation(GameObject character, CharacterDisplayState state)
        {
            Debug.Log($"UpdateAnimation called for {character.name} with state: {state}");
            if (!characterAnimators.TryGetValue(character, out var animator))
                return;

            // Reset all triggers first to prevent animation conflicts
            animator.ResetTrigger("Idle");
            animator.ResetTrigger("Dance");
            animator.ResetTrigger("Selected");
            animator.ResetTrigger("Locked");

            string characterId = character.name.Replace("Character_", "");
            bool isLocked = !CharacterSelectionManager.Instance.IsCharacterUnlocked(characterId);

            if (isLocked)
            {
                // For locked characters:
                // - On hover -> Locked animation
                // - Otherwise -> Idle animation
                if (state == CharacterDisplayState.Hover)
                {
                    animator.SetTrigger("Locked");
                    animator.speed = 0.5f;
                }
                else
                {
                    animator.SetTrigger("Idle");
                    animator.speed = idleAnimationSpeed;
                }
            }
            else
            {
                // Unlocked characters use all states normally
                switch (state)
                {
                    case CharacterDisplayState.Idle:
                        animator.SetTrigger("Idle");
                        animator.speed = idleAnimationSpeed;
                        break;
                    case CharacterDisplayState.Hover:
                        animator.SetTrigger("Dance");
                        animator.speed = hoverAnimationSpeed;
                        break;
                    case CharacterDisplayState.Selected:
                        animator.SetTrigger("Selected");
                        animator.speed = 1f;
                        break;
                    case CharacterDisplayState.Locked:
                        animator.SetTrigger("Locked");
                        animator.speed = 0.5f;
                        break;
                }
            }
        }

        private void UpdateMaterials(GameObject character, CharacterDisplayState state)
        {
            if (!characterRenderers.TryGetValue(character, out var renderer) ||
                !originalMaterials.ContainsKey(character))
                return;

            Material[] currentMaterials;

            switch (state)
            {
                case CharacterDisplayState.Locked:
                    currentMaterials = new Material[renderer.materials.Length];
                    for (int i = 0; i < currentMaterials.Length; i++)
                    {
                        currentMaterials[i] = lockedMaterial;
                    }
                    break;

                case CharacterDisplayState.Hover:
                case CharacterDisplayState.Selected:
                    currentMaterials = originalMaterials[character];
                    foreach (var material in currentMaterials)
                    {
                        if (material.HasProperty("_EmissionIntensity"))
                        {
                            material.SetFloat("_EmissionIntensity", highlightIntensity);
                        }
                    }
                    break;

                default:
                    currentMaterials = originalMaterials[character];
                    foreach (var material in currentMaterials)
                    {
                        if (material.HasProperty("_EmissionIntensity"))
                        {
                            material.SetFloat("_EmissionIntensity", 1f);
                        }
                    }
                    break;
            }

            renderer.materials = currentMaterials;
        }

        private void UpdateLighting(GameObject character, CharacterDisplayState state)
        {
            float targetIntensity = state == CharacterDisplayState.Hover ||
                                  state == CharacterDisplayState.Selected
                                  ? highlightIntensity
                                  : dimmedIntensity;

            var characterLights = character.GetComponentsInChildren<Light>();
            foreach (var light in characterLights)
            {
                light.intensity = targetIntensity;
            }
        }

        #endregion

        #region Spotlight Control

        /// <summary>
        /// Rotates the spotlight to focus on a character
        /// </summary>
        public async Task RotateSpotlight(Light spotlight, float targetRotation, float duration)
        {
            if (spotlight == null) return;

            try
            {
                Vector3 currentRotation = spotlight.transform.localEulerAngles;
                Vector3 targetRotationVector = new Vector3(
                    currentRotation.x,
                    targetRotation,
                    currentRotation.z
                );

                await spotlight.transform
                    .DOLocalRotate(targetRotationVector, duration)
                    .SetEase(Ease.InOutQuad)
                    .AsyncWaitForCompletion();

                spotlight.intensity = spotlightIntensity;
                spotlight.range = spotlightRange;
                spotlight.spotAngle = spotlightAngle;
            }
            catch (Exception e)
            {
                Debug.LogError($"[CharacterDisplayManager] Failed to rotate spotlight: {e.Message}");
            }
        }

        #endregion

        #region Cleanup

        /// <summary>
        /// Cleans up cached components and materials
        /// </summary>
        public void Cleanup()
        {
            characterAnimators.Clear();
            characterRenderers.Clear();
            originalMaterials.Clear();
            isInitialized = false;
        }

        protected override void OnManagerDestroyed()
        {
            base.OnManagerDestroyed();
            Cleanup();
        }

        #endregion
    }
}
// --- END FILE ---

// File: Characters/CharacterManager.cs
// Size: 331 characters
// ---
using CyberPickle.Core.Management;
using CyberPickle.Core.Interfaces;

namespace CyberPickle.Characters
{
    public class CharacterManager : Manager<CharacterManager>, IInitializable
    {
        public void Initialize()
        {
            UnityEngine.Debug.Log("CharacterManager initialized");
        }
    }
}

// --- END FILE ---

// File: Characters/CharacterPointerHandler.cs
// Size: 7173 characters
// ---
// File: Assets/_CyberPickle/Code/Characters/CharacterPointerHandler.cs
//
// Purpose: Handles pointer interaction events for character models in the selection screen.
// Manages mouse hover, click events, and communicates with the selection system through
// GameEvents. Requires a BoxCollider for physics raycasting.
//
// Created: 2024-02-11
// Updated: 2024-02-11

using UnityEngine;
using UnityEngine.EventSystems;
using CyberPickle.Core.Events;


namespace CyberPickle.Characters
{
    /// <summary>
    /// Handles pointer interactions with character models in the selection screen.
    /// Requires a BoxCollider component for physics raycasting.
    /// </summary>
    [RequireComponent(typeof(BoxCollider))]
    public class CharacterPointerHandler : MonoBehaviour,
        IPointerEnterHandler,
        IPointerExitHandler,
        IPointerClickHandler
    {
        private BoxCollider pointerCollider;
        private string characterId;
        private bool isInteractable = true;

        /// <summary>
        /// Initializes the required components and configures the BoxCollider
        /// for pointer interactions.
        /// </summary>
        private void Awake()
        {
            // Add debug logging
            Debug.Log($"[CharacterPointerHandler] Initializing for GameObject: {gameObject.name}");

            pointerCollider = GetComponent<BoxCollider>();
            if (pointerCollider == null)
            {
                pointerCollider = gameObject.AddComponent<BoxCollider>();
                // Make sure collider size is appropriate
                pointerCollider.size = new Vector3(2f, 4f, 2f);
                pointerCollider.center = new Vector3(0f, 2f, 0f);
                pointerCollider.isTrigger = true;
                Debug.Log($"[CharacterPointerHandler] Added BoxCollider to {gameObject.name}");
            }
        }

       
        private void Update()
        {
            // Debug ray from mouse position
            Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);
            RaycastHit hit;

            if (Physics.Raycast(ray, out hit))
            {
                Debug.DrawRay(ray.origin, ray.direction * hit.distance, Color.yellow);
                
            }
        }
        private void OnDrawGizmos()
        {
            if (pointerCollider != null)
            {
                // Draw collider bounds
                Gizmos.color = Color.yellow;
                Matrix4x4 rotationMatrix = Matrix4x4.TRS(transform.position, transform.rotation, transform.lossyScale);
                Gizmos.matrix = rotationMatrix;
                Gizmos.DrawWireCube(pointerCollider.center, pointerCollider.size);
            }
        }

        /// <summary>
        /// Initializes the handler with character-specific data
        /// </summary>
        /// <param name="characterId">Unique identifier for the character</param>
        public void Initialize(string characterId)
        {
            this.characterId = characterId;
            Debug.Log($"[CharacterPointerHandler] Initialized for character: {characterId}");
        }

        /// <summary>
        /// Enables or disables pointer interactions with the character
        /// </summary>
        /// <param name="interactable">Whether the character should respond to pointer events</param>
        public void SetInteractable(bool interactable, bool allowHover = true)
        {
            isInteractable = interactable;

            // Allow hover even if interaction is disabled
            pointerCollider.isTrigger = !interactable || allowHover;

            Debug.Log($"[CharacterPointerHandler] Interactable set to {interactable}, AllowHover: {allowHover}");
        }
        public bool IsInteractable => isInteractable;
        /// <summary>
        /// Handles pointer enter events, triggering character hover state
        /// </summary>
        /// <param name="eventData">Data associated with the pointer event</param>
        public void OnPointerEnter(PointerEventData eventData)
        {
            Debug.Log($"[CharacterPointerHandler] POINTER ENTER - Position: {eventData.position}");
            Debug.Log($"Cursor Entering {name} GameObject");

            // Always invoke hover events, even for locked characters
            GameEvents.OnCharacterHoverEnter?.Invoke(characterId);

            // Add additional debug to verify behavior
            if (isInteractable)
            {
                Debug.Log($"[CharacterPointerHandler] Hovering over unlocked character: {characterId}");
            }
            else
            {
                Debug.Log($"[CharacterPointerHandler] Hovering over locked character: {characterId}");
            }
        }

        /// <summary>
        /// Handles pointer exit events, ending character hover state
        /// </summary>
        /// <param name="eventData">Data associated with the pointer event</param>
        public void OnPointerExit(PointerEventData eventData)
        {
            Debug.Log($"[CharacterPointerHandler] POINTER EXIT - Position: {eventData.position}");
            if (!isInteractable) return;
            GameEvents.OnCharacterHoverExit?.Invoke(characterId);
        }

        /// <summary>
        /// Handles pointer click events, differentiating between left and right clicks
        /// Left click: Select character
        /// Right click: Show character details
        /// </summary>
        /// <param name="eventData">Data associated with the pointer event</param>
        public void OnPointerClick(PointerEventData eventData)
        {
            Debug.Log($"[CharacterPointerHandler] POINTER CLICK - Position: {eventData.position}, Button: {eventData.button}");
            if (!isInteractable)
            {
                Debug.Log($"[CharacterPointerHandler] Click blocked for locked character: {characterId}");
                return; // Block click interaction
            }

            switch (eventData.button)
            {
                case PointerEventData.InputButton.Left:
                    GameEvents.OnCharacterSelected?.Invoke(characterId);
                    break;
                case PointerEventData.InputButton.Right:
                    GameEvents.OnCharacterDetailsRequested?.Invoke(characterId);
                    break;
            }
        }

        /// <summary>
        /// Allows runtime adjustment of the collider size to match character model scale
        /// </summary>
        /// <param name="size">New size for the collision box</param>
        /// <param name="center">New center position for the collision box</param>
        public void AdjustColliderSize(Vector3 size, Vector3 center)
        {
            if (pointerCollider != null)
            {
                pointerCollider.size = size;
                pointerCollider.center = center;
                Debug.Log($"[CharacterPointerHandler] Adjusted collider size for {characterId}");
            }
        }
    }
}

// --- END FILE ---

// File: Characters/CharacterSelectionManager.cs
// Size: 38434 characters
// ---
// File: Assets/_CyberPickle/Code/Characters/CharacterSelectionManager.cs
//
// Purpose: Manages the character selection screen functionality in Cyber Pickle.
// This manager coordinates character display, UI interactions, profile data handling,
// and state transitions. It acts as the central coordinator for the character
// selection flow and maintains the state of displayed characters.
//
// Dependencies:
// - CharacterDisplayManager: Handles visual presentation of characters
// - CharacterUIManager: Manages UI elements and interactions
// - ProfileManager: Handles profile data and persistence
// - GameManager: Controls game state transitions
// - InputManager: Processes player input
// - CameraManager: Controls camera transitions and effects
//
// Created: 2024-02-11
// Updated: 2024-02-29

using UnityEngine;
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using CyberPickle.Core.Management;
using CyberPickle.Core.Events;
using CyberPickle.Core.States;
using CyberPickle.Core.Camera;
using CyberPickle.Core.Services.Authentication;
using CyberPickle.Core.Services.Authentication.Data;
using CyberPickle.Characters.Data;
using CyberPickle.Core.Input;
using CyberPickle.Core;
using DG.Tweening;
using System.Collections;

namespace CyberPickle.Characters
{
    /// <summary>
    /// Defines possible display states for characters in the selection screen
    /// </summary>
    public enum CharacterDisplayState
    {
        /// <summary>Character is not visible</summary>
        Hidden,
        /// <summary>Character is visible but not unlocked</summary>
        Locked,
        /// <summary>Character is in default display state</summary>
        Idle,
        /// <summary>Character is being hovered over</summary>
        Hover,
        /// <summary>Character has been selected</summary>
        Selected,
        
    }

    /// <summary>
    /// Central manager for the character selection screen functionality.
    /// Coordinates between display, UI, and game state systems.
    /// </summary>
    public class CharacterSelectionManager : Manager<CharacterSelectionManager>
    {
        private bool cameraFocused = false;

        #region Serialized Fields

        [Header("Scene References")]
        [SerializeField] private Transform[] characterPositions;
        [SerializeField] private Light spotLight;
        [SerializeField] private float spotlightRotationDuration = 0.5f;

        [Header("Character References")]
        [SerializeField] private CharacterData[] availableCharacters;

        [Header("Managers")]
        [SerializeField] private CharacterDisplayManager displayManager;
        [SerializeField] private CharacterUIManager uiManager;

        [Header("Camera Focus Settings")]
        [SerializeField] private Vector3 cameraFocusOffset = new Vector3(0, 2, -3);
        [SerializeField] private float cameraFocusFieldOfView = 40f;
        [SerializeField] private float focusTransitionDuration = 1f;
        [SerializeField] private float focusHeightOffset = 0f;
        [SerializeField] private float focusDistance = -5f;
        [SerializeField] private Vector3 focusRotationAngles = new Vector3(10f, 0f, 0f);
        [SerializeField] private float lookOffset = 2f;

        [SerializeField] private float spotlightRotationSpeed = 3f;    // Adjust how quickly the spotlight aims
        [SerializeField] private float spotlightVerticalOffset = 1.5f; // How high above the feet to aim
        #endregion

        #region Private Fields

        // Core service references
        private ProfileManager profileManager;
        private GameManager gameManager;
        private InputManager inputManager;
        private CameraManager cameraManager;

        // State tracking
        private Dictionary<string, GameObject> spawnedCharacters = new Dictionary<string, GameObject>();
        private Dictionary<string, CharacterDisplayState> characterStates = new Dictionary<string, CharacterDisplayState>();
        private string currentlySelectedCharacterId;
        private string currentlyHoveredCharacterId;
        private bool isTransitioning;
        private int currentSpotlightIndex;
        private Vector3 characterSelectionCameraPosition;

        // Stores whether each character was interactable before selection
        private Dictionary<string, bool> oldInteractableStates = new Dictionary<string, bool>();

       
        // Stores Hover/Selected/Locked 
        private Dictionary<string, CharacterDisplayState> oldDisplayStates = new Dictionary<string, CharacterDisplayState>();


        [SerializeField] private float defaultFieldOfView = 60f;  // Or whatever default FOV you want

        #endregion

        #region Public Methods

        /// <summary>
        /// Retrieves character data for the specified character ID
        /// </summary>
        /// <param name="characterId">The ID of the character to retrieve</param>
        /// <returns>CharacterData if found, null otherwise</returns>
        public CharacterData GetCharacterData(string characterId)
        {
            return Array.Find(availableCharacters, c => c.characterId == characterId);
        }

        /// <summary>
        /// Checks if a character is unlocked for the current profile
        /// </summary>
        /// <param name="characterId">The ID of the character to check</param>
        /// <returns>True if the character is unlocked, false otherwise</returns>
        public bool IsCharacterUnlocked(string characterId)
        {
            if (string.IsNullOrEmpty(characterId)) return false;

            var characterData = Array.Find(availableCharacters, c => c.characterId == characterId);
            if (characterData == null) return false;

            // Check if unlocked by default
            if (characterData.unlockedByDefault) return true;

            // Check profile data for unlock status
            var profile = profileManager.ActiveProfile;
            if (profile?.CharacterProgress == null) return false;

            return profile.CharacterProgress.ContainsKey(characterId);
        }

        /// <summary>
        /// Handles the selection of a character and triggers the transition to level selection
        /// </summary>
        /// <param name="characterId">The ID of the character to select</param>
        /// <returns>True if selection was successful, false otherwise</returns>
        public async Task<bool> SelectCharacter(string characterId)
        {
            if (!IsCharacterUnlocked(characterId) || isTransitioning) return false;

            isTransitioning = true;

            try
            {
                currentlySelectedCharacterId = characterId;
                SetCharacterState(characterId, CharacterDisplayState.Selected);

                var profile = profileManager.ActiveProfile;
                if (profile != null)
                {
                    await profileManager.UpdateProfileAsync(profile);
                }

                GameEvents.OnGameStateChanged.Invoke(GameState.LevelSelect);
                return true;
            }
            catch (Exception e)
            {
                Debug.LogError($"[CharacterSelectionManager] Failed to select character: {e.Message}");
                return false;
            }
            finally
            {
                isTransitioning = false;
            }
        }

        #endregion

        #region Protected Methods

        protected override void OnManagerAwake()
        {
            base.OnManagerAwake();
            Debug.Log($"[CharacterSelectionManager] OnManagerAwake called. Instance ID: {GetInstanceID()}");
            InitializeManagerReferences();
            ValidateReferences();
            displayManager.Initialize();  // Initialize display manager early
        }

        protected override void OnManagerEnabled()
        {
            base.OnManagerEnabled();
            Debug.Log($"[CharacterSelectionManager] OnEnable called. Instance ID: {GetInstanceID()}");

            // Ensure manager references are valid on enable
            if (!EnsureManagerReferences())
            {
                Debug.LogError("[CharacterSelectionManager] Failed to get manager references in OnEnable!");
                return;
            }

            SubscribeToEvents();
        }

        protected override void OnManagerDisabled()
        {
            base.OnManagerDisabled();
            UnsubscribeFromEvents();
        }

        protected override void OnManagerDestroyed()
        {
            base.OnManagerDestroyed();
            CleanupCharacterSelection();
            UnsubscribeFromEvents();
        }

        #endregion

        #region Manager Reference Handling

        private void InitializeManagerReferences()
        {
            Debug.Log("[CharacterSelectionManager] Initializing manager references");
            EnsureManagerReferences();
        }

        private bool EnsureManagerReferences()
        {
            if (profileManager == null)
            {
                profileManager = ProfileManager.Instance;
                Debug.Log($"[CharacterSelectionManager] Got ProfileManager instance: {(profileManager != null ? "Success" : "Failed")}");
            }

            if (gameManager == null)
            {
                gameManager = GameManager.Instance;
            }

            if (inputManager == null)
            {
                inputManager = InputManager.Instance;
            }

            if (cameraManager == null)
            {
                cameraManager = CameraManager.Instance;
            }

            bool referencesValid = ValidateManagerReferences();
            Debug.Log($"[CharacterSelectionManager] Manager references valid: {referencesValid}");
            return referencesValid;
        }

        private bool ValidateManagerReferences()
        {
            if (profileManager == null)
            {
                Debug.LogError("[CharacterSelectionManager] ProfileManager reference is null!");
                return false;
            }

            if (gameManager == null)
            {
                Debug.LogError("[CharacterSelectionManager] GameManager reference is null!");
                return false;
            }

            if (inputManager == null)
            {
                Debug.LogError("[CharacterSelectionManager] InputManager reference is null!");
                return false;
            }

            if (cameraManager == null)
            {
                Debug.LogError("[CharacterSelectionManager] CameraManager reference is null!");
                return false;
            }

            if (displayManager == null)
            {
                Debug.LogError("[CharacterSelectionManager] DisplayManager reference is null!");
                return false;
            }

            if (uiManager == null)
            {
                Debug.LogError("[CharacterSelectionManager] UIManager reference is null!");
                return false;
            }

            return true;
        }

        #endregion






        #region Private Methods

       

        private void ValidateReferences()
        {
            if (characterPositions == null || characterPositions.Length == 0)
            {
                Debug.LogError("[CharacterSelectionManager] Character positions not assigned!");
            }

            if (availableCharacters == null || availableCharacters.Length == 0)
            {
                Debug.LogError("[CharacterSelectionManager] No available characters configured!");
            }

            if (spotLight == null)
            {
                Debug.LogError("[CharacterSelectionManager] Spotlight not assigned!");
            }
        }

        /// <summary>
        /// Subscribes to all relevant game events for character selection functionality
        /// </summary>
        private void SubscribeToEvents()
        {
            // Core game state events
            GameEvents.OnGameStateChanged.AddListener(HandleGameStateChanged);
            GameEvents.OnProfileSelected.AddListener(HandleProfileSelected);
            GameEvents.OnProfileNavigationInput.AddListener(HandleNavigationInput);

            // Character pointer interaction events
            GameEvents.OnCharacterHoverEnter.AddListener(HandleCharacterHoverEnter);
            GameEvents.OnCharacterHoverExit.AddListener(HandleCharacterHoverExit);
            GameEvents.OnCharacterSelected.AddListener(HandleCharacterSelected);
            GameEvents.OnCharacterDetailsRequested.AddListener(HandleCharacterDetails);
            GameEvents.OnCharacterSelectionCancelled.AddListener(HandleSelectionCancelled);

            Debug.Log("[CharacterSelectionManager] Subscribed to all events");
        }

        /// <summary>
        /// Unsubscribes from all events to prevent memory leaks
        /// </summary>
        private void UnsubscribeFromEvents()
        {
            // Core game state events
            GameEvents.OnGameStateChanged.RemoveListener(HandleGameStateChanged);
            GameEvents.OnProfileSelected.RemoveListener(HandleProfileSelected);
            GameEvents.OnProfileNavigationInput.RemoveListener(HandleNavigationInput);

            // Character pointer interaction events
            GameEvents.OnCharacterHoverEnter.RemoveListener(HandleCharacterHoverEnter);
            GameEvents.OnCharacterHoverExit.RemoveListener(HandleCharacterHoverExit);
            GameEvents.OnCharacterSelected.RemoveListener(HandleCharacterSelected);
            GameEvents.OnCharacterDetailsRequested.RemoveListener(HandleCharacterDetails);
            GameEvents.OnCharacterSelectionCancelled.RemoveListener(HandleSelectionCancelled);

            Debug.Log("[CharacterSelectionManager] Unsubscribed from all events");
        }


        private void HandleGameStateChanged(GameState newState)
        {
            switch (newState)
            {
                case GameState.CharacterSelect:
                    InitializeCharacterSelection();
                    characterSelectionCameraPosition = Camera.main.transform.position;
                    break;
                case GameState.MainMenu:
                case GameState.LevelSelect:
                    CleanupCharacterSelection();
                    break;
            }
        }

        private void HandleProfileSelected(string profileId)
        {
            var profile = profileManager.GetProfile(profileId);
            if (profile != null)
            {
                LoadCharacterProgressionData(profile);
            }
        }

        private void HandleNavigationInput(float direction)
        {
            if (isTransitioning) return;

            int newIndex = currentSpotlightIndex;
            if (direction > 0 && currentSpotlightIndex < characterPositions.Length - 1)
            {
                newIndex++;
            }
            else if (direction < 0 && currentSpotlightIndex > 0)
            {
                newIndex--;
            }

            if (newIndex != currentSpotlightIndex)
            {
                RotateSpotlightToIndex(newIndex);
            }
        }

        private async void InitializeCharacterSelection()
        {
            Debug.Log("[CharacterSelectionManager] Starting character selection initialization");

            // Ensure manager references are valid before proceeding
            if (!EnsureManagerReferences())
            {
                Debug.LogError("[CharacterSelectionManager] Cannot initialize character selection - invalid manager references!");
                return;
            }

            isTransitioning = true;

            try
            {
                Debug.Log($"[CharacterSelectionManager] ProfileManager state - Instance: {(profileManager != null ? "exists" : "null")}, " +
                    $"ActiveProfile: {(profileManager?.ActiveProfile != null ? profileManager.ActiveProfile.ProfileId : "null")}");

                CleanupCharacterSelection();

                var profile = profileManager.ActiveProfile;
                if (profile == null)
                {
                    Debug.LogError("[CharacterSelectionManager] No active profile found! Character selection cannot proceed.");
                    return;
                }

                LoadCharacterProgressionData(profile);

                // Spawn all characters

                for (int i = 0; i < availableCharacters.Length; i++)
                {
                    var characterData = availableCharacters[i];
                    await SpawnCharacter(characterData, characterPositions[i]);
                }

                uiManager.Initialize(availableCharacters);
                currentSpotlightIndex = 0;
                RotateSpotlightToIndex(currentSpotlightIndex);
            }
            catch (Exception e)
            {
                Debug.LogError($"[CharacterSelectionManager] Error during initialization: {e.Message}\n{e.StackTrace}");
            }
            finally
            {
                isTransitioning = false;
            }
        }

        private async Task SpawnCharacter(CharacterData characterData, Transform position)
        {
            try
            {
                GameObject characterInstance = await displayManager.SpawnCharacter(
                    characterData,
                    position.position,
                    position.rotation
                );

                if (characterInstance != null)
                {
                    // Add debug logging to verify setup
                    Debug.Log($"[CharacterSelectionManager] Setting up character {characterData.characterId}");

                    // Check if pointer handler exists and is properly initialized
                    var pointerHandler = characterInstance.GetComponent<CharacterPointerHandler>();
                    if (pointerHandler == null)
                    {
                        pointerHandler = characterInstance.AddComponent<CharacterPointerHandler>();
                        Debug.Log($"[CharacterSelectionManager] Added CharacterPointerHandler to {characterData.characterId}");
                    }
                    pointerHandler.Initialize(characterData.characterId);

                    // Verify layer setup
                    characterInstance.layer = LayerMask.NameToLayer("Character");
                    Debug.Log($"[CharacterSelectionManager] Set layer for {characterData.characterId} to Character");

                    // Store references
                    spawnedCharacters[characterData.characterId] = characterInstance;

                    // Determine character state
                    bool isUnlocked = IsCharacterUnlocked(characterData.characterId);
                    characterStates[characterData.characterId] = isUnlocked ? CharacterDisplayState.Idle : CharacterDisplayState.Locked;

                    // Update interactability
                    if (isUnlocked)
                    {
                        pointerHandler.SetInteractable(true);
                    }
                    else
                    {
                        // Allow hover but disable click for locked characters
                        pointerHandler.SetInteractable(false, allowHover: true);
                        Debug.Log($"[CharacterSelectionManager] Character {characterData.characterId} is locked but hoverable");
                    }

                    Debug.Log($"[CharacterSelectionManager] Character setup complete - ID: {characterData.characterId}, Unlocked: {isUnlocked}");
                }
            }
            catch (Exception e)
            {
                Debug.LogError($"[CharacterSelectionManager] Failed to spawn character {characterData.characterId}: {e.Message}");
            }
        }


        /// <summary>
        /// Handles mouse hover enter events for characters
        /// </summary>
        /// <param name="characterId">ID of the character being hovered</param>
        private void HandleCharacterHoverEnter(string characterId)
        {
            if (isTransitioning || cameraFocused) return;

            for (int i = 0; i < availableCharacters.Length; i++)
            {
                if (availableCharacters[i].characterId == characterId)
                {
                    if (currentSpotlightIndex != i)
                    {
                        RotateSpotlightToIndex(i);
                    }

                    var characterTransform = characterPositions[i];

                    bool isUnlocked = IsCharacterUnlocked(characterId);
                    // Set hover state - for locked characters this means "Locked" state
                    SetCharacterState(characterId, isUnlocked ? CharacterDisplayState.Hover : CharacterDisplayState.Locked);

                    // Update UI based on lock state
                    if (isUnlocked)
                    {
                        uiManager.UpdatePanelPositions(characterTransform);
                        uiManager.ShowCharacterPreview(availableCharacters[i]);
                    }
                    else
                    {
                        uiManager.HideAllPanels();
                        uiManager.UpdatePanelPositions(characterTransform);
                        uiManager.ShowUnlockRequirements(availableCharacters[i]);
                    }
                    break;
                }
            }
        }

        /// <summary>
        /// Handles mouse hover exit events for characters
        /// </summary>
        /// <param name="characterId">ID of the character no longer being hovered</param>
        private void HandleCharacterHoverExit(string characterId)
        {
            bool isUnlocked = IsCharacterUnlocked(characterId);

            // Set the state back - for locked characters this means Idle
            SetCharacterState(characterId, isUnlocked ? CharacterDisplayState.Idle : CharacterDisplayState.Idle);

            if (!isUnlocked)
            {
                uiManager.HideUnlockPanel();
            }
        }

        /// <summary>
        /// Handles character selection via mouse click
        /// </summary>
        /// <param name="characterId">ID of the selected character</param>
        private async void HandleCharacterSelected(string characterId)
        {
            // Guard checks
            if (isTransitioning || string.IsNullOrEmpty(characterId)) return;
            isTransitioning = true;
            currentlySelectedCharacterId = characterId;

            if (!spawnedCharacters.TryGetValue(characterId, out GameObject selectedCharacter))
            {
                Debug.LogError($"[CharacterSelectionManager] Selected character {characterId} not found");
                isTransitioning = false;
                return;
            }

            try
            {
                // 1) Store current states before we override them
                oldInteractableStates.Clear();
                oldDisplayStates.Clear();
                foreach (var kvp in spawnedCharacters)
                {
                    string id = kvp.Key;
                    GameObject obj = kvp.Value;

                    // Capture 'interactable' from CharacterPointerHandler
                    var pointerHandler = obj.GetComponent<CharacterPointerHandler>();
                    if (pointerHandler != null)
                    {
                        oldInteractableStates[id] = pointerHandler.IsInteractable;
                    }

                    // Capture display state from characterStates dictionary
                    if (characterStates.TryGetValue(id, out var currentState))
                    {
                        oldDisplayStates[id] = currentState;
                    }
                }

                // 2) Disable interactions for everyone so the user canâ€™t hover/click others
                //    but allow a 'Cancel' if you want. For example:
                SetCharactersInteractable(false, allowCancel: true);

                // 3) Change this selected one to "Selected" state
                SetCharacterState(characterId, CharacterDisplayState.Selected);

                // 4) Focus camera on the selected character
                await cameraManager.FocusCameraOnCharacter(
                    selectedCharacter.transform,
                    focusHeightOffset,
                    focusDistance,
                    focusTransitionDuration,
                    cameraFocusFieldOfView,
                    lookOffset
                );

                cameraFocused = true;
                isTransitioning = false;

                // Show details & confirmation UI
                uiManager.ShowDetails(characterId);
                uiManager.ShowConfirmationPanel(true);

                // Add listeners for confirm/cancel
                GameEvents.OnCharacterConfirmed.AddListener(HandleCharacterConfirmed);
                GameEvents.OnCharacterSelectionCancelled.AddListener(HandleSelectionCancelled);
            }
            catch (Exception ex)
            {
                Debug.LogError($"[CharacterSelectionManager] Error in HandleCharacterSelected: {ex.Message}");
                isTransitioning = false;
            }
        }



        private async Task ResetToCharacterSelectionView()
        {
            if (cameraManager == null) return;

            await cameraManager.TransitionToPosition(
                 cameraManager.CharacterSelectCameraPosition.position,
                 cameraManager.CharacterSelectCameraPosition.rotation,
                 focusTransitionDuration,
                 defaultFieldOfView
            );
        }


        private async void HandleCharacterConfirmed()
        {
            try
            {
                CleanupSelectionListeners();
                await SelectCharacter(currentlySelectedCharacterId);
                ResetSelectionState();
                GameEvents.OnGameStateChanged.Invoke(GameState.LevelSelect);
            }
            catch (Exception ex)
            {
                Debug.LogError($"[CharacterSelectionManager] Error during character confirmation: {ex.Message}");
                ResetSelectionState();
            }
        }


        private async void HandleSelectionCancelled()
        {
            if (isTransitioning) return;
            isTransitioning = true;

            try
            {
                // Hide UI
                uiManager.ShowConfirmationPanel(false);
                uiManager.HideAllPanels();

                // Return to the wide camera view
                await ResetToCharacterSelectionView();

                // 1) Restore each character's old display + interactable states
                foreach (var kvp in spawnedCharacters)
                {
                    string id = kvp.Key;
                    GameObject obj = kvp.Value;

                    // Display State
                    if (oldDisplayStates.TryGetValue(id, out CharacterDisplayState oldState))
                    {
                        SetCharacterState(id, oldState);
                    }

                    // Interactable
                    var pointerHandler = obj.GetComponent<CharacterPointerHandler>();
                    if (pointerHandler != null && oldInteractableStates.TryGetValue(id, out bool oldInteractable))
                    {
                        pointerHandler.SetInteractable(oldInteractable);
                    }
                }

                // 2) Clear our dictionaries so they don't accumulate old data
                oldDisplayStates.Clear();
                oldInteractableStates.Clear();

                // 3) Reset internal selection state
                ResetSelectionState();
                cameraFocused = false;
            }
            catch (Exception ex)
            {
                Debug.LogError($"[CharacterSelectionManager] Error during HandleSelectionCancelled: {ex.Message}");
            }
            finally
            {
                isTransitioning = false;
            }
        }





        private void SetCharactersInteractable(bool interactable, bool allowCancel = false)
        {
            foreach (var character in spawnedCharacters.Values)
            {
                var pointerHandler = character.GetComponent<CharacterPointerHandler>();
                if (pointerHandler != null)
                {
                    // For selected character, only allow cancel interaction
                    if (character.name.Contains(currentlySelectedCharacterId))
                    {
                        pointerHandler.SetInteractable(allowCancel, allowHover: false);
                    }
                    else
                    {
                        pointerHandler.SetInteractable(interactable, allowHover: interactable);
                    }
                }
            }
        }

        private void CleanupSelectionListeners()
        {
            GameEvents.OnCharacterConfirmed.RemoveListener(HandleCharacterConfirmed);
            GameEvents.OnCharacterSelectionCancelled.RemoveListener(HandleSelectionCancelled);
        }

        private void ResetSelectionState()
        {
            isTransitioning = false;
            CleanupSelectionListeners();
            uiManager.HideAllPanels();
        }

       
        /// <summary>
        /// Handles requests to view character details
        /// </summary>
        /// <param name="characterId">ID of the character whose details were requested</param>
        private void HandleCharacterDetails(string characterId)
        {
            if (isTransitioning || !IsCharacterUnlocked(characterId)) return;
            uiManager.ShowDetails(characterId);
        }


        private void LoadCharacterProgressionData(ProfileData profile)
        {
            if (profile == null) return;

            foreach (var characterProgress in profile.CharacterProgress)
            {
                string characterId = characterProgress.Key;
                var progressData = characterProgress.Value;
                uiManager.UpdateCharacterProgress(characterId, progressData);
            }
        }

        private Coroutine spotlightFollowCoroutine;

        private void RotateSpotlightToIndex(int index)
        {
            // Basic checks
            if (index < 0 || index >= characterPositions.Length || isTransitioning) return;

            // Mark weâ€™re transitioning only while we pick new index
            isTransitioning = true;
            currentSpotlightIndex = index;

            // Update the character states or UI
            UpdateCharacterStates(index);

            // Get the character data and GameObject
            CharacterData charData = availableCharacters[index];
            if (!spawnedCharacters.TryGetValue(charData.characterId, out GameObject characterObj))
            {
                Debug.LogError($"[CharacterSelectionManager] Character not found at index {index} ({charData.characterId})");
                isTransitioning = false;
                return;
            }

            // Stop any old tracking so we only have one coroutine running
            if (spotlightFollowCoroutine != null)
            {
                StopCoroutine(spotlightFollowCoroutine);
            }

            // Start a new coroutine that smoothly follows the character
            spotlightFollowCoroutine = StartCoroutine(SmoothlyTrackCharacter(characterObj.transform));
            isTransitioning = false;
        }

        /// <summary>
        /// Continuously rotates the spotlight to face the given transform,
        /// using a smooth Slerp so it doesn't snap suddenly.
        /// </summary>
        private IEnumerator SmoothlyTrackCharacter(Transform targetCharacterRoot)
        {
            // Early exit if we don't have a target
            if (!targetCharacterRoot)
            {
                Debug.LogError("[CharacterSelectionManager] SmoothlyTrackCharacter called with null target.");
                yield break;
            }

            // Find the Hips bone (the Transform we want to track)
            Transform hipsBone = FindHipsBone(targetCharacterRoot);

            // If Hips bone is not found, log an error and exit the coroutine
            if (!hipsBone)
            {
                Debug.LogError($"[CharacterSelectionManager] Hips bone not found on {targetCharacterRoot.name} or its children.");
                yield break;
            }

            // Track the Hips bone's position
            while (true)
            {
                // Calculate look-at point (with vertical offset)
                Vector3 lookAtPoint = hipsBone.position + Vector3.up * spotlightVerticalOffset;

                // Calculate the desired rotation for the spotlight
                Quaternion targetRotation = Quaternion.LookRotation(lookAtPoint - spotLight.transform.position);

                // Smoothly rotate the spotlight towards the target
                spotLight.transform.rotation = Quaternion.Slerp(spotLight.transform.rotation, targetRotation, Time.deltaTime * spotlightRotationSpeed);

                yield return null; // Wait for the next frame
            }
        }

        // Helper function to find the Hips bone
        private Transform FindHipsBone(Transform characterRoot)
        {
            // Check if the current transform is the Hips bone
            if (characterRoot.name.EndsWith(":Hips"))
            {
                return characterRoot;
            }

            // Recursively search in children
            foreach (Transform child in characterRoot)
            {
                Transform hips = FindHipsBone(child);
                if (hips != null)
                {
                    return hips;
                }
            }

            return null; // Hips bone not found
        }



        private void UpdateCharacterStates(int focusedIndex)
        {
            for (int i = 0; i < availableCharacters.Length; i++)
            {
                var characterData = availableCharacters[i];
                var characterId = characterData.characterId;

                if (!IsCharacterUnlocked(characterId))
                {
                    SetCharacterState(characterId, CharacterDisplayState.Locked);
                    continue;
                }

                if (i == focusedIndex)
                {
                    SetCharacterState(characterId, CharacterDisplayState.Hover);
                }
                // If this is the character that was rightâ€‘clicked for details,
                // keep it on Hover instead of forcing Idle.
                else if (characterId == currentlyHoveredCharacterId)
                {
                    // Do nothing, or explicitly set Hover again
                    SetCharacterState(characterId, CharacterDisplayState.Hover);
                }
                else
                {
                    SetCharacterState(characterId, CharacterDisplayState.Idle);
                }
            }

            if (!string.IsNullOrEmpty(currentlyHoveredCharacterId))
            {
                var characterData = Array.Find(availableCharacters, c => c.characterId == currentlyHoveredCharacterId);
                if (characterData != null)
                {
                    uiManager.ShowCharacterPreview(characterData);
                    uiManager.UpdatePanelPositions(characterPositions[focusedIndex]);
                }
            }
        }

        private void SetCharacterState(string characterId, CharacterDisplayState newState)
        {
            if (!spawnedCharacters.ContainsKey(characterId)) return;

            characterStates[characterId] = newState;
            displayManager.UpdateCharacterState(spawnedCharacters[characterId], newState);
        }

        

        private async Task ResetCameraPosition()
        {
            if (cameraManager == null)
            {
                Debug.LogError("[CharacterSelectionManager] CameraManager is null");
                return;
            }

            await cameraManager.ResetToDefaultPosition(focusTransitionDuration);
        }

        public bool IsCharacterSelected(string characterId)
        {
            return !string.IsNullOrEmpty(currentlySelectedCharacterId);
        }

        public GameObject GetCharacterGameObject(string characterId)
        {
            if (spawnedCharacters.TryGetValue(characterId, out GameObject character))
            {
                return character;
            }
            else
            {
                Debug.LogError($"[CharacterSelectionManager] Character with ID '{characterId}' not found in spawnedCharacters.");
                return null;
            }
        }
        private void CleanupCharacterSelection()
        {
            foreach (var character in spawnedCharacters.Values)
            {
                if (character != null)
                {
                    Destroy(character);
                }
            }

            spawnedCharacters.Clear();
            characterStates.Clear();
            currentlySelectedCharacterId = null;
            currentlyHoveredCharacterId = null;
            isTransitioning = false;
            uiManager.Cleanup();
        }

        #endregion
    }
}
// --- END FILE ---

// File: Characters/CharacterUIManager.cs
// Size: 18324 characters
// ---
// File: Assets/_CyberPickle/Code/Characters/CharacterUIManager.cs
//
// Purpose: Manages the UI elements for character selection, including hover state,
// details panel, and stat displays. Works with CharacterSelectionManager to provide
// visual feedback and interaction options.

using UnityEngine;
using UnityEngine.UI;
using TMPro;
using System.Collections.Generic;
using CyberPickle.Core.Management;
using CyberPickle.Core.Services.Authentication;
using CyberPickle.Characters.Data;
using DG.Tweening;
using CyberPickle.Core.Services.Authentication.Data;
using CyberPickle.Core.Events;

namespace CyberPickle.Characters
{
    public class CharacterUIManager : Manager<CharacterUIManager>
    {
        [Header("Details Panel")]
        [SerializeField] private CanvasGroup detailsPanel;
        [SerializeField] private TextMeshProUGUI detailsCharacterNameText;
        [SerializeField] private TextMeshProUGUI levelText;
        [SerializeField] private Transform statsContainer;
        [SerializeField] private TextMeshProUGUI loreText;
        [SerializeField] private GameObject statRowPrefab;

        [Header("Hover Panel")]
        [SerializeField] private CanvasGroup hoverPanel;
        [SerializeField] private TextMeshProUGUI hoverCharacterNameText;
        [SerializeField] private GameObject leftClickPrompt;
        [SerializeField] private GameObject rightClickPrompt;

        [Header("Unlock Panel")]
        [SerializeField] private CanvasGroup unlockPanel;
        [SerializeField] private TextMeshProUGUI unlockRequirementsText;

        [Header("Confirm Selection Panel")]
        [SerializeField] private CanvasGroup confirmationPanelPrefab; // Prefab reference
        private CanvasGroup confirmationPanel; // Runtime reference to instantiated panel


        [Header("Animation Settings")]
        [SerializeField] private float panelFadeDuration = 0.3f;
        [SerializeField] private float statUpdateDuration = 0.5f;

        [Header("Positioning")]
        [SerializeField] private Vector3 hoverPanelOffset = new Vector3(0, 2, 0);
        [SerializeField] private Vector3 detailsPanelOffsetGeneral = new Vector3(2, 1, 0); // Offset in general view
        [SerializeField] private Vector3 detailsPanelOffsetFocused = new Vector3(-1, 0, 0); // Offset in focused view
        [SerializeField] private Vector3 confirmationPanelOffset = new Vector3(0, 2, 0);

        // Dependencies
        private CharacterSelectionManager characterSelectionManager;
        private ProfileManager profileManager;

        // State tracking
        private string currentCharacterId;
        private Dictionary<string, TextMeshProUGUI> statTextCache;
        private Dictionary<string, CharacterProgressionData> progressionCache;

        protected override void OnManagerAwake()
        {
            base.OnManagerAwake();
            InitializeManagers();
            ValidateReferences();
            InitializeCache();
        }

        public void UpdatePanelPositions(Transform characterPosition)
        {
            if (characterPosition == null) return;

            // Position hover panel above character
            if (hoverPanel != null)
            {
                hoverPanel.transform.position = characterPosition.position + hoverPanelOffset;
            }

            // Position details panel based on camera focus
            if (detailsPanel != null)
            {
                if (characterSelectionManager.IsCharacterSelected(currentCharacterId)) // Focused view
                {
                    detailsPanel.transform.position = characterPosition.position + detailsPanelOffsetFocused;
                    detailsPanel.transform.localScale = new Vector3(0.5f, 0.5f, 0.5f); // Scale in focused view
                }
                else // General view
                {
                    detailsPanel.transform.position = characterPosition.position + detailsPanelOffsetGeneral;
                    detailsPanel.transform.localScale = Vector3.one; // No scaling in general view
                }
            }

            // Position unlock panel above the character (aligned with hover panel)
            if (unlockPanel != null)
            {
                unlockPanel.transform.position = characterPosition.position + hoverPanelOffset;
            }

            // Position confirmation panel above the character
            if (confirmationPanel != null)
            {
                confirmationPanel.transform.position = characterPosition.position + confirmationPanelOffset;
            }
        }
        private void InitializeManagers()
        {
            characterSelectionManager = CharacterSelectionManager.Instance;
            profileManager = ProfileManager.Instance;

            if (!ValidateManagerReferences())
            {
                Debug.LogError("[CharacterUIManager] Failed to initialize required managers!");
            }
        }

        private bool ValidateManagerReferences()
        {
            return characterSelectionManager != null && profileManager != null;
        }

        private void ValidateReferences()
        {
            if (detailsPanel == null) Debug.LogError("[CharacterUIManager] Details panel is missing!");
            if (hoverPanel == null) Debug.LogError("[CharacterUIManager] Hover panel is missing!");
            if (unlockPanel == null) Debug.LogError("[CharacterUIManager] Unlock panel is missing!");
            if (statsContainer == null) Debug.LogError("[CharacterUIManager] Stats container is missing!");
            if (statRowPrefab == null) Debug.LogError("[CharacterUIManager] Stat row prefab is missing!");
        }

        private void InitializeCache()
        {
            statTextCache = new Dictionary<string, TextMeshProUGUI>();
            progressionCache = new Dictionary<string, CharacterProgressionData>();
            HideAllPanels();
        }

        public void Initialize(CharacterData[] characters)
        {
            ClearUI();
            foreach (var character in characters)
            {
                if (character != null)
                {
                    progressionCache[character.characterId] = GetCharacterProgression(character.characterId);
                }
            }
            Debug.Log("[CharacterUIManager] Initialized with " + characters.Length + " characters");
        }

        public void ShowCharacterPreview(CharacterData character)
        {
            if (character == null) return;

            currentCharacterId = character.characterId;
            bool isUnlocked = characterSelectionManager.IsCharacterUnlocked(character.characterId);

            // Always reset panels before updating
            HideAllPanels();

            // Update hover panel content
            if (hoverCharacterNameText != null)
            {
                hoverCharacterNameText.text = character.displayName;
            }

            // Hide click prompts for locked characters
            if (leftClickPrompt != null) leftClickPrompt.SetActive(isUnlocked);
            if (rightClickPrompt != null) rightClickPrompt.SetActive(isUnlocked);

            // Show the appropriate panel based on unlock state
            if (isUnlocked)
            {
                SetPanelState(hoverPanel, true);
            }
            else
            {
                ShowUnlockRequirements(character);
            }
        }

        public void ShowDetails(string characterId)
        {
            var character = characterSelectionManager.GetCharacterData(characterId);
            if (character == null) return;

            currentCharacterId = characterId;

            // Update details panel content
            if (detailsCharacterNameText != null)
            {
                detailsCharacterNameText.text = character.displayName;
            }

            if (loreText != null)
            {
                loreText.text = character.lore;
            }

            // Get progression data
            var progression = progressionCache.TryGetValue(characterId, out var cachedProgression)
                ? cachedProgression
                : GetCharacterProgression(characterId);

            if (levelText != null && progression != null)
            {
                levelText.text = $"Level {progression.CharacterLevel}";
            }

            // Update and show stats
            UpdateCharacterStats(character, progression);

            // Show details panel
            SetPanelState(hoverPanel, false);
            SetPanelState(detailsPanel, true);
            SetPanelState(unlockPanel, false);

            // Get the character's position
            var characterPosition = characterSelectionManager.GetCharacterGameObject(characterId)?.transform;

            // Position the details panel correctly based on camera view
            if (characterSelectionManager.IsCharacterSelected(currentCharacterId))
            {
                // Focused view (details panel to the left, scaled down)
                if (characterPosition != null)
                {
                    detailsPanel.transform.position = characterPosition.position + detailsPanelOffsetFocused; // Use detailsPanelOffsetFocused
                    detailsPanel.transform.localScale = new Vector3(0.5f, 0.5f, 0.5f);
                }
            }
            else
            {
                // General view (details panel at default position, no scaling)
                if (characterPosition != null)
                {
                    detailsPanel.transform.position = characterPosition.position + detailsPanelOffsetGeneral; // Use detailsPanelOffsetGeneral
                    detailsPanel.transform.localScale = Vector3.one;
                }
            }
        }

        public void ShowConfirmationPanel(bool show)
        {
            Debug.Log($"[CharacterUIManager] ShowConfirmationPanel called with show={show}");

            if (!show)
            {
                if (confirmationPanel != null)
                {
                    // Clean up existing listeners before destroying
                    var buttons = confirmationPanel.GetComponentsInChildren<Button>();
                    foreach (var button in buttons)
                    {
                        button.onClick.RemoveAllListeners();
                    }
                    Destroy(confirmationPanel.gameObject);
                    confirmationPanel = null;
                }
                return;
            }

            if (confirmationPanel == null)
            {
                if (confirmationPanelPrefab == null)
                {
                    Debug.LogError("[CharacterUIManager] Confirmation panel prefab is missing!");
                    return;
                }

                var instance = Instantiate(confirmationPanelPrefab, hoverPanel.transform.parent);
                confirmationPanel = instance.GetComponent<CanvasGroup>();

                if (confirmationPanel != null)
                {
                    var characterPosition = characterSelectionManager.GetCharacterGameObject(currentCharacterId)?.transform;
                    if (characterPosition != null)
                    {
                        confirmationPanel.transform.position = characterPosition.position + confirmationPanelOffset;
                    }
                }

                var buttons = instance.GetComponentsInChildren<Button>();
                foreach (var button in buttons)
                {
                    button.onClick.RemoveAllListeners(); // Clear any existing listeners
                    if (button.gameObject.name.Contains("Confirm"))
                    {
                        button.onClick.AddListener(() => {
                            Debug.Log("[CharacterUIManager] Confirm button clicked");
                            GameEvents.OnCharacterConfirmed?.Invoke();
                        });
                    }
                    else if (button.gameObject.name.Contains("Cancel"))
                    {
                        button.onClick.AddListener(() => {
                            Debug.Log("[CharacterUIManager] Cancel button clicked");
                            GameEvents.OnCharacterSelectionCancelled?.Invoke();
                        });
                    }
                }
            }

            if (confirmationPanel != null)
            {
                confirmationPanel.gameObject.SetActive(true);
                SetPanelState(confirmationPanel, true);
            }
        }

        public void UpdateCharacterProgress(string characterId, CharacterProgressionData progression)
        {
            if (string.IsNullOrEmpty(characterId) || progression == null) return;

            progressionCache[characterId] = progression;

            if (characterId == currentCharacterId)
            {
                var character = characterSelectionManager.GetCharacterData(characterId);
                if (character != null)
                {
                    UpdateCharacterStats(character, progression);
                }
            }
        }

        private void UpdateCharacterStats(CharacterData baseData, CharacterProgressionData progression)
        {
            ClearStatsContainer();

            CreateStatRow("Health", baseData.maxHealth, progression);
            CreateStatRow("Defense", baseData.defense, progression);
            CreateStatRow("Power", baseData.power, progression);
            CreateStatRow("Speed", baseData.speed, progression);
            CreateStatRow("Dexterity", baseData.dexterity, progression);
            CreateStatRow("Luck", baseData.luck, progression);
        }

        private void CreateStatRow(string statName, float baseValue, CharacterProgressionData progression)
        {
            if (statRowPrefab == null || statsContainer == null) return;

            GameObject statRow = Instantiate(statRowPrefab, statsContainer);
            var texts = statRow.GetComponentsInChildren<TextMeshProUGUI>();

            if (texts.Length >= 2)
            {
                texts[0].text = statName;
                texts[1].text = baseValue.ToString("F1");

                string statKey = $"{currentCharacterId}_{statName}";
                statTextCache[statKey] = texts[1];

                // Animate if progressed value exists
                if (progression?.Stats != null && progression.Stats.TryGetValue(statName, out float progressedValue))
                {
                    DOTween.To(
                        () => baseValue,
                        (float value) => texts[1].text = value.ToString("F1"),
                        progressedValue,
                        statUpdateDuration
                    );
                }
            }
        }

        public void ShowUnlockRequirements(CharacterData character)
        {
            if (unlockRequirementsText == null) return;

            string requirements = "Requirements to unlock:\n";

            if (character.requiredPlayerLevel > 1)
            {
                requirements += $"ï¿½ Level {character.requiredPlayerLevel}\n";
            }

            if (character.requiredAchievements != null && character.requiredAchievements.Length > 0)
            {
                foreach (var achievement in character.requiredAchievements)
                {
                    requirements += $"ï¿½ {achievement}\n";
                }
            }

            unlockRequirementsText.text = requirements;
            SetPanelState(unlockPanel, true);
        }

        public void HideUnlockPanel()
        {
            if (unlockPanel != null)
            {
                SetPanelState(unlockPanel, false); // Use the existing method to hide the panel
            }

            Debug.Log("[CharacterUIManager] Unlock panel hidden");
        }
        private CharacterProgressionData GetCharacterProgression(string characterId)
        {
            if (string.IsNullOrEmpty(characterId) || profileManager == null) return null;

            var profile = profileManager.ActiveProfile;
            if (profile?.CharacterProgress == null) return null;

            profile.CharacterProgress.TryGetValue(characterId, out var progression);
            return progression;
        }

        private void SetPanelState(CanvasGroup panel, bool visible)
        {
            if (panel == null) return;

            panel.DOFade(visible ? 1f : 0f, panelFadeDuration);
            panel.interactable = visible;
            panel.blocksRaycasts = visible;
        }

        public void Cleanup()
        {
            ClearUI();
            if (confirmationPanel != null)
            {
                var buttons = confirmationPanel.GetComponentsInChildren<Button>();
                foreach (var button in buttons)
                {
                    button.onClick.RemoveAllListeners();
                }
                Destroy(confirmationPanel.gameObject);
                confirmationPanel = null;
            }
            progressionCache.Clear();
        }

        private void ClearUI()
        {
            HideAllPanels();
            ClearStatsContainer();
            currentCharacterId = null;
        }

        public void HideAllPanels()
        {
            SetPanelState(hoverPanel, false);
            SetPanelState(detailsPanel, false);
            SetPanelState(unlockPanel, false);
        }

        private void ClearStatsContainer()
        {
            if (statsContainer == null) return;

            foreach (Transform child in statsContainer)
            {
                Destroy(child.gameObject);
            }

            statTextCache.Clear();
        }

        protected override void OnManagerDestroyed()
        {
            base.OnManagerDestroyed();
            Cleanup();
        }
    }
}
// --- END FILE ---

// File: Progression/ProgressionManager.cs
// Size: 338 characters
// ---
using CyberPickle.Core.Management;
using CyberPickle.Core.Interfaces;

namespace CyberPickle.Progression
{
    public class ProgressionManager : Manager<ProgressionManager>, IInitializable
    {
        public void Initialize()
        {
            UnityEngine.Debug.Log("ProgressionManager initialized");
        }
    }
}

// --- END FILE ---

// File: Characters/Data/CharacterData.cs
// Size: 5601 characters
// ---
// File: Assets/Code/Characters/Data/CharacterData.cs
//
// Purpose: Defines the base data structure for playable characters in Cyber Pickle.
// This ScriptableObject stores character attributes, stats, unlock requirements,
// and visual references. Stats are aligned with the core gameplay design and 
// character progression systems.
//
// Created: 2024-02-11
// Updated: 2024-02-11

using UnityEngine;
using System;

namespace CyberPickle.Characters.Data
{
    /// <summary>
    /// ScriptableObject that defines the base data for a playable character.
    /// Contains all permanent character data including base stats, unlock requirements,
    /// and visual references. Runtime character state and progression are stored separately
    /// in ProfileData.
    /// </summary>
    [CreateAssetMenu(fileName = "Character", menuName = "CyberPickle/Characters/CharacterData")]
    public class CharacterData : ScriptableObject
    {
        [Header("Basic Info")]
        [Tooltip("Unique identifier for the character")]
        public string characterId;

        [Tooltip("Display name shown in the UI")]
        public string displayName;

        [Tooltip("Short description for character selection screen")]
        [TextArea(3, 5)]
        public string description;

        [Tooltip("Extended character backstory and lore")]
        [TextArea(5, 10)]
        public string lore;

        [Header("Visual References")]
        [Tooltip("The character's prefab containing model and required components")]
        public GameObject characterPrefab;

        [Tooltip("2D icon for UI elements")]
        public Sprite characterIcon;

        [Tooltip("Material applied when character is locked")]
        public Material lockedMaterial;

        [Header("Base Stats")]
        [Tooltip("Maximum health points")]
        public float maxHealth = 100f;

        [Tooltip("Rate of health recovery over time")]
        public float healthRegeneration = 1f;

        [Tooltip("Reduces incoming damage")]
        public float defense = 10f;

        [Tooltip("Enhances weapon damage")]
        public float power = 10f;

        [Tooltip("Affects movement speed")]
        public float speed = 5f;

        [Tooltip("Increases item attraction radius")]
        public float magneticField = 1f;

        [Tooltip("Influences rate of fire")]
        public float dexterity = 10f;

        [Tooltip("Affects drop rates and item rarity")]
        public float luck = 1f;

        [Tooltip("Increases explosion radius and effect areas")]
        public float areaOfEffect = 1f;

        [Header("Unlock Requirements")]
        [Tooltip("If true, character is available from the start")]
        public bool unlockedByDefault;

        [Tooltip("Minimum player level required to unlock")]
        public int requiredPlayerLevel;

        [Tooltip("Achievement IDs required to unlock this character")]
        public string[] requiredAchievements;

        [Header("Animation Parameters")]
        [Tooltip("Trigger parameter for idle animation")]
        public string idleAnimationTrigger = "Idle";

        [Tooltip("Trigger parameter for hover/preview animation")]
        public string hoverAnimationTrigger = "Dance";

        [Tooltip("Trigger parameter for selection animation")]
        public string selectAnimationTrigger = "Selected";

        [Tooltip("Trigger parameter for locked state animation")]
        public string lockedAnimationTrigger = "Locked";

        /// <summary>
        /// Validates the CharacterData when it's created or modified in the editor.
        /// Automatically generates a characterId if none is provided.
        /// </summary>
        private void OnValidate()
        {
            if (string.IsNullOrEmpty(characterId))
            {
                characterId = displayName?.ToLower().Replace(" ", "_") ?? "undefined";
                Debug.Log($"[CharacterData] Auto-generated characterId: {characterId}");
            }

            ValidateStats();
        }

        /// <summary>
        /// Ensures all stats are within valid ranges
        /// </summary>
        private void ValidateStats()
        {
            maxHealth = Mathf.Max(1f, maxHealth);
            healthRegeneration = Mathf.Max(0f, healthRegeneration);
            defense = Mathf.Max(0f, defense);
            power = Mathf.Max(0f, power);
            speed = Mathf.Max(0.1f, speed);
            magneticField = Mathf.Max(0.1f, magneticField);
            dexterity = Mathf.Max(0f, dexterity);
            luck = Mathf.Max(0f, luck);
            areaOfEffect = Mathf.Max(0.1f, areaOfEffect);
        }

#if UNITY_EDITOR
        /// <summary>
        /// Validates required references are assigned in the editor
        /// </summary>
        public bool ValidateReferences()
        {
            if (characterPrefab == null)
            {
                Debug.LogError($"[CharacterData] Character prefab is missing for {displayName}");
                return false;
            }

            if (characterIcon == null)
            {
                Debug.LogError($"[CharacterData] Character icon is missing for {displayName}");
                return false;
            }

            if (lockedMaterial == null)
            {
                Debug.LogError($"[CharacterData] Locked material is missing for {displayName}");
                return false;
            }

            return true;
        }
#endif
    }
}

// --- END FILE ---

// File: Core/Analytics/AnalyticsManager.cs
// Size: 335 characters
// ---
using CyberPickle.Core.Management;
using CyberPickle.Core.Interfaces;

namespace CyberPickle.Core.Analytics
{
    public class AnalyticsManager : Manager<AnalyticsManager>, IInitializable
    {
        public void Initialize()
        {
            UnityEngine.Debug.Log("AnalyticsManager initialized");
        }
    }
}

// --- END FILE ---

// File: Core/Audio/AudioManager.cs
// Size: 356 characters
// ---
using CyberPickle.Core.Management;
using CyberPickle.Core.Interfaces;

namespace CyberPickle.Core.Audio
{
    public class AudioManager : Manager<AudioManager>, IInitializable
    {
        public void Initialize()
        {
            // Basic initialization
            UnityEngine.Debug.Log("AudioManager initialized");
        }
    }
}

// --- END FILE ---

// File: Core/Boot/BootManager.cs
// Size: 10456 characters
// ---
// File: Assets/Code/Core/Boot/BootManager.cs
//
// Purpose: Manages the game's boot sequence, initializing all core systems, services,
// and gameplay managers in the correct order while providing visual feedback.
//
// Created: 2024-02-11
// Updated: 2024-02-11

using UnityEngine;
using System.Collections;
using CyberPickle.Core.Management;
using CyberPickle.Core.Interfaces;
using CyberPickle.Core.Config;
using CyberPickle.Core.Boot.UI;
using CyberPickle.Core.Audio;
using CyberPickle.Core.SaveSystem;
using CyberPickle.Core.Input;
using CyberPickle.Core.Pool;
using CyberPickle.Core.Services.Authentication;
using CyberPickle.Core.Services.Leaderboard;
using CyberPickle.Core.Services.Steam;
using CyberPickle.Core.Analytics;
using CyberPickle.Characters;
using CyberPickle.Progression;
using CyberPickle.Achievements;
using UnityEngine.SceneManagement;
using CyberPickle.Core.Services.Authentication.Flow;



namespace CyberPickle.Core.Boot
{
    public class BootManager : Manager<BootManager>, IInitializable
    {
        [Header("UI")]
        [SerializeField] private BootUIController uiController;

        [Header("Timing")]
        [SerializeField] private float minimumLoadTime = 2f;
        [SerializeField] private float delayBeforeScene = 0.5f;

        private float startTime;
        private ConfigRegistry configRegistry;

        protected override void OnManagerAwake()
        {
            Debug.Log("<color=yellow>[BootManager] Awake called</color>");
            ValidateRequirements();
            startTime = Time.time;
            Initialize();
        }

        private void ValidateRequirements()
        {
            if (uiController == null)
            {
                throw new System.Exception("<color=red>[BootManager] UI Controller is not assigned!</color>");
            }
        }

        public void Initialize()
        {
            Debug.Log("<color=yellow>[BootManager] Starting initialize sequence...</color>");
            uiController.UpdateLoadingText("Starting initialization...");
            uiController.UpdateProgress(0f);
            StartCoroutine(InitializeGameSystems());
        }

        private IEnumerator InitializeGameSystems()
        {
            Debug.Log("<color=yellow>[BootManager] Starting initialization sequence...</color>");

            // Initialize ConfigRegistry first
            bool configSuccess = false;
            yield return StartCoroutine(InitializeConfigRegistry(success => configSuccess = success));

            if (!configSuccess)
            {
                Debug.LogError("<color=red>[BootManager] Failed to initialize configs. Aborting boot sequence.</color>");
                yield break;
            }

            // Initialize core systems
            yield return StartCoroutine(InitializeCore());

            // Initialize services
            yield return StartCoroutine(InitializeServices());

            // Initialize gameplay
            yield return StartCoroutine(InitializeGameplay());

            yield return StartCoroutine(CompleteInitialization());
        }

        // Custom class to handle initialization result
        private class ConfigInitializationResult : CustomYieldInstruction
        {
            public bool Success { get; private set; }

            public ConfigInitializationResult(bool success)
            {
                Success = success;
            }

            public override bool keepWaiting => false;
        }

        private IEnumerator InitializeConfigRegistry(System.Action<bool> onComplete)
        {
            uiController.UpdateLoadingText("Loading Configurations...");
            float progress = 0f;
            uiController.UpdateProgress(progress);

            configRegistry = ConfigRegistry.Instance;
            if (configRegistry == null)
            {
                Debug.LogError("<color=red>[BootManager] Failed to create ConfigRegistry!</color>");
                onComplete?.Invoke(false);
                yield break;
            }

            bool initComplete = false;
            bool initSuccess = false;

            // Start async initialization
            configRegistry.InitializeAsync().ContinueWith(task =>
            {
                initComplete = true;
                initSuccess = !task.IsFaulted;

                if (task.IsFaulted)
                {
                    Debug.LogError($"<color=red>[BootManager] Config initialization failed: {task.Exception.GetBaseException().Message}</color>");
                }
            }, System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext());

            // Show progress while waiting
            while (!initComplete)
            {
                progress = Mathf.PingPong(Time.time * 0.5f, 0.1f);
                uiController.UpdateProgress(progress);
                yield return null;
            }

            if (initSuccess)
            {
                Debug.Log("<color=green>[BootManager] Configurations loaded successfully!</color>");
                uiController.UpdateProgress(0.1f); // Move to 10% progress
            }

            onComplete?.Invoke(initSuccess);
        }

        private IEnumerator InitializeCore()
        {
            uiController.UpdateLoadingText("Initializing Core Systems...");
            float progressStart = 0.1f;
            float progressEnd = 0.4f;
            float step = (progressEnd - progressStart) / 4f;

            // Initialize Input Manager first
            yield return InitializeManager<InputManager>("Input System", progressStart, progressStart + step);

            // Then other systems
            yield return InitializeManager<AudioManager>("Audio System", progressStart + step, progressStart + (step * 2));
            yield return InitializeManager<SaveManager>("Save System", progressStart + (step * 2), progressStart + (step * 3));
            yield return InitializeManager<PoolManager>("Pool System", progressStart + (step * 3), progressEnd);
        }

        private IEnumerator InitializeServices()
        {
            uiController.UpdateLoadingText("Initializing Services...");
            float progressStart = 0.4f;
            float progressEnd = 0.7f;
            float step = (progressEnd - progressStart) / 5f;

            // Initialize AuthFlowManager first
            yield return InitializeManager<AuthenticationFlowManager>("Auth Flow", progressStart, progressStart + step);

            // Then the rest of the services
            yield return InitializeManager<AuthenticationManager>("Authentication", progressStart + step, progressStart + (step * 2));
            yield return InitializeManager<ProfileManager>("Profile Manager", progressStart + (step * 2), progressStart + (step * 3));
            yield return InitializeManager<LeaderboardManager>("Leaderboard", progressStart + (step * 3), progressStart + (step * 4));
            yield return InitializeManager<SteamManager>("Steam", progressStart + (step * 4), progressEnd);
            yield return InitializeManager<AnalyticsManager>("Analytics", progressStart + (step * 4), progressEnd);
        }

        private IEnumerator InitializeGameplay()
        {
            uiController.UpdateLoadingText("Initializing Gameplay Systems...");
            float progressStart = 0.7f;
            float progressEnd = 0.9f;
            float step = (progressEnd - progressStart) / 4f;

            yield return InitializeManager<GameManager>("Game System", progressStart, progressStart + step);
            yield return InitializeManager<CharacterManager>("Character System", progressStart + step, progressStart + (step * 2));
            yield return InitializeManager<ProgressionManager>("Progression System", progressStart + (step * 2), progressStart + (step * 3));
            yield return InitializeManager<AchievementManager>("Achievement System", progressStart + (step * 3), progressEnd);
        }

        private IEnumerator InitializeManager<M>(string systemName, float startProgress, float endProgress)
            where M : Manager<M>, IInitializable
        {
            Debug.Log($"<color=yellow>[BootManager] Initializing {systemName}...</color>");

            M manager = null;
            bool success = false;

            try
            {
                manager = Manager<M>.Instance;
                manager.Initialize();
                success = true;
                Debug.Log($"<color=green>[BootManager] {systemName} initialized successfully!</color>");
            }
            catch (System.Exception e)
            {
                Debug.LogError($"<color=red>[BootManager] Failed to initialize {systemName}: {e.Message}</color>");
                yield break;
            }

            if (success)
            {
                float elapsed = 0f;
                float duration = 0.5f;

                while (elapsed < duration)
                {
                    elapsed += Time.deltaTime;
                    float normalizedTime = elapsed / duration;
                    float currentProgress = Mathf.Lerp(startProgress, endProgress, normalizedTime);
                    uiController.UpdateProgress(currentProgress);
                    yield return null;
                }
            }
        }

        private IEnumerator CompleteInitialization()
        {
            uiController.UpdateLoadingText("Loading Complete");
            uiController.UpdateProgress(1f);

            // Ensure minimum display time
            float elapsedTime = Time.time - startTime;
            if (elapsedTime < minimumLoadTime)
            {
                yield return new WaitForSeconds(minimumLoadTime - elapsedTime);
            }

            yield return new WaitForSeconds(delayBeforeScene);

            // Get mainMenuSceneName from config
            var bootConfig = configRegistry.GetConfig<BootConfig>();
            LoadMainMenuScene(bootConfig.mainMenuSceneName);
        }

        private void LoadMainMenuScene(string sceneName)
        {
            Debug.Log($"<color=green>[BootManager] Loading main menu scene: {sceneName}</color>");
            SceneManager.LoadScene(sceneName);
        }
    }
}




// --- END FILE ---

// File: Core/Boot/BootSceneManager.cs
// Size: 6462 characters
// ---
using UnityEngine;
using UnityEngine.UI;
using TMPro;
using System.Collections;
using UnityEngine.SceneManagement;
using CyberPickle.Core.Management;

namespace CyberPickle.Core.Boot
{
    public class BootSceneManager : Manager<BootSceneManager>
    {
        [Header("UI References")]
        [SerializeField] private CanvasGroup logoCanvasGroup;
        [SerializeField] private TextMeshProUGUI companyNameText;
        [SerializeField] private Image loadingBarFill;
        [SerializeField] private TextMeshProUGUI loadingText;

        [Header("Animation Settings")]
        [SerializeField] private float fadeInDuration = 1.5f;
        [SerializeField] private float displayDuration = 2.0f;
        [SerializeField] private float fadeOutDuration = 1.5f;

        [Header("Scene Settings")]
        [SerializeField] private string mainMenuSceneName = "MainMenu";
        [SerializeField] private float minimumLoadingTime = 3.0f;
        [SerializeField] private bool waitForInput = true; // Add this to make input wait optional

        private float startTime;

        protected override void OnManagerAwake()
        {
            // Ensure canvas group starts invisible
            if (logoCanvasGroup != null)
                logoCanvasGroup.alpha = 0f;

            if (loadingBarFill != null)
                loadingBarFill.fillAmount = 0f;

            startTime = Time.time;
            StartCoroutine(BootSequence());
        }

        private IEnumerator BootSequence()
        {
            // Initial setup
            UpdateLoadingText("Initializing...");
            yield return StartCoroutine(FadeInLogo());

            // Core systems initialization
            yield return StartCoroutine(InitializeSystems());

            // Ensure minimum loading time
            float elapsedTime = Time.time - startTime;
            if (elapsedTime < minimumLoadingTime)
            {
                yield return new WaitForSeconds(minimumLoadingTime - elapsedTime);
            }

            // Display completion
            UpdateLoadingText("Press Any Key to Continue");

            // Wait for display duration
            yield return new WaitForSeconds(displayDuration);

            // Wait for input if enabled
            if (waitForInput)
            {
                yield return StartCoroutine(WaitForAnyKey());
            }

            // Transition out
            yield return StartCoroutine(FadeOutLogo());

            // Load main menu
            LoadMainMenu();
        }

        private IEnumerator WaitForAnyKey()
        {
            bool keyPressed = false;
            while (!keyPressed)
            {
                // Check for any key press or mouse click
                if (UnityEngine.Input.anyKeyDown || UnityEngine.Input.GetMouseButtonDown(0) || UnityEngine.Input.GetMouseButtonDown(1))
                {
                    keyPressed = true;
                }
                yield return null;
            }
        }

        private IEnumerator InitializeSystems()
        {
            float currentProgress = 0f;
            float targetProgress = 0.2f;

            // Audio System
            UpdateLoadingText("Initializing Audio System...");
            yield return StartCoroutine(UpdateProgressBar(currentProgress, targetProgress));
            currentProgress = targetProgress;
            targetProgress = 0.4f;

            // Save System
            UpdateLoadingText("Initializing Save System...");
            yield return StartCoroutine(UpdateProgressBar(currentProgress, targetProgress));
            currentProgress = targetProgress;
            targetProgress = 0.6f;

            // Input System
            UpdateLoadingText("Initializing Input System...");
            yield return StartCoroutine(UpdateProgressBar(currentProgress, targetProgress));
            currentProgress = targetProgress;
            targetProgress = 0.8f;

            // Game Systems
            UpdateLoadingText("Initializing Game Systems...");
            yield return StartCoroutine(UpdateProgressBar(currentProgress, targetProgress));
            currentProgress = targetProgress;
            targetProgress = 1f;

            // Final Setup
            UpdateLoadingText("Completing Setup...");
            yield return StartCoroutine(UpdateProgressBar(currentProgress, targetProgress));
        }

        private IEnumerator FadeInLogo()
        {
            float elapsed = 0f;

            while (elapsed < fadeInDuration)
            {
                elapsed += Time.deltaTime;
                float normalizedTime = elapsed / fadeInDuration;

                if (logoCanvasGroup != null)
                    logoCanvasGroup.alpha = Mathf.Lerp(0f, 1f, normalizedTime);

                yield return null;
            }

            if (logoCanvasGroup != null)
                logoCanvasGroup.alpha = 1f;
        }

        private IEnumerator FadeOutLogo()
        {
            float elapsed = 0f;

            while (elapsed < fadeOutDuration)
            {
                elapsed += Time.deltaTime;
                float normalizedTime = elapsed / fadeOutDuration;

                if (logoCanvasGroup != null)
                    logoCanvasGroup.alpha = Mathf.Lerp(1f, 0f, normalizedTime);

                yield return null;
            }

            if (logoCanvasGroup != null)
                logoCanvasGroup.alpha = 0f;
        }

        private IEnumerator UpdateProgressBar(float from, float to)
        {
            float elapsed = 0f;
            float duration = 0.5f;

            while (elapsed < duration)
            {
                elapsed += Time.deltaTime;
                float normalizedTime = elapsed / duration;

                if (loadingBarFill != null)
                    loadingBarFill.fillAmount = Mathf.Lerp(from, to, normalizedTime);

                yield return null;
            }

            if (loadingBarFill != null)
                loadingBarFill.fillAmount = to;
        }

        private void UpdateLoadingText(string text)
        {
            if (loadingText != null)
                loadingText.text = text;
        }

        private void LoadMainMenu()
        {
            SceneManager.LoadScene(mainMenuSceneName);
        }
    }
}
// --- END FILE ---

// File: Core/Camera/CameraManager.cs
// Size: 13945 characters
// ---
using UnityEngine;
using System.Collections;
using CyberPickle.Core.Management;
using CyberPickle.Core.Events;
using CyberPickle.Core.States;
using UnityEngine.Rendering;
using DG.Tweening;
using System;
using System.Threading.Tasks;

namespace CyberPickle.Core.Camera
{
    public class CameraManager : Manager<CameraManager>
    {
        [Header("Camera References")]
        [SerializeField] private UnityEngine.Camera mainCamera;
        [SerializeField] private Transform menuCameraPosition;
        [SerializeField] private Transform characterSelectCameraPosition;

        [Header("Transition Settings")]
        [SerializeField] private float transitionDuration = 1.5f;
        [SerializeField] private AnimationCurve transitionCurve = AnimationCurve.EaseInOut(0, 0, 1, 1);

        [Header("Camera Animation Settings")]
        [SerializeField] private float menuIdleAmplitude = 0.1f;
        [SerializeField] private float menuIdleFrequency = 1f;
        [SerializeField] private float characterSelectIdleAmplitude = 0.2f;
        [SerializeField] private float characterSelectIdleFrequency = 0.5f;

        [Header("Post Processing")]
        [SerializeField] private Volume menuVolume;
        [SerializeField] private Volume characterSelectVolume;

        [Header("Animation Settings")]
        [SerializeField] private bool enableMenuIdleAnimation = false; // Set to false by default
        [SerializeField] private bool enableCharacterSelectIdleAnimation = true;

        [Header("Camera Settings")]
        [SerializeField] private float defaultFieldOfView = 60f;
        public Transform CharacterSelectCameraPosition => characterSelectCameraPosition;

        private Coroutine currentTransition;
        private Coroutine idleAnimationCoroutine;
        private Vector3 cameraVelocity;
        private Vector3 rotationVelocity;

        protected override void OnManagerAwake()
        {
            base.OnManagerAwake();

            if (mainCamera == null)
            {
                mainCamera = UnityEngine.Camera.main;
                Debug.Log("[CameraManager] Main camera assigned automatically");
            }

            ValidateReferences();
            InitializeCamera();
        }

        protected override void OnManagerEnabled()
        {
            base.OnManagerEnabled();
            SubscribeToEvents();
        }

        protected override void OnManagerDisabled()
        {
            base.OnManagerDisabled();
            UnsubscribeFromEvents();
            StopAllCoroutines();
        }

        protected override void OnManagerDestroyed()
        {
            base.OnManagerDestroyed();
            UnsubscribeFromEvents();
            StopAllCoroutines();
        }

        private void ValidateReferences()
        {
            if (menuCameraPosition == null)
                Debug.LogError("[CameraManager] Menu camera position is not assigned!");
            if (characterSelectCameraPosition == null)
                Debug.LogError("[CameraManager] Character select camera position is not assigned!");
        }


        private void InitializeCamera()
        {
            if (mainCamera != null && menuCameraPosition != null)
            {
                mainCamera.transform.position = menuCameraPosition.position;
                mainCamera.transform.rotation = menuCameraPosition.rotation;

                if (enableMenuIdleAnimation)
                {
                    StartMenuIdleAnimation();
                }
            }
        }

        private void SubscribeToEvents()
        {
            GameEvents.OnGameStateChanged.AddListener(HandleGameStateChanged);
        }

        private void UnsubscribeFromEvents()
        {
            GameEvents.OnGameStateChanged.RemoveListener(HandleGameStateChanged);
        }

        private void HandleGameStateChanged(GameState newState)
        {
            switch (newState)
            {
                case GameState.CharacterSelect:
                    TransitionToCharacterSelect();
                    break;
                case GameState.MainMenu:
                    TransitionToMainMenu();
                    break;
            }
        }

        private void TransitionToCharacterSelect()
        {
            Debug.Log("[CameraManager] Starting transition to character select");
            StopIdleAnimation();

            if (currentTransition != null)
                StopCoroutine(currentTransition);

            currentTransition = StartCoroutine(TransitionCameraRoutine(
                characterSelectCameraPosition.position,
                characterSelectCameraPosition.rotation,
                () => {
                    Debug.Log("[CameraManager] Character select transition complete");
                    StartCharacterSelectIdleAnimation();
                    GameEvents.OnCameraTransitionComplete.Invoke();
                }
            ));
        }

        private void TransitionToMainMenu()
        {
            Debug.Log("[CameraManager] Starting transition to main menu");
            StopIdleAnimation();

            if (currentTransition != null)
                StopCoroutine(currentTransition);

            currentTransition = StartCoroutine(TransitionCameraRoutine(
                menuCameraPosition.position,
                menuCameraPosition.rotation,
                () => {
                    Debug.Log("[CameraManager] Main menu transition complete");
                    StartMenuIdleAnimation();
                    GameEvents.OnCameraTransitionComplete.Invoke();
                }
            ));
        }

        private IEnumerator TransitionCameraRoutine(Vector3 targetPosition, Quaternion targetRotation, System.Action onComplete = null)
        {
            float elapsedTime = 0f;
            Vector3 startPosition = mainCamera.transform.position;
            Quaternion startRotation = mainCamera.transform.rotation;

            while (elapsedTime < transitionDuration)
            {
                elapsedTime += Time.deltaTime;
                float normalizedTime = elapsedTime / transitionDuration;
                float curveValue = transitionCurve.Evaluate(normalizedTime);

                mainCamera.transform.position = Vector3.Lerp(startPosition, targetPosition, curveValue);
                mainCamera.transform.rotation = Quaternion.Slerp(startRotation, targetRotation, curveValue);

                yield return null;
            }

            // Ensure we reach the exact target
            mainCamera.transform.position = targetPosition;
            mainCamera.transform.rotation = targetRotation;

            onComplete?.Invoke();
        }

        private void StartMenuIdleAnimation()
        {
            if (!enableMenuIdleAnimation)
            {
                Debug.Log("[CameraManager] Menu idle animation disabled");
                return;
            }

            StopIdleAnimation();
            idleAnimationCoroutine = StartCoroutine(MenuIdleAnimationRoutine());
        }

        private void StartCharacterSelectIdleAnimation()
        {
            StopIdleAnimation();
            idleAnimationCoroutine = StartCoroutine(CharacterSelectIdleAnimationRoutine());
        }

        private void StopIdleAnimation()
        {
            if (idleAnimationCoroutine != null)
            {
                StopCoroutine(idleAnimationCoroutine);
                idleAnimationCoroutine = null;
            }
        }

        private IEnumerator MenuIdleAnimationRoutine()
        {
            Vector3 startPosition = mainCamera.transform.position;

            while (true)
            {
                float time = Time.time;
                Vector3 newPosition = startPosition;
                newPosition.y += Mathf.Sin(time * menuIdleFrequency) * menuIdleAmplitude;

                mainCamera.transform.position = newPosition;
                yield return null;
            }
        }

        private IEnumerator CharacterSelectIdleAnimationRoutine()
        {
            Vector3 startPosition = mainCamera.transform.position;

            while (true)
            {
                float time = Time.time;
                Vector3 newPosition = startPosition;
                newPosition.y += Mathf.Sin(time * characterSelectIdleFrequency) * characterSelectIdleAmplitude;

                mainCamera.transform.position = newPosition;
                yield return null;
            }
        }

        public void SetPostProcessingBlend(float blend)
        {
            if (menuVolume != null)
                menuVolume.weight = 1 - blend;

            if (characterSelectVolume != null)
                characterSelectVolume.weight = blend;
        }

        public async Task FocusCameraOnCharacter(
     Transform characterTransform,
     float cameraHeightOffset,
     float focusDistance,
     float transitionDuration,
     float targetFOV,
     float lookOffset 
 )
        {
            if (characterTransform == null) return;

            StopIdleAnimation();

            // Position the camera behind & above the character
            Vector3 targetPosition = new Vector3(
                characterTransform.position.x,
                characterTransform.position.y + cameraHeightOffset,
                characterTransform.position.z + focusDistance
            );

            // Shift the look-at point higher than the character's pivot
            Vector3 lookAtPoint = characterTransform.position + Vector3.up * lookOffset;

            // Now calculate rotation toward that higher lookAtPoint
            Vector3 directionToCharacter = lookAtPoint - targetPosition;
            Quaternion targetRotation = Quaternion.LookRotation(directionToCharacter);

            // Move, rotate & set FOV
            await TransitionToPosition(
                targetPosition,
                targetRotation,
                transitionDuration,
                targetFOV
            );
        }

        public async Task TransitionToPosition(Vector3 targetPosition, Quaternion targetRotation, float duration, float targetFOV)
        {
            if (mainCamera == null)
            {
                Debug.LogError("[CameraManager] Main camera is null!");
                return;
            }

            Debug.Log($"[CameraManager] Starting camera transition to position: {targetPosition}");

            try
            {
                // Store original values for potential reset
                Vector3 originalPosition = mainCamera.transform.position;
                Quaternion originalRotation = mainCamera.transform.rotation;
                float originalFOV = mainCamera.fieldOfView;

                // Create a sequence for synchronized animations
                Sequence cameraSequence = DOTween.Sequence();

                // Add position transition
                cameraSequence.Join(mainCamera.transform.DOMove(targetPosition, duration)
                    .SetEase(transitionCurve));

                // Add rotation transition
                cameraSequence.Join(mainCamera.transform.DORotateQuaternion(targetRotation, duration)
                    .SetEase(transitionCurve));

                // Add FOV transition
                cameraSequence.Join(DOTween.To(() => mainCamera.fieldOfView,
                    x => mainCamera.fieldOfView = x,
                    targetFOV,
                    duration)
                    .SetEase(transitionCurve));

                // Wait for sequence completion
                await cameraSequence.AsyncWaitForCompletion();

                Debug.Log("[CameraManager] Camera transition completed successfully");
                GameEvents.OnCameraTransitionComplete.Invoke();
            }
            catch (Exception ex)
            {
                Debug.LogError($"[CameraManager] Error during camera transition: {ex.Message}");
                throw;
            }
        }

        public async Task ResetToDefaultPosition(float duration)
        {
            if (mainCamera == null || menuCameraPosition == null)
            {
                Debug.LogError("[CameraManager] Required references are null!");
                return;
            }

            Debug.Log("[CameraManager] Resetting camera to default position");

            try
            {
                // Get default values from menu camera position
                Vector3 defaultPosition = menuCameraPosition.position;
                Quaternion defaultRotation = menuCameraPosition.rotation;
                float defaultFOV = mainCamera.fieldOfView; // You might want to store this as a serialized field

                // Create transition sequence
                Sequence resetSequence = DOTween.Sequence();

                // Add position reset
                resetSequence.Join(mainCamera.transform.DOMove(defaultPosition, duration)
                    .SetEase(transitionCurve));

                // Add rotation reset
                resetSequence.Join(mainCamera.transform.DORotateQuaternion(defaultRotation, duration)
                    .SetEase(transitionCurve));

                // Wait for sequence completion
                await resetSequence.AsyncWaitForCompletion();

                Debug.Log("[CameraManager] Camera reset completed successfully");
                GameEvents.OnCameraTransitionComplete.Invoke();
            }
            catch (Exception ex)
            {
                Debug.LogError($"[CameraManager] Error during camera reset: {ex.Message}");
                throw;
            }
        }
    }
}
// --- END FILE ---

// File: Core/Config/ConfigRegistry.cs
// Size: 5509 characters
// ---
// File: Assets/Code/Core/Config/ConfigRegistry.cs
//
// Purpose: Central registry for all game configuration ScriptableObjects.
// Loads and manages access to all configuration assets using the Addressables system.
// Ensures configs are loaded before any manager initialization.
//
// Created: 2024-02-11
// Updated: 2024-02-11

// File: Assets/Code/Core/Config/ConfigRegistry.cs

using UnityEngine;
using UnityEngine.AddressableAssets;
using UnityEngine.ResourceManagement.AsyncOperations;
using System.Collections.Generic;
using System.Threading.Tasks;
using System;
using CyberPickle.Core.Management;

namespace CyberPickle.Core.Config
{
    public class ConfigRegistry : Manager<ConfigRegistry>
    {
        private readonly Dictionary<Type, ScriptableObject> configs = new Dictionary<Type, ScriptableObject>();
        private readonly Dictionary<Type, AsyncOperationHandle> operationHandles = new Dictionary<Type, AsyncOperationHandle>();
        private bool isInitialized = false;

        private const string BOOT_CONFIG_KEY = "config/boot";
        private const string GAME_CONFIG_KEY = "config/game";

        protected override void OnManagerAwake()
        {
            Debug.Log("<color=yellow>[ConfigRegistry] Initializing...</color>");
        }

        public async Task InitializeAsync()
        {
            if (isInitialized)
            {
                Debug.LogWarning("[ConfigRegistry] Already initialized!");
                return;
            }

            try
            {
                await LoadCoreConfigs();
                await LoadUIConfigs();

                isInitialized = true;
                Debug.Log("<color=green>[ConfigRegistry] All configs loaded successfully!</color>");
            }
            catch (Exception e)
            {
                Debug.LogError($"<color=red>[ConfigRegistry] Failed to initialize: {e.Message}</color>");
                throw;
            }
        }

        private async Task LoadCoreConfigs()
        {
            Debug.Log("[ConfigRegistry] Loading core configs...");

            try
            {
                await LoadConfigAsync<BootConfig>(BOOT_CONFIG_KEY);
                await LoadConfigAsync<GameConfig>(GAME_CONFIG_KEY);
            }
            catch (Exception e)
            {
                throw new Exception($"Failed to load core configs: {e.Message}", e);
            }
        }

        private async Task LoadUIConfigs()
        {
            Debug.Log("[ConfigRegistry] Loading UI configs...");

            try
            {
                var loadOperation = Addressables.LoadAssetsAsync<ScriptableObject>(
                    "config-ui",
                    (config) =>
                    {
                        // This is called for each loaded asset
                        RegisterConfig(config);
                    }
                );

                operationHandles[typeof(ScriptableObject)] = loadOperation;
                await loadOperation.Task;

                if (loadOperation.Status != AsyncOperationStatus.Succeeded)
                {
                    throw new Exception($"UI configs load operation failed");
                }
            }
            catch (Exception e)
            {
                Debug.LogWarning($"[ConfigRegistry] UI configs failed to load: {e.Message}");
                // Don't throw here - UI configs aren't critical
            }
        }

        private async Task<T> LoadConfigAsync<T>(string key) where T : ScriptableObject
        {
            try
            {
                var loadOperation = Addressables.LoadAssetAsync<T>(key);
                operationHandles[typeof(T)] = loadOperation;

                await loadOperation.Task;

                if (loadOperation.Status != AsyncOperationStatus.Succeeded)
                {
                    throw new Exception($"Failed to load config at key: {key}");
                }

                var config = loadOperation.Result;
                RegisterConfig(config);
                return config;
            }
            catch (Exception e)
            {
                throw new Exception($"Error loading config {typeof(T).Name}: {e.Message}", e);
            }
        }

        private void RegisterConfig<T>(T config) where T : ScriptableObject
        {
            var type = config.GetType();
            configs[type] = config;
            Debug.Log($"[ConfigRegistry] Registered config: {type.Name}");
        }

        public T GetConfig<T>() where T : ScriptableObject
        {
            if (!isInitialized)
            {
                throw new InvalidOperationException("[ConfigRegistry] Attempted to get config before initialization!");
            }

            if (configs.TryGetValue(typeof(T), out ScriptableObject config))
            {
                return config as T;
            }

            throw new Exception($"[ConfigRegistry] Config not found for type: {typeof(T).Name}");
        }

        protected override void OnManagerDestroyed()
        {
            foreach (var handle in operationHandles.Values)
            {
                if (handle.IsValid())
                {
                    Addressables.Release(handle);
                }
            }

            operationHandles.Clear();
            configs.Clear();
        }
    }
}

// --- END FILE ---

// File: Core/GameManager/GameManager.cs
// Size: 8137 characters
// ---
using UnityEngine;
using UnityEngine.SceneManagement;
using System.Collections;
using CyberPickle.Core.Management;
using CyberPickle.Core.Events;
using CyberPickle.Core.States;
using CyberPickle.Core.Config;
using CyberPickle.Core.Interfaces;

namespace CyberPickle.Core
{
    public class GameManager : Manager<GameManager>, IInitializable
    {

        private GameConfig gameConfig;
        private GameState currentState = GameState.None;
        private GameState previousState = GameState.None;
        private bool isInitialized;
        private bool isPaused;

        public GameState CurrentState => currentState;
        public bool IsPaused => isPaused;

        #region Initialization

        public void Initialize()
        {
            if (isInitialized) return;

            LoadGameConfig();
            if (gameConfig == null)
            {
                Debug.LogError("<color=red>[GameManager] Failed to load GameConfig. Cannot initialize!</color>");
                return;
            }

            RegisterEventListeners();
            isInitialized = true;

            GameEvents.OnGameInitialized.Invoke();
        }

        private void RegisterEventListeners()
        {
            // Register for events that might affect game state
            GameEvents.OnPlayerDied.AddListener(HandlePlayerDeath);
            GameEvents.OnLevelCompleted.AddListener(HandleLevelCompleted);
        }

        private void LoadGameConfig()
        {
            try
            {
                var configRegistry = ConfigRegistry.Instance;
                if (configRegistry == null)
                {
                    throw new System.Exception("ConfigRegistry not initialized!");
                }

                gameConfig = configRegistry.GetConfig<GameConfig>();
                if (gameConfig == null)
                {
                    throw new System.Exception("GameConfig not found in registry!");
                }

                Debug.Log("<color=green>[GameManager] GameConfig loaded successfully!</color>");
            }
            catch (System.Exception e)
            {
                Debug.LogError($"<color=red>[GameManager] Failed to load GameConfig: {e.Message}</color>");
            }
        }

        #endregion

        #region Game Flow Control

        public void StartNewGame()
        {
            StartCoroutine(StartNewGameSequence());
        }

        private IEnumerator StartNewGameSequence()
        {
            ChangeState(GameState.Loading);

            // Load character select scene
            yield return LoadSceneAsync(gameConfig.characterSelectSceneName);
            ChangeState(GameState.CharacterSelect);
        }

        public void StartLevel(string levelId)
        {
            StartCoroutine(StartLevelSequence(levelId));
        }

        private IEnumerator StartLevelSequence(string levelId)
        {
            ChangeState(GameState.Loading);

            // Load game scene
            yield return LoadSceneAsync(gameConfig.gameSceneName);

            // Initialize level
            yield return new WaitForSeconds(gameConfig.gameStartDelay);

            ChangeState(GameState.Playing);
            GameEvents.OnGameStarted.Invoke();
        }

        public void PauseGame()
        {
            if (currentState != GameState.Playing) return;

            isPaused = true;
            Time.timeScale = 0f;
            ChangeState(GameState.Paused);
            GameEvents.OnGamePaused.Invoke();
        }

        public void ResumeGame()
        {
            if (currentState != GameState.Paused) return;

            isPaused = false;
            Time.timeScale = 1f;
            ChangeState(GameState.Playing);
            GameEvents.OnGameResumed.Invoke();
        }

        public void GameOver()
        {
            StartCoroutine(GameOverSequence());
        }

        private IEnumerator GameOverSequence()
        {
            yield return new WaitForSeconds(gameConfig.gameOverDelay);

            ChangeState(GameState.GameOver);
            GameEvents.OnGameOver.Invoke();

            // Load post-game scene
            yield return LoadSceneAsync(gameConfig.postGameSceneName);
            ChangeState(GameState.PostGame);
        }

        #endregion

        #region State Management

        private void ChangeState(GameState newState)
        {
            if (currentState == newState) return;

            previousState = currentState;
            currentState = newState;

            Debug.Log($"Game State Changed: {previousState} -> {currentState}");

            HandleStateChange();
        }

        private void HandleStateChange()
        {
            switch (currentState)
            {
                case GameState.MainMenu:
                    Time.timeScale = 1f;
                    break;

                case GameState.Playing:
                    Time.timeScale = 1f;
                    break;

                case GameState.Paused:
                    Time.timeScale = 0f;
                    break;

                case GameState.GameOver:
                    Time.timeScale = 0f;
                    break;
            }
        }

        #endregion

        #region Event Handlers

        private void HandlePlayerDeath()
        {
            if (currentState == GameState.Playing)
            {
                GameOver();
            }
        }

        private void HandleLevelCompleted(string levelId)
        {
            if (currentState == GameState.Playing)
            {
                StartCoroutine(LevelCompleteSequence(levelId));
            }
        }

        private IEnumerator LevelCompleteSequence(string levelId)
        {
            // Save progress
            SaveProgress();

            // Show level complete UI
            yield return new WaitForSeconds(2f);

            // Load post-game scene
            yield return LoadSceneAsync(gameConfig.postGameSceneName);
            ChangeState(GameState.PostGame);
        }

        #endregion

        #region Utility Methods

        private void SaveProgress()
        {
            // This will be implemented when we create the SaveSystem
            Debug.Log("Saving game progress...");
        }

        private IEnumerator LoadSceneAsync(string sceneName)
        {
            AsyncOperation asyncLoad = SceneManager.LoadSceneAsync(sceneName);

            while (!asyncLoad.isDone)
            {
                float progress = Mathf.Clamp01(asyncLoad.progress / 0.9f);
                // Could dispatch loading progress event here
                yield return null;
            }
        }

        #endregion

        #region Debug Methods

        public void ToggleDebugMode()
        {
            if (!gameConfig.enableDebugMode) return;

            // Add debug functionality
            Debug.Log("Debug mode toggled");
        }

        #endregion

        protected override void OnManagerAwake()
        {
            Debug.Log("<color=yellow>[GameManager] Initializing...</color>");
            Initialize();
        }

        private void OnApplicationPause(bool pauseStatus)
        {
            if (pauseStatus && currentState == GameState.Playing)
            {
                PauseGame();
            }
        }
        protected override void OnManagerDestroyed()
        {
            if (!IsActiveInstance) return;

            try
            {
                SaveProgress();
            }
            catch (System.Exception e)
            {
                Debug.LogError($"Error saving progress during shutdown: {e.Message}");
            }

            // Cleanup event listeners
            GameEvents.OnPlayerDied.RemoveListener(HandlePlayerDeath);
            GameEvents.OnLevelCompleted.RemoveListener(HandleLevelCompleted);
        }
    }
}

// --- END FILE ---

// File: Core/Input/InputManager.cs
// Size: 10672 characters
// ---
using UnityEngine;
using CyberPickle.Core.Management;
using CyberPickle.Core.Events;
using CyberPickle.Core.Interfaces;
using CyberPickle.Core.States;

#if ENABLE_INPUT_SYSTEM
using UnityEngine.InputSystem;
using UnityEngine.InputSystem.Controls;
#endif

namespace CyberPickle.Core.Input
{
    public class InputManager : Manager<InputManager>, IInitializable
    {
        [Header("Input Settings")]
        [SerializeField, Tooltip("Mouse sensitivity multiplier for horizontal movement")]
        private float mouseSensitivity = 1.5f;

        [SerializeField, Tooltip("Touch sensitivity multiplier for horizontal movement")]
        private float touchSensitivity = 1.5f;

        [SerializeField, Tooltip("Keyboard sensitivity multiplier for horizontal movement")]
        private float keyboardSensitivity = 0.1f;

        [Header("Dead Zones")]
        [SerializeField, Tooltip("Minimum mouse movement required to trigger input")]
        private float mouseDeadZone = 0.01f;

        [SerializeField, Tooltip("Minimum touch movement required to trigger input")]
        private float touchDeadZone = 0.001f;

        private GameState currentGameState;
        private bool isInputEnabled = true;
        private bool isInitialized;

#if ENABLE_INPUT_SYSTEM
        private InputAction moveAction;
        private InputAction anyKeyAction;
        private InputAction touchPositionAction;
        private InputAction touchPressAction;
        private InputAction mousePositionAction;
        private InputAction mouseButtonAction;
        private InputAction profileNavigationAction;
        private Vector2 previousTouchPosition;
        private Vector2 previousMousePosition;
        private bool isMousePressed;
#endif

        public void Initialize()
        {
            if (isInitialized) return;

            SetupInputActions();
            RegisterEvents();
            EnableInput();

            isInitialized = true;
            Debug.Log("InputManager initialized");
        }

        private void SetupInputActions()
        {
#if ENABLE_INPUT_SYSTEM
            // Movement input
            moveAction = new InputAction("Move");
            moveAction.AddCompositeBinding("2DVector")
                .With("Up", "<Keyboard>/w")
                .With("Down", "<Keyboard>/s")
                .With("Left", "<Keyboard>/a")
                .With("Right", "<Keyboard>/d")
                .With("Up", "<Keyboard>/upArrow")
                .With("Down", "<Keyboard>/downArrow")
                .With("Left", "<Keyboard>/leftArrow")
                .With("Right", "<Keyboard>/rightArrow");
            moveAction.performed += ctx => HandleMovement(ctx.ReadValue<Vector2>());
            moveAction.canceled += ctx => HandleMovement(Vector2.zero);

            // Any key input
            anyKeyAction = new InputAction("AnyKey", InputActionType.Button);
            anyKeyAction.AddBinding("<Keyboard>/anyKey");
            anyKeyAction.AddBinding("<Mouse>/leftButton");
            anyKeyAction.performed += ctx => HandleAnyKeyPress();

            // Mouse input
            mousePositionAction = new InputAction("MousePosition", InputActionType.Value, "<Mouse>/position");
            mouseButtonAction = new InputAction("MouseButton", InputActionType.Button, "<Mouse>/leftButton");

            mouseButtonAction.started += _ => { isMousePressed = true; previousMousePosition = mousePositionAction.ReadValue<Vector2>(); };
            mouseButtonAction.canceled += _ => isMousePressed = false;

            // Touch input
            touchPositionAction = new InputAction("TouchPosition");
            touchPositionAction.AddBinding("<Touchscreen>/position");

            touchPressAction = new InputAction("TouchPress");
            touchPressAction.AddBinding("<Touchscreen>/primaryTouch/press");
            touchPressAction.performed += ctx => HandleTouchPress(ctx.ReadValue<float>());

            // Add this new action for profile navigation
            profileNavigationAction = new InputAction("ProfileNavigation");
            profileNavigationAction.AddCompositeBinding("1DAxis")
                .With("Positive", "<Keyboard>/downArrow")
                .With("Negative", "<Keyboard>/upArrow");
            profileNavigationAction.performed += ctx => HandleProfileNavigation(ctx.ReadValue<float>());
#endif
        }
        private void HandleProfileNavigation(float direction)
        {
            if (!isInputEnabled) return;

            if (currentGameState == GameState.ProfileSelection)
            {
                GameEvents.OnProfileNavigationInput.Invoke(direction);
            }
        }
        protected override void OnManagerEnabled()
        {
#if ENABLE_INPUT_SYSTEM
            moveAction?.Enable();
            anyKeyAction?.Enable();
            touchPositionAction?.Enable();
            touchPressAction?.Enable();
            mousePositionAction?.Enable();
            mouseButtonAction?.Enable();
            profileNavigationAction?.Enable();
#endif
        }

        protected override void OnManagerDisabled()
        {
#if ENABLE_INPUT_SYSTEM
            moveAction?.Disable();
            anyKeyAction?.Disable();
            touchPositionAction?.Disable();
            touchPressAction?.Disable();
            mousePositionAction?.Disable();
            mouseButtonAction?.Disable();
            profileNavigationAction?.Enable();
#endif
        }

        private void HandleMovement(Vector2 movement)
        {
            if (!isInputEnabled || currentGameState != GameState.Playing) return;

            float horizontalInput = movement.x * keyboardSensitivity;
            if (Mathf.Abs(horizontalInput) > mouseDeadZone)
            {
                GameEvents.OnHorizontalInput.Invoke(horizontalInput);
            }
        }

        private void HandleAnyKeyPress()
        {
            if (!isInputEnabled) return;

            switch (currentGameState)
            {
                case GameState.MainMenu:
                    GameEvents.OnMainMenuInput.Invoke();
                    break;
            }
        }

#if ENABLE_INPUT_SYSTEM
        private void HandleTouchPress(float pressed)
        {
            if (!isInputEnabled) return;

            if (pressed > 0)
            {
                previousTouchPosition = touchPositionAction.ReadValue<Vector2>();
            }
            else if (currentGameState == GameState.MainMenu)
            {
                GameEvents.OnMainMenuInput.Invoke();
            }
        }

        private void HandleMouseInput()
        {
            if (!isMousePressed || !isInputEnabled) return;

            Vector2 currentMousePosition = mousePositionAction.ReadValue<Vector2>();
            Vector2 mouseDelta = currentMousePosition - previousMousePosition;
            float normalizedDelta = mouseDelta.x / Screen.width * mouseSensitivity;

            if (Mathf.Abs(normalizedDelta) > mouseDeadZone && currentGameState == GameState.Playing)
            {
                GameEvents.OnHorizontalInput.Invoke(normalizedDelta);
            }

            previousMousePosition = currentMousePosition;
        }

        private void Update()
        {
            if (!isInputEnabled) return;

            // Handle mouse movement
            HandleMouseInput();

            // Handle touch movement
            if (Touchscreen.current != null && Touchscreen.current.primaryTouch.press.isPressed)
            {
                Vector2 currentPosition = touchPositionAction.ReadValue<Vector2>();
                Vector2 delta = currentPosition - previousTouchPosition;
                float normalizedDelta = delta.x / Screen.width * touchSensitivity;

                if (Mathf.Abs(normalizedDelta) > touchDeadZone && currentGameState == GameState.Playing)
                {
                    GameEvents.OnHorizontalInput.Invoke(normalizedDelta);
                }

                previousTouchPosition = currentPosition;
            }

            // Check for pause input
            if (Keyboard.current != null && Keyboard.current.escapeKey.wasPressedThisFrame)
            {
                switch (currentGameState)
                {
                    case GameState.Playing:
                        GameEvents.OnPauseRequested.Invoke();
                        break;
                    case GameState.Paused:
                        GameEvents.OnResumeRequested.Invoke();
                        break;
                }
            }
        }
#endif

        private void RegisterEvents()
        {
            GameEvents.OnGameStateChanged.AddListener(HandleGameStateChanged);
            GameEvents.OnGamePaused.AddListener(DisableInput);
            GameEvents.OnGameResumed.AddListener(EnableInput);
        }

        private void HandleGameStateChanged(GameState newState)
        {
            currentGameState = newState;
            Debug.Log($"Input Manager state changed to: {newState}");
        }

        public void EnableInput()
        {
            isInputEnabled = true;
#if ENABLE_INPUT_SYSTEM
            moveAction?.Enable();
            anyKeyAction?.Enable();
            touchPositionAction?.Enable();
            touchPressAction?.Enable();
            mousePositionAction?.Enable();
            mouseButtonAction?.Enable();
#endif
        }

        public void DisableInput()
        {
            isInputEnabled = false;
#if ENABLE_INPUT_SYSTEM
            moveAction?.Disable();
            anyKeyAction?.Disable();
            touchPositionAction?.Disable();
            touchPressAction?.Disable();
            mousePositionAction?.Disable();
            mouseButtonAction?.Disable();
#endif
        }

        protected override void OnManagerDestroyed()
        {
            // Clean up events
            GameEvents.OnGameStateChanged.RemoveListener(HandleGameStateChanged);
            GameEvents.OnGamePaused.RemoveListener(DisableInput);
            GameEvents.OnGameResumed.RemoveListener(EnableInput);

            // Clean up input actions
#if ENABLE_INPUT_SYSTEM
            moveAction?.Dispose();
            anyKeyAction?.Dispose();
            touchPositionAction?.Dispose();
            touchPressAction?.Dispose();
            mousePositionAction?.Dispose();
            mouseButtonAction?.Dispose();
            profileNavigationAction?.Dispose();
#endif
        }
    }
}

// --- END FILE ---

// File: Core/Pool/PoolManager.cs
// Size: 315 characters
// ---
using CyberPickle.Core.Management;
using CyberPickle.Core.Interfaces;

namespace CyberPickle.Core.Pool
{
    public class PoolManager : Manager<PoolManager>, IInitializable
    {
        public void Initialize()
        {
            UnityEngine.Debug.Log("PoolManager initialized");
        }
    }
}

// --- END FILE ---

// File: Core/SaveSystem/SaveManager.cs
// Size: 321 characters
// ---
using CyberPickle.Core.Management;
using CyberPickle.Core.Interfaces;

namespace CyberPickle.Core.SaveSystem
{
    public class SaveManager : Manager<SaveManager>, IInitializable
    {
        public void Initialize()
        {
            UnityEngine.Debug.Log("SaveManager initialized");
        }
    }
}

// --- END FILE ---

// File: Core/Transitions/TransitionManager.cs
// Size: 6850 characters
// ---
using UnityEngine;
using System.Collections;
using CyberPickle.Core.Management;
using CyberPickle.Core.Events;
using CyberPickle.Core.States;

namespace CyberPickle.Core.Transitions
{
    public class TransitionManager : Manager<TransitionManager>
    {
        [Header("Scene References")]
        [SerializeField] private GameObject menuArea;
        [SerializeField] private GameObject characterSelectArea;
        [SerializeField] private Light bonfireLight;
        [SerializeField] private float maxBonfireIntensity = 2f;

        [Header("Transition Settings")]
        [SerializeField] private float transitionDuration = 1f;
        [SerializeField] private AnimationCurve transitionCurve = AnimationCurve.EaseInOut(0, 0, 1, 1);

        private Coroutine currentTransition;
        private GameState currentState;

        protected override void OnManagerAwake()
        {
            base.OnManagerAwake();
            ValidateReferences();
            InitializeScene();
        }

        private void ValidateReferences()
        {
            if (characterSelectArea == null)
                Debug.LogError("[TransitionManager] Character select area is missing!");

            if (bonfireLight == null)
                Debug.LogError("[TransitionManager] Bonfire light is missing!");
        }

        private void InitializeScene()
        {
            Debug.Log("[TransitionManager] Initializing scene");

            if (characterSelectArea != null)
            {
                characterSelectArea.SetActive(false);
                Debug.Log("[TransitionManager] Character select area hidden");
            }

            if (bonfireLight != null)
            {
                bonfireLight.intensity = 0f;
                Debug.Log("[TransitionManager] Bonfire light initialized");
            }
        }

        protected override void OnManagerEnabled()
        {
            base.OnManagerEnabled();
            SubscribeToEvents();
        }

        protected override void OnManagerDisabled()
        {
            base.OnManagerDisabled();
            UnsubscribeFromEvents();
            StopAllCoroutines();
        }

        private void SubscribeToEvents()
        {
            GameEvents.OnGameStateChanged.AddListener(HandleGameStateChanged);
            GameEvents.OnCameraTransitionComplete.AddListener(HandleCameraTransitionComplete);
        }

        private void UnsubscribeFromEvents()
        {
            GameEvents.OnGameStateChanged.RemoveListener(HandleGameStateChanged);
            GameEvents.OnCameraTransitionComplete.RemoveListener(HandleCameraTransitionComplete);
        }

        private void HandleGameStateChanged(GameState newState)
        {
            currentState = newState;

            switch (newState)
            {
                case GameState.CharacterSelect:
                    StartCharacterSelectTransition();
                    break;
                case GameState.MainMenu:
                    StartMainMenuTransition();
                    break;
            }
        }

        private void HandleCameraTransitionComplete()
        {
            Debug.Log("[TransitionManager] Camera transition complete");

            // Additional effects or state changes after camera movement based on current state
            switch (currentState)
            {
                case GameState.CharacterSelect:
                    // Maybe trigger some additional VFX or lighting changes
                    if (bonfireLight != null)
                    {
                        StartCoroutine(AnimateBonfireLight(maxBonfireIntensity, 0.5f));
                    }
                    break;

                case GameState.MainMenu:
                    // Return to default state or trigger menu-specific effects
                    if (bonfireLight != null)
                    {
                        StartCoroutine(AnimateBonfireLight(0f, 0.5f));
                    }
                    break;
            }
        }

        private void StartCharacterSelectTransition()
        {
            Debug.Log("[TransitionManager] Starting character select transition");

            if (currentTransition != null)
                StopCoroutine(currentTransition);

            currentTransition = StartCoroutine(CharacterSelectTransitionRoutine());
        }

        private void StartMainMenuTransition()
        {
            Debug.Log("[TransitionManager] Starting main menu transition");

            if (currentTransition != null)
                StopCoroutine(currentTransition);

            currentTransition = StartCoroutine(MainMenuTransitionRoutine());
        }

        private IEnumerator CharacterSelectTransitionRoutine()
        {
            if (characterSelectArea != null)
            {
                characterSelectArea.SetActive(true);
                Debug.Log("[TransitionManager] Character select area activated");
            }

            // Fade in the bonfire light
            if (bonfireLight != null)
            {
                yield return StartCoroutine(AnimateBonfireLight(maxBonfireIntensity, transitionDuration));
            }

            GameEvents.OnCameraTransitionComplete.Invoke();
        }

        private IEnumerator MainMenuTransitionRoutine()
        {
            if (menuArea != null)
                menuArea.SetActive(true);

            // Fade out bonfire light
            if (bonfireLight != null)
            {
                yield return StartCoroutine(AnimateBonfireLight(0f, transitionDuration));
            }

            if (characterSelectArea != null)
                characterSelectArea.SetActive(false);

            Debug.Log("[TransitionManager] Main menu transition complete");
        }

        private IEnumerator AnimateBonfireLight(float targetIntensity, float duration)
        {
            if (bonfireLight == null) yield break;

            float startIntensity = bonfireLight.intensity;
            float elapsedTime = 0f;

            while (elapsedTime < duration)
            {
                elapsedTime += Time.deltaTime;
                float normalizedTime = elapsedTime / duration;
                float curveValue = transitionCurve.Evaluate(normalizedTime);

                bonfireLight.intensity = Mathf.Lerp(startIntensity, targetIntensity, curveValue);
                yield return null;
            }

            bonfireLight.intensity = targetIntensity;
        }


        protected override void OnManagerDestroyed()
        {
            base.OnManagerDestroyed();
            UnsubscribeFromEvents();
            StopAllCoroutines();
        }
    }
}
// --- END FILE ---

// File: Core/VFX/SmokeVFXController.cs
// Size: 3081 characters
// ---
using UnityEngine;
using UnityEngine.VFX;

namespace CyberPickle.Core.VFX
{
    [RequireComponent(typeof(VisualEffect))]
    public class SmokeVFXController : MonoBehaviour
    {
        private VisualEffect vfx;

        // These names must match exactly with the parameters in your Visual Effect Graph
        private const string SPAWN_RATE_PARAM = "SpawnRate";
        private const string SMOKE_DENSITY_PARAM = "SmokeDensity";
        private const string SMOKE_SIZE_PARAM = "SmokeSize";

        [Header("Debug")]
        [SerializeField] private bool showDebugLog = true;

        private void Awake()
        {
            vfx = GetComponent<VisualEffect>();
            ValidateParameters();
        }

        private void ValidateParameters()
        {
            if (vfx == null)
            {
                Debug.LogError("[SmokeVFXController] No VisualEffect component found!");
                return;
            }

            // Check if parameters exist
            bool hasSpawnRate = HasParameter(SPAWN_RATE_PARAM);
            bool hasSmokeDensity = HasParameter(SMOKE_DENSITY_PARAM);
            bool hasSmokeSize = HasParameter(SMOKE_SIZE_PARAM);

            if (showDebugLog)
            {
                Debug.Log($"[SmokeVFXController] Parameter check:\n" +
                    $"SpawnRate: {(hasSpawnRate ? "Found" : "Missing")}\n" +
                    $"SmokeDensity: {(hasSmokeDensity ? "Found" : "Missing")}\n" +
                    $"SmokeSize: {(hasSmokeSize ? "Found" : "Missing")}");
            }

            // Log warning for any missing parameters
            if (!hasSpawnRate) Debug.LogWarning($"[SmokeVFXController] Missing parameter: {SPAWN_RATE_PARAM}");
            if (!hasSmokeDensity) Debug.LogWarning($"[SmokeVFXController] Missing parameter: {SMOKE_DENSITY_PARAM}");
            if (!hasSmokeSize) Debug.LogWarning($"[SmokeVFXController] Missing parameter: {SMOKE_SIZE_PARAM}");
        }

        private bool HasParameter(string name)
        {
            return vfx.HasFloat(name);
        }

        public void SetSmokeDensity(float density)
        {
            if (vfx != null && HasParameter(SMOKE_DENSITY_PARAM))
            {
                vfx.SetFloat(SMOKE_DENSITY_PARAM, density);
                if (showDebugLog) Debug.Log($"[SmokeVFXController] Set SmokeDensity to {density}");
            }
        }

        public void SetSpawnRate(float rate)
        {
            if (vfx != null && HasParameter(SPAWN_RATE_PARAM))
            {
                vfx.SetFloat(SPAWN_RATE_PARAM, rate);
                if (showDebugLog) Debug.Log($"[SmokeVFXController] Set SpawnRate to {rate}");
            }
        }

        public void SetSmokeSize(float size)
        {
            if (vfx != null && HasParameter(SMOKE_SIZE_PARAM))
            {
                vfx.SetFloat(SMOKE_SIZE_PARAM, size);
                if (showDebugLog) Debug.Log($"[SmokeVFXController] Set SmokeSize to {size}");
            }
        }
    }
}

// --- END FILE ---

// File: UI/Effects/GlitchTextEffect.cs
// Size: 7856 characters
// ---
using UnityEngine;
using TMPro;
using System.Collections;
using CyberPickle.UI.Effects.Config;

namespace CyberPickle.UI.Effects
{
    [RequireComponent(typeof(TextMeshProUGUI))]
    public class GlitchTextEffect : MonoBehaviour
    {
        [SerializeField] private GlitchTextConfig config;

        private TextMeshProUGUI textMesh;
        private Material glitchMaterial;
        private string originalText;

        void Start()
        {
            if (config == null)
            {
                Debug.LogError("GlitchTextConfig not assigned to GlitchTextEffect on " + gameObject.name);
                return;
            }

            textMesh = GetComponent<TextMeshProUGUI>();
            glitchMaterial = textMesh.fontMaterial;
            originalText = textMesh.text;

            if (glitchMaterial.shader.name != "TextMeshPro/Distance Field Glitch")
            {
                Debug.LogWarning("Please assign the 'TextMeshPro/Distance Field Glitch with Scanlines and Chromatic Aberration' shader to the font material.");
            }

            UpdateShaderProperties();
            StartCoroutine(FadeInRoutine());
            StartCoroutine(GlitchTextRoutine());
            StartCoroutine(RandomCharRoutine());
            StartCoroutine(PulseRoutine());
            StartCoroutine(DynamicGlitchIntensityRoutine());
            StartCoroutine(CharacterColorGlitchRoutine());
        }

        void OnValidate()
        {
            if (glitchMaterial == null)
            {
                textMesh = GetComponent<TextMeshProUGUI>();
                if (textMesh != null)
                {
                    glitchMaterial = textMesh.fontMaterial;
                }
            }

            if (glitchMaterial != null && config != null)
            {
                UpdateShaderProperties();
            }
        }

        void UpdateShaderProperties()
        {
            glitchMaterial.SetFloat("_GlitchIntensity", config.glitchIntensity);
            glitchMaterial.SetFloat("_GlitchAmplitude", config.glitchAmplitude);
            glitchMaterial.SetFloat("_GlitchSpeed", config.glitchSpeed);
            glitchMaterial.SetFloat("_ScanlineIntensity", config.scanlineIntensity);
            glitchMaterial.SetFloat("_ScanlineSpeed", config.scanlineSpeed);
            glitchMaterial.SetFloat("_ScanlineFrequency", config.scanlineFrequency);
            glitchMaterial.SetFloat("_ChromAberration", config.chromAberration);
        }

        IEnumerator FadeInRoutine()
        {
            float elapsedTime = 0f;
            Color color = textMesh.color;
            color.a = 0f;
            textMesh.color = color;

            while (elapsedTime < config.fadeDuration)
            {
                elapsedTime += Time.deltaTime;
                color.a = Mathf.Clamp01(elapsedTime / config.fadeDuration);
                textMesh.color = color;
                yield return null;
            }

            color.a = 1f;
            textMesh.color = color;
        }

        IEnumerator GlitchTextRoutine()
        {
            while (true)
            {
                yield return new WaitForSeconds(config.glitchInterval);
                if (Random.value < config.glitchIntensity)
                {
                    UpdateShaderProperties();
                    yield return new WaitForSeconds(0.1f);
                    glitchMaterial.SetFloat("_RGBSplitAmount", 0f);
                    UpdateShaderProperties();
                }
            }
        }

        IEnumerator RandomCharRoutine()
        {
            while (true)
            {
                yield return new WaitForSeconds(Random.Range(config.randomCharIntervalMin, config.randomCharIntervalMax));
                if (Random.value < config.randomCharIntensity)
                {
                    int charIndex = Random.Range(0, originalText.Length);
                    char randomChar = (char)Random.Range(33, 126);
                    string glitchedText = originalText.Substring(0, charIndex) + randomChar + originalText.Substring(charIndex + 1);
                    textMesh.text = glitchedText;
                    yield return new WaitForSeconds(Random.Range(config.randomCharDisplayDurationMin, config.randomCharDisplayDurationMax));
                    textMesh.text = originalText;
                }
            }
        }

        IEnumerator PulseRoutine()
        {
            Vector3 originalScale = textMesh.transform.localScale;
            while (true)
            {
                float scale = Mathf.Lerp(1f, config.pulseScale, Mathf.PingPong(Time.time * config.pulseSpeed, 1));
                textMesh.transform.localScale = originalScale * scale;
                yield return null;
            }
        }

        IEnumerator DynamicGlitchIntensityRoutine()
        {
            while (true)
            {
                yield return new WaitForSeconds(Random.Range(0f, config.glitchIntensityInterval));
                config.glitchIntensity = Random.Range(config.glitchIntensityMin, config.glitchIntensityMax);
                UpdateShaderProperties();
                yield return new WaitForSeconds(config.glitchIntensityDuration);
                config.glitchIntensity = 0f;
                UpdateShaderProperties();
            }
        }

        IEnumerator CharacterColorGlitchRoutine()
        {
            while (true)
            {
                yield return new WaitForSeconds(Random.Range(5f, 15f));
                if (Random.value < config.colorGlitchIntensity)
                {
                    int charIndex = Random.Range(0, originalText.Length);
                    Color originalColor = textMesh.color;
                    Color glitchColor = Random.value > 0.5f ? new Color(0.0f, 1.0f, 1.0f) : new Color(1.0f, 0.0f, 1.0f);

                    TMP_TextInfo textInfo = textMesh.textInfo;
                    textMesh.ForceMeshUpdate();
                    var charInfo = textInfo.characterInfo[charIndex];
                    if (charInfo.isVisible)
                    {
                        int meshIndex = charInfo.materialReferenceIndex;
                        int vertexIndex = charInfo.vertexIndex;
                        Color32[] newVertexColors = textInfo.meshInfo[meshIndex].colors32;
                        newVertexColors[vertexIndex + 0] = glitchColor;
                        newVertexColors[vertexIndex + 1] = glitchColor;
                        newVertexColors[vertexIndex + 2] = glitchColor;
                        newVertexColors[vertexIndex + 3] = glitchColor;
                        textMesh.UpdateVertexData(TMP_VertexDataUpdateFlags.Colors32);
                    }
                    yield return new WaitForSeconds(config.colorGlitchDuration);

                    textMesh.ForceMeshUpdate();
                    var charInfoRestore = textInfo.characterInfo[charIndex];
                    if (charInfoRestore.isVisible)
                    {
                        int meshIndex = charInfoRestore.materialReferenceIndex;
                        int vertexIndex = charInfoRestore.vertexIndex;
                        Color32[] newVertexColors = textInfo.meshInfo[meshIndex].colors32;
                        newVertexColors[vertexIndex + 0] = originalColor;
                        newVertexColors[vertexIndex + 1] = originalColor;
                        newVertexColors[vertexIndex + 2] = originalColor;
                        newVertexColors[vertexIndex + 3] = originalColor;
                        textMesh.UpdateVertexData(TMP_VertexDataUpdateFlags.Colors32);
                    }
                }
            }
        }
    }
}

// --- END FILE ---

// File: Core/Base/Events/GameEvent.cs
// Size: 1118 characters
// ---
using System;
using System.Collections.Generic;

namespace CyberPickle.Core.Events
{
    public class GameEvent
    {
        private readonly List<Action> listeners = new List<Action>();

        public void AddListener(Action listener)
        {
            listeners.Add(listener);
        }

        public void RemoveListener(Action listener)
        {
            listeners.Remove(listener);
        }

        public void Invoke()
        {
            for (int i = listeners.Count - 1; i >= 0; i--)
                listeners[i]?.Invoke();
        }
    }

    public class GameEvent<T>
    {
        private readonly List<Action<T>> listeners = new List<Action<T>>();

        public void AddListener(Action<T> listener)
        {
            listeners.Add(listener);
        }

        public void RemoveListener(Action<T> listener)
        {
            listeners.Remove(listener);
        }

        public void Invoke(T value)
        {
            for (int i = listeners.Count - 1; i >= 0; i--)
                listeners[i]?.Invoke(value);
        }
    }
}

// --- END FILE ---

// File: Core/Base/Interfaces/ICleanable.cs
// Size: 117 characters
// ---
namespace CyberPickle.Core.Interfaces
{
    public interface ICleanable
    {
        void Cleanup();
    }
}

// --- END FILE ---

// File: Core/Base/Interfaces/IInitializable.cs
// Size: 122 characters
// ---
namespace CyberPickle.Core.Interfaces
{
    public interface IInitializable
    {
        void Initialize();
    }
}
// --- END FILE ---

// File: Core/Base/Manager/Manager.cs
// Size: 4527 characters
// ---
using UnityEngine;
using CyberPickle.Core.Interfaces;
using System.Threading;

namespace CyberPickle.Core.Management
{
    /// <summary>
    /// Base manager class implementing the singleton pattern for all game managers
    /// </summary>
    public abstract class Manager<T> : MonoBehaviour where T : Manager<T>
    {
        private static T instance;
        private static readonly object lockObject = new object();
        private static bool isQuitting = false;
        protected CancellationTokenSource cancellationTokenSource;

        public static T Instance
        {
            get
            {
                if (instance == null)
                {
                    // Check if we're quitting or in play mode
                    if (!Application.isPlaying)
                    {
                        Debug.LogWarning($"[{typeof(T).Name}] Instance will not be created because the application is not in play mode.");
                        return null;
                    }

                    lock (lockObject)
                    {
                        if (instance == null)
                        {
                            instance = FindObjectOfType<T>();
                            if (instance == null)
                            {
                                GameObject go = new GameObject($"[{typeof(T).Name}]");
                                instance = go.AddComponent<T>();
                                DontDestroyOnLoad(go);
                            }
                        }
                    }
                }
                return instance;
            }
        }

        protected virtual void Awake()
        {
            if (instance == null)
            {
                instance = (T)this;
                DontDestroyOnLoad(gameObject);
                cancellationTokenSource = new CancellationTokenSource();
                OnManagerAwake();
            }
            else if (instance != this)
            {
                Debug.LogWarning($"[{typeof(T).Name}] Instance already exists, destroying duplicate!");
                Destroy(gameObject);
            }
        }

        protected virtual void OnManagerAwake()
        {
            // If this manager is initializable, initialize it automatically
            if (this is IInitializable initializable)
            {
                Debug.Log($"<color=yellow>[{typeof(T).Name}] Auto-initializing...</color>");
                initializable.Initialize();
            }
        }

        protected virtual void OnEnable()
        {
            if (cancellationTokenSource == null || cancellationTokenSource.IsCancellationRequested)
            {
                cancellationTokenSource = new CancellationTokenSource();
            }
            OnManagerEnabled();
        }

        protected virtual void OnDisable()
        {
            OnManagerDisabled();
        }

        protected virtual void OnDestroy()
        {
            if (instance == this)
            {
                OnManagerDestroyed();
                instance = null;

                // Cancel any pending async operations
                if (cancellationTokenSource != null)
                {
                    cancellationTokenSource.Cancel();
                    cancellationTokenSource.Dispose();
                    cancellationTokenSource = null;
                }
            }
        }

        protected virtual void OnApplicationQuit()
        {
            isQuitting = true;

            // Cancel any pending async operations
            if (cancellationTokenSource != null && !cancellationTokenSource.IsCancellationRequested)
            {
                cancellationTokenSource.Cancel();
            }

            OnManagerApplicationQuit();
        }

        // Virtual methods for derived classes to override
        protected virtual void OnManagerEnabled() { }
        protected virtual void OnManagerDisabled() { }
        protected virtual void OnManagerDestroyed() { }
        protected virtual void OnManagerApplicationQuit() { }

        // Helper method to check if this is the active instance
        protected bool IsActiveInstance => instance == this;

        // Helper method to check if the application is quitting
        protected bool IsQuitting => Application.isPlaying && !Application.isEditor && (Time.frameCount == 0 || !enabled);
    }
}
// --- END FILE ---

// File: Core/Boot/Config/BootConfig.cs
// Size: 647 characters
// ---
using UnityEngine;

namespace CyberPickle.Core.Config
{
    [CreateAssetMenu(fileName = "BootConfig", menuName = "CyberPickle/Config/Boot")]
    public class BootConfig : ScriptableObject
    {
        [Header("Scene Settings")]
        public string mainMenuSceneName = "MainMenu";

        [Header("Timing Settings")]
        public float fadeInDuration = 1.5f;
        public float displayDuration = 2.0f;
        public float fadeOutDuration = 1.5f;
        public float minimumLoadingTime = 3.0f;

        [Header("Loading Settings")]
        public bool waitForInput = true;
        public string[] loadingTips;
    }
}

// --- END FILE ---

// File: Core/Boot/UI/BootUIController.cs
// Size: 1867 characters
// ---
using UnityEngine;
using UnityEngine.UI;
using TMPro;

namespace CyberPickle.Core.Boot.UI
{
    public class BootUIController : MonoBehaviour
    {
        [Header("UI References")]
        [SerializeField] private CanvasGroup logoCanvasGroup;
        [SerializeField] private TextMeshProUGUI companyNameText;
        [SerializeField] private Slider loadingBarSlider;
        [SerializeField] private TextMeshProUGUI loadingText;

        private void Awake()
        {
            ValidateReferences();
        }

        private void ValidateReferences()
        {
            if (logoCanvasGroup == null)
                Debug.LogError("[BootUIController] Logo CanvasGroup is not assigned!");
            if (companyNameText == null)
                Debug.LogError("[BootUIController] Company Name Text is not assigned!");
            if (loadingBarSlider == null)
                Debug.LogError("[BootUIController] Loading Bar Slider is not assigned!");
            if (loadingText == null)
                Debug.LogError("[BootUIController] Loading Text is not assigned!");
        }

        public void UpdateProgress(float progress)
        {
            if (loadingBarSlider != null)
            {
                loadingBarSlider.value = progress;
            }
        }

        public void UpdateLoadingText(string text)
        {
            if (loadingText != null)
            {
                loadingText.text = text;
                Debug.Log($"[BootUIController] Loading text updated: {text}");
            }
        }

        public void SetLogoAlpha(float alpha)
        {
            if (logoCanvasGroup != null)
            {
                logoCanvasGroup.alpha = alpha;
                Debug.Log($"[BootUIController] Logo alpha updated: {alpha:F2}");
            }
        }
    }
}
// --- END FILE ---

// File: Core/GameManager/Config/GameConfig.cs
// Size: 947 characters
// ---
using UnityEngine;

namespace CyberPickle.Core.Config
{
    [CreateAssetMenu(fileName = "GameConfig", menuName = "CyberPickle/Config/Game")]
    public class GameConfig : ScriptableObject
    {
        [Header("Scene Names")]
        public string mainMenuSceneName = "MainMenu";
        public string characterSelectSceneName = "CharacterSelect";
        public string equipmentSelectSceneName = "EquipmentSelect";
        public string levelSelectSceneName = "LevelSelect";
        public string gameSceneName = "Game";
        public string postGameSceneName = "PostGame";

        [Header("Game Settings")]
        public float gameStartDelay = 3f;
        public float gameOverDelay = 2f;
        public bool enableTutorial = true;

        [Header("Debug Settings")]
        public bool enableDebugMode = false;
        public bool skipBootSequence = false;
        public bool unlockAllCharacters = false;
    }
}

// --- END FILE ---

// File: Core/GameManager/Events/EventManager.cs
// Size: 1443 characters
// ---
using CyberPickle.Core.Management;
using CyberPickle.Core.Interfaces;

namespace CyberPickle.Core.Events
{
    public class EventManager : Manager<EventManager>, IInitializable
    {
        private bool isInitialized;

        public void Initialize()
        {
            if (isInitialized) return;

            // Initialize any event-related systems
            RegisterGlobalEventListeners();

            isInitialized = true;
        }

        private void RegisterGlobalEventListeners()
        {
            // Register for analytics
            GameEvents.OnLevelCompleted.AddListener((levelId) =>
                TrackLevelCompletion(levelId));

            GameEvents.OnAchievementUnlocked.AddListener((achievementId) =>
                TrackAchievement(achievementId));

            // Add more global event listeners as needed
        }

        private void TrackLevelCompletion(string levelId)
        {
            // Will be implemented when Analytics system is ready
            UnityEngine.Debug.Log($"Level completed: {levelId}");
        }

        private void TrackAchievement(string achievementId)
        {
            // Will be implemented when Achievement system is ready
            UnityEngine.Debug.Log($"Achievement unlocked: {achievementId}");
        }

        protected override void OnManagerAwake()
        {
            Initialize();
        }
    }
}

// --- END FILE ---

// File: Core/GameManager/Events/GameEvents.cs
// Size: 5470 characters
// ---
using CyberPickle.Core.GameFlow.States.ProfileCard;
using CyberPickle.Core.Services.Authentication.Data;
using CyberPickle.Core.States;
using System.Collections.Generic;

namespace CyberPickle.Core.Events
{
    public static class GameEvents
    {
        // Game State Events
        public static readonly GameEvent OnGameInitialized = new GameEvent();
        public static readonly GameEvent OnGameStarted = new GameEvent();
        public static readonly GameEvent OnGamePaused = new GameEvent();
        public static readonly GameEvent OnGameResumed = new GameEvent();
        public static readonly GameEvent OnGameOver = new GameEvent();

        // Player Events
        public static readonly GameEvent<int> OnExperienceGained = new GameEvent<int>();
        public static readonly GameEvent<int> OnLevelUp = new GameEvent<int>();
        public static readonly GameEvent<float> OnHealthChanged = new GameEvent<float>();
        public static readonly GameEvent OnPlayerDied = new GameEvent();

        // Progress Events
        public static readonly GameEvent<string> OnAchievementUnlocked = new GameEvent<string>();
        public static readonly GameEvent<string> OnLevelCompleted = new GameEvent<string>();
        public static readonly GameEvent<string> OnCharacterUnlocked = new GameEvent<string>();

        // Economy Events
        public static readonly GameEvent<int> OnCurrencyChanged = new GameEvent<int>();
        public static readonly GameEvent<string> OnItemPurchased = new GameEvent<string>();
        public static readonly GameEvent<string> OnItemEquipped = new GameEvent<string>();

        
        // Input related events
        public static readonly GameEvent OnMainMenuInput = new GameEvent();
        public static readonly GameEvent<float> OnHorizontalInput = new GameEvent<float>();
        public static readonly GameEvent OnPauseRequested = new GameEvent();
        public static readonly GameEvent OnResumeRequested = new GameEvent();
        public static readonly GameEvent<GameState> OnGameStateChanged = new GameEvent<GameState>();
        public static GameEvent<float> OnProfileNavigationInput = new GameEvent<float>();

        // Authentication events
        public static readonly GameEvent OnAuthenticationRequested = new GameEvent();
        public static readonly GameEvent OnProfileLoadRequested = new GameEvent();

        // Profile-related events
        public static readonly GameEvent<List<ProfileData>> OnProfilesLoaded = new GameEvent<List<ProfileData>>();
        public static readonly GameEvent OnProfilesCleared = new GameEvent();
        public static readonly GameEvent<string> OnProfileSelected = new GameEvent<string>();
        public static readonly GameEvent<string> OnProfileCreated = new GameEvent<string>();
        public static readonly GameEvent<string> OnProfileDeleted = new GameEvent<string>();
        public static readonly GameEvent<string> OnProfileRestored = new GameEvent<string>();

        // UI Animation Events
        public static readonly GameEvent OnUIAnimationStarted = new GameEvent();
        public static readonly GameEvent OnUIAnimationCompleted = new GameEvent();
        public static readonly GameEvent OnProfileUIReady = new GameEvent();

        // Profile Card UI Events
        public static readonly GameEvent<ProfileCardState> OnProfileCardStateChanged = new GameEvent<ProfileCardState>();
        public static readonly GameEvent OnProfileCardClicked = new GameEvent();
        public static readonly GameEvent OnProfileCardTransitionComplete = new GameEvent();
        public static readonly GameEvent<bool> OnProfileCardInteractionEnabled = new GameEvent<bool>();

        //Camera Events
        public static readonly GameEvent OnCameraTransitionComplete = new GameEvent();

        // Character Selection Events
        public static readonly GameEvent<string> OnCharacterHoverEnter = new GameEvent<string>();
        public static readonly GameEvent<string> OnCharacterHoverExit = new GameEvent<string>();
        public static readonly GameEvent<string> OnCharacterSelected = new GameEvent<string>();
        public static readonly GameEvent<string> OnCharacterDetailsRequested = new GameEvent<string>();
        public static readonly GameEvent<string> OnCharacterConfirmationRequested = new GameEvent<string>();
        public static readonly GameEvent OnCharacterConfirmed = new GameEvent();
        public static readonly GameEvent OnCharacterSelectionCancelled = new GameEvent();

        /// <summary>
        /// Event raised when the mouse pointer enters a character in the selection screen
        /// </summary>
        /// <param name="characterId">ID of the character being hovered</param>

        /// <summary>
        /// Event raised when the mouse pointer exits a character in the selection screen
        /// </summary>
        /// <param name="characterId">ID of the character no longer being hovered</param>

        /// <summary>
        /// Event raised when a character is selected via left-click
        /// </summary>
        /// <param name="characterId">ID of the selected character</param>

        /// <summary>
        /// Event raised when character details are requested via right-click
        /// </summary>
        /// <param name="characterId">ID of the character whose details are requested</param>

    }
}

// --- END FILE ---

// File: Core/GameManager/States/GameState.cs
// Size: 307 characters
// ---
namespace CyberPickle.Core.States
{
    public enum GameState
    {
        None,
        Loading,
        ProfileSelection,
        MainMenu,
        CharacterSelect,
        EquipmentSelect,
        LevelSelect,
        Playing,
        Paused,
        PostGame,
        GameOver
    }
}

// --- END FILE ---

// File: Core/Services/Authentication/AuthenticationManager.cs
// Size: 9074 characters
// ---
// File: Assets/Code/Core/Services/Authentication/AuthenticationManager.cs
//
// Purpose: Manages authentication state in the game.
// Provides centralized control over user authentication.
//
// Dependencies:
// - Unity.Services.Authentication for base authentication
// - CyberPickle.Core.Events for game-wide event system
// - CyberPickle.Core.Management for base manager pattern
//
// Created: 2024-01-13
// Updated: 2024-01-14

using UnityEngine;
using System;
using System.Threading.Tasks;
using Unity.Services.Core;
using Unity.Services.Authentication;
using CyberPickle.Core.Management;
using CyberPickle.Core.Events;
using CyberPickle.Core.Interfaces;

namespace CyberPickle.Core.Services.Authentication
{
    public class AuthenticationManager : Manager<AuthenticationManager>, IInitializable
    {
        private AuthenticationState currentState = AuthenticationState.NotInitialized;
        private AuthenticationEvents authEvents;
        private bool isInitialized;

        public AuthenticationState CurrentState => currentState;
        public bool IsSignedIn => AuthenticationService.Instance.IsSignedIn;
        public string CurrentPlayerId => AuthenticationService.Instance.PlayerId;

        protected override void OnManagerAwake()
        {
            authEvents = new AuthenticationEvents();
        }

        public async void Initialize()
        {
            if (isInitialized) return;

            try
            {
                SetState(AuthenticationState.NotInitialized);

                // Initialize Unity Services
                await UnityServices.InitializeAsync();

                // Subscribe to Authentication events
                SubscribeToAuthEvents();

                // Check for cached session
                if (AuthenticationService.Instance.SessionTokenExists)
                {
                    authEvents.InvokeSessionTokenFound(AuthenticationService.Instance.PlayerId);
                }

                SetState(AuthenticationState.NotAuthenticated);
                isInitialized = true;

                Debug.Log("Authentication Manager initialized successfully");
            }
            catch (Exception e)
            {
                Debug.LogError($"Failed to initialize Authentication Manager: {e.Message}");
                SetState(AuthenticationState.AuthenticationFailed);
            }
        }

        private void SubscribeToAuthEvents()
        {
            AuthenticationService.Instance.SignedIn += OnSignedIn;
            AuthenticationService.Instance.SignedOut += OnSignedOut;
            AuthenticationService.Instance.Expired += OnSessionExpired;
        }

        private void UnsubscribeFromAuthEvents()
        {
            if (AuthenticationService.Instance != null)
            {
                AuthenticationService.Instance.SignedIn -= OnSignedIn;
                AuthenticationService.Instance.SignedOut -= OnSignedOut;
                AuthenticationService.Instance.Expired -= OnSessionExpired;
            }
        }

        #region Authentication Methods

        public async Task<bool> SignInAnonymouslyAsync()
        {
            if (currentState == AuthenticationState.AuthenticationInProgress)
            {
                Debug.LogWarning("Authentication already in progress");
                return false;
            }

            try
            {
                SetState(AuthenticationState.AuthenticationInProgress);

                await AuthenticationService.Instance.SignInAnonymouslyAsync();

                // Sign-in successful, events are handled in OnSignedIn

                return true;
            }
            catch (AuthenticationException e)
            {
                HandleAuthenticationError(e);
                return false;
            }
            catch (RequestFailedException e)
            {
                HandleRequestError(e);
                return false;
            }
        }

        public void SignOut()
        {
            try
            {
                AuthenticationService.Instance.SignOut();
                SetState(AuthenticationState.NotAuthenticated);
                authEvents.InvokeSignedOut();
            }
            catch (Exception e)
            {
                Debug.LogError($"Error during sign out: {e.Message}");
            }
        }

        #endregion

        #region Event Handlers

        private void OnSignedIn()
        {
            Debug.Log("[AuthManager] SignedIn event received");
            SetState(AuthenticationState.Authenticated);
            authEvents.InvokeAuthenticationCompleted(AuthenticationService.Instance.PlayerId);
            Debug.Log($"[AuthManager] Signed in successfully. Player ID: {AuthenticationService.Instance.PlayerId}");
        }

        private void OnSignedOut()
        {
            SetState(AuthenticationState.NotAuthenticated);
            authEvents.InvokeSignedOut();
            Debug.Log("Signed out successfully");
        }

        private void OnSessionExpired()
        {
            SetState(AuthenticationState.SessionExpired);
            authEvents.InvokeSessionExpired();
            Debug.Log("Session expired");
        }

        #endregion

        #region Error Handling

        private void HandleAuthenticationError(AuthenticationException e)
        {
            string errorMessage = $"Authentication error: {e.Message}";
            Debug.LogError(errorMessage);
            SetState(AuthenticationState.AuthenticationFailed);
            authEvents.InvokeAuthenticationFailed(errorMessage);
        }

        private void HandleRequestError(RequestFailedException e)
        {
            string errorMessage = $"Request failed: {e.Message} (Error Code: {e.ErrorCode})";
            Debug.LogError(errorMessage);
            SetState(AuthenticationState.AuthenticationFailed);
            authEvents.InvokeAuthenticationFailed(errorMessage);
        }

        #endregion

        private void SetState(AuthenticationState newState)
        {
            if (currentState != newState)
            {
                Debug.Log($"[AuthManager] State changing from {currentState} to {newState}");
                currentState = newState;
                authEvents.InvokeAuthenticationStateChanged(newState);
            }
        }

        #region Event Subscription Methods

        public void SubscribeToAuthenticationStateChanged(Action<AuthenticationState> callback)
            => authEvents.OnAuthenticationStateChanged += callback;

        public void UnsubscribeFromAuthenticationStateChanged(Action<AuthenticationState> callback)
            => authEvents.OnAuthenticationStateChanged -= callback;

        public void SubscribeToAuthenticationCompleted(Action<string> callback)
            => authEvents.OnAuthenticationCompleted += callback;

        public void UnsubscribeFromAuthenticationCompleted(Action<string> callback)
            => authEvents.OnAuthenticationCompleted -= callback;

        public void SubscribeToAuthenticationFailed(Action<string> callback)
            => authEvents.OnAuthenticationFailed += callback;

        public void UnsubscribeFromAuthenticationFailed(Action<string> callback)
            => authEvents.OnAuthenticationFailed -= callback;

        // Session event subscriptions
        public void SubscribeToSessionTokenFound(Action<string> callback)
            => authEvents.OnSessionTokenFound += callback;

        public void UnsubscribeFromSessionTokenFound(Action<string> callback)
            => authEvents.OnSessionTokenFound -= callback;

        public void SubscribeToSessionExpired(Action callback)
            => authEvents.OnSessionExpired += callback;

        public void UnsubscribeFromSessionExpired(Action callback)
            => authEvents.OnSessionExpired -= callback;

        public void SubscribeToSignedOut(Action callback)
            => authEvents.OnSignedOut += callback;

        public void UnsubscribeFromSignedOut(Action callback)
            => authEvents.OnSignedOut -= callback;

        #endregion

        protected override void OnManagerDestroyed()
        {
            if (!IsActiveInstance) return;

            try
            {
                // Ensure clean sign out if necessary
                if (AuthenticationService.Instance != null && AuthenticationService.Instance.IsSignedIn)
                {
                    AuthenticationService.Instance.SignOut();
                }

                // Unsubscribe from events
                UnsubscribeFromAuthEvents();

                Debug.Log("[AuthManager] Cleanup completed successfully");
            }
            catch (Exception ex)
            {
                Debug.LogError($"[AuthManager] Error during cleanup: {ex.Message}");
            }
        }

    }
}

// --- END FILE ---

// File: Core/Services/Authentication/ProfileManager.cs
// Size: 14376 characters
// ---
// File: Assets/Code/Core/Services/Authentication/ProfileManager.cs

using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using UnityEngine;
using System.Linq;
using CyberPickle.Core.Management;
using CyberPickle.Core.Interfaces;
using CyberPickle.Core.Services.Authentication.Data;
using System.Threading;

namespace CyberPickle.Core.Services.Authentication
{
    public class ProfileOperationResult
    {
        public bool Success { get; }
        public string Message { get; }
        public Exception Error { get; }

        private ProfileOperationResult(bool success, string message, Exception error = null)
        {
            Success = success;
            Message = message;
            Error = error;
        }

        public static ProfileOperationResult Succeeded(string message = null)
            => new ProfileOperationResult(true, message);

        public static ProfileOperationResult Failed(string message, Exception error = null)
            => new ProfileOperationResult(false, message, error);
    }

    public class ProfileManager : Manager<ProfileManager>, IInitializable
    {
        private ProfileContainer profileContainer;
        private ProfileManagementEvents profileEvents;
        private bool isInitialized;
        private bool isAutosaveEnabled = true;
        private readonly object saveLock = new object();

        public bool IsInitialized => isInitialized;
        public ProfileData ActiveProfile => profileContainer?.ActiveProfile;

        public void Initialize()
        {
            if (isInitialized) return;

            Debug.Log("[ProfileManager] Starting initialization");

            try
            {
                profileContainer = ProfileContainer.Load();
                Debug.Log($"[ProfileManager] Loaded profile container. Has profiles: {profileContainer?.Profiles?.Count > 0}");

                if (profileContainer == null)
                {
                    profileContainer = new ProfileContainer();
                    Debug.Log("[ProfileManager] Created new profile container");
                }

                profileEvents = new ProfileManagementEvents();
                isInitialized = true;
                Debug.Log("[ProfileManager] Initialization complete");
            }
            catch (Exception e)
            {
                Debug.LogError($"[ProfileManager] Failed to initialize: {e.Message}");
                throw;
            }
        }

        protected override void OnManagerAwake()
        {
            Debug.Log("[ProfileManager] OnManagerAwake called");
            Initialize();
        }

        private void ValidateState()
        {
            if (!isInitialized)
            {
                throw new InvalidOperationException("[ProfileManager] Manager not initialized");
            }

            if (profileContainer == null)
            {
                throw new InvalidOperationException("[ProfileManager] Profile container is null");
            }
        }

        public async Task<ProfileOperationResult> CreateProfileAsync(string profileId, string playerId, string displayName)
        {
            try
            {
                ValidateState();

                Debug.Log($"[ProfileManager] Creating profile: {displayName} (ID: {profileId})");
                var profile = new ProfileData(profileId, playerId, displayName);
                profileContainer.AddProfile(profile);
                profileContainer.SetActiveProfile(profileId);

                await SaveProfilesAsync();
                profileEvents.InvokeNewProfileCreated(profileId);

                return ProfileOperationResult.Succeeded($"Profile created successfully: {profileId}");
            }
            catch (Exception ex)
            {
                Debug.LogError($"[ProfileManager] Failed to create profile: {ex.Message}");
                return ProfileOperationResult.Failed("Failed to create profile", ex);
            }
        }

        public ProfileData GetProfile(string profileId)
        {
            try
            {
                ValidateState();
                return profileContainer.GetProfile(profileId);
            }
            catch (Exception ex)
            {
                Debug.LogError($"[ProfileManager] Failed to get profile {profileId}: {ex.Message}");
                return null;
            }
        }

        public async Task<ProfileOperationResult> AddProfileAsync(ProfileData profile)
        {
            try
            {
                ValidateState();

                Debug.Log($"[ProfileManager] Adding profile: {profile.DisplayName}");
                profileContainer.AddProfile(profile);
                await SaveProfilesAsync();
                profileEvents?.InvokeNewProfileCreated(profile.ProfileId);

                return ProfileOperationResult.Succeeded($"Profile added successfully: {profile.DisplayName}");
            }
            catch (Exception ex)
            {
                Debug.LogError($"[ProfileManager] Failed to add profile: {ex.Message}");
                return ProfileOperationResult.Failed("Failed to add profile", ex);
            }
        }

        public async Task<ProfileOperationResult> DeleteProfileAsync(string profileId)
        {
            try
            {
                ValidateState();

                Debug.Log($"[ProfileManager] Deleting profile: {profileId}");

                // Check if profile exists
                var profile = GetProfile(profileId);
                if (profile == null)
                {
                    return ProfileOperationResult.Failed($"Profile not found: {profileId}");
                }

                // If deleting active profile, handle special case
                if (ActiveProfile?.ProfileId == profileId)
                {
                    var nextProfile = profileContainer.Profiles
                        .FirstOrDefault(p => p.ProfileId != profileId);

                    if (nextProfile != null)
                    {
                        profileContainer.SetActiveProfile(nextProfile.ProfileId);
                    }
                }

                profileContainer.RemoveProfile(profileId);
                await SaveProfilesAsync();
                profileEvents?.InvokeProfileDeleted(profileId);

                return ProfileOperationResult.Succeeded($"Profile deleted successfully: {profileId}");
            }
            catch (Exception ex)
            {
                Debug.LogError($"[ProfileManager] Failed to delete profile: {ex.Message}");
                return ProfileOperationResult.Failed("Failed to delete profile", ex);
            }
        }

        public async Task<ProfileOperationResult> UpdateProfileAsync(ProfileData profile)
        {
            try
            {
                ValidateState();

                Debug.Log($"[ProfileManager] Updating profile: {profile.ProfileId}");
                profileContainer.UpdateProfile(profile);
                await SaveProfilesAsync();

                return ProfileOperationResult.Succeeded($"Profile updated successfully: {profile.ProfileId}");
            }
            catch (Exception ex)
            {
                Debug.LogError($"[ProfileManager] Failed to update profile: {ex.Message}");
                return ProfileOperationResult.Failed("Failed to update profile", ex);
            }
        }

        public async Task<ProfileOperationResult> SwitchActiveProfileAsync(string profileId)
        {
            try
            {
                ValidateState();

                var profile = GetProfile(profileId);
                if (profile == null)
                {
                    return ProfileOperationResult.Failed($"Profile not found: {profileId}");
                }

                profileContainer.SetActiveProfile(profileId);
                Debug.Log($"[ProfileManager] ActiveProfile set to {ActiveProfile?.ProfileId} at {Time.time}"); ;
                await SaveProfilesAsync();

                profileEvents.InvokeProfileSwitched(profileId);

                return ProfileOperationResult.Succeeded($"Profile switched successfully: {profileId}");
            }
            catch (Exception ex)
            {
                Debug.LogError($"[ProfileManager] Failed to switch profile: {ex.Message}");
                return ProfileOperationResult.Failed("Failed to switch profile", ex);
            }
        }

        public IReadOnlyList<ProfileData> GetAllProfiles()
        {
            try
            {
                ValidateState();
                return profileContainer.Profiles;
            }
            catch (Exception ex)
            {
                Debug.LogError($"[ProfileManager] Failed to get profiles: {ex.Message}");
                return new List<ProfileData>();
            }
        }

        public async Task<ProfileOperationResult> UpdateActiveProfileProgressAsync(float playTime, int score, float distance, int level)
        {
            try
            {
                ValidateState();

                if (ActiveProfile == null)
                {
                    return ProfileOperationResult.Failed("No active profile");
                }

                ActiveProfile.UpdateProgress(playTime, score, distance, level);
                profileContainer.UpdateProfile(ActiveProfile);
                await SaveProfilesAsync();

                return ProfileOperationResult.Succeeded("Profile progress updated successfully");
            }
            catch (Exception ex)
            {
                Debug.LogError($"[ProfileManager] Failed to update profile progress: {ex.Message}");
                return ProfileOperationResult.Failed("Failed to update profile progress", ex);
            }
        }

        private async Task SaveProfilesAsync()
        {
            if (!isAutosaveEnabled || profileContainer == null) return;

            try
            {
                var token = cancellationTokenSource?.Token ?? CancellationToken.None;
                if (token.IsCancellationRequested)
                {
                    Debug.Log("[ProfileManager] Save operation cancelled due to application quit");
                    return;
                }

                // Check IsQuitting on the main thread before starting the save operation
                bool isQuitting = IsQuitting;
                if (isQuitting)
                {
                    Debug.Log("[ProfileManager] Skipping save due to application quit");
                    return;
                }

                // Run the save operation on a background thread
                await Task.Run(() =>
                {
                    lock (saveLock)
                    {
                        profileContainer.SaveProfiles();
                    }
                }, token);

                Debug.Log("[ProfileManager] Profile save completed successfully");
            }
            catch (OperationCanceledException)
            {
                Debug.Log("[ProfileManager] Save operation was cancelled");
            }
            catch (Exception ex)
            {
                Debug.LogError($"[ProfileManager] Failed to save profiles: {ex.Message}");
            }
        }

        public async Task<ProfileOperationResult> ClearAllProfilesAsync()
        {
            try
            {
                ValidateState();

                profileContainer.ClearAll();
                await SaveProfilesAsync();

                return ProfileOperationResult.Succeeded("All profiles cleared successfully");
            }
            catch (Exception ex)
            {
                Debug.LogError($"[ProfileManager] Failed to clear profiles: {ex.Message}");
                return ProfileOperationResult.Failed("Failed to clear profiles", ex);
            }
        }

        #region Event Subscription Methods
        public void SubscribeToProfileLoaded(Action<string> callback)
            => profileEvents.OnProfileLoaded += callback;

        public void UnsubscribeFromProfileLoaded(Action<string> callback)
            => profileEvents.OnProfileLoaded -= callback;

        public void SubscribeToProfileSwitched(Action<string> callback)
        {
            if (profileEvents == null)
            {
                Debug.LogError("[ProfileManager] profileEvents is null in SubscribeToProfileSwitched");
                return;
            }
            profileEvents.OnProfileSwitched += callback;
        }

        public void UnsubscribeFromProfileSwitched(Action<string> callback)
            => profileEvents.OnProfileSwitched -= callback;

        public void SubscribeToNewProfileCreated(Action<string> callback)
            => profileEvents.OnNewProfileCreated += callback;

        public void UnsubscribeFromNewProfileCreated(Action<string> callback)
            => profileEvents.OnNewProfileCreated -= callback;

        public void SubscribeToProfileDeleted(Action<string> callback)
            => profileEvents.OnProfileDeleted += callback;

        public void UnsubscribeFromProfileDeleted(Action<string> callback)
            => profileEvents.OnProfileDeleted -= callback;
        #endregion

        protected override void OnDestroy()
        {
            if (isInitialized)
            {
                try
                {
                    // Don't wait for async operations during cleanup
                    if (!IsQuitting)
                    {
                        SaveProfilesAsync().GetAwaiter().GetResult();
                    }
                }
                catch (Exception ex)
                {
                    Debug.LogError($"[ProfileManager] Error during cleanup: {ex.Message}");
                }
                finally
                {
                    isInitialized = false;
                    profileEvents = null;
                }
            }

            base.OnDestroy();
        }
    }
}



// --- END FILE ---

// File: Core/Services/LeaderBoard/LeaderboardManager.cs
// Size: 352 characters
// ---
using CyberPickle.Core.Management;
using CyberPickle.Core.Interfaces;

namespace CyberPickle.Core.Services.Leaderboard
{
    public class LeaderboardManager : Manager<LeaderboardManager>, IInitializable
    {
        public void Initialize()
        {
            UnityEngine.Debug.Log("LeaderboardManager initialized");
        }
    }
}

// --- END FILE ---

// File: Core/Services/Steam/SteamManager.cs
// Size: 368 characters
// ---
// Core/Services/Steam/SteamManager.cs
using CyberPickle.Core.Management;
using CyberPickle.Core.Interfaces;

namespace CyberPickle.Core.Services.Steam
{
    public class SteamManager : Manager<SteamManager>, IInitializable
    {
        public void Initialize()
        {
            UnityEngine.Debug.Log("SteamManager initialized");
        }
    }
}

// --- END FILE ---

// File: UI/Components/ProfileCard/ProfileCardExpanded.cs
// Size: 6637 characters
// ---
// File: Assets/Code/UI/Components/ProfileCard/ProfileCardExpanded.cs
//
// Purpose: Handles the expanded view of the profile card showing detailed information
// and providing minimize and profile switch options.
//
// Created: 2024-02-11

using UnityEngine;
using UnityEngine.UI;
using TMPro;
using System;
using CyberPickle.Core.Events;
using CyberPickle.Core.Services.Authentication;
using CyberPickle.Core.Services.Authentication.Data;
using CyberPickle.Core.States;

namespace CyberPickle.UI.Components.ProfileCard
{
    public class ProfileCardExpanded : MonoBehaviour
    {
        [Header("Card Elements")]
        [SerializeField] private Image backgroundPanel;
        [SerializeField] private Image neonBorder;

        [Header("Header Section")]
        [SerializeField] private TextMeshProUGUI profileNameText;
        [SerializeField] private TextMeshProUGUI lastLoginText;
        [SerializeField] private Image avatarImage;

        [Header("Stats Grid")]
        [SerializeField] private GridLayoutGroup statsGrid;
        [SerializeField] private TextMeshProUGUI levelStatValue;
        [SerializeField] private TextMeshProUGUI timeStatValue;
        [SerializeField] private TextMeshProUGUI scoreStatValue;

        [Header("Buttons")]
        [SerializeField] private Button minimizeButton;
        [SerializeField] private TextMeshProUGUI minimizeButtonText;
        [SerializeField] private Button switchProfileButton;
        [SerializeField] private TextMeshProUGUI switchProfileButtonText;

        private ProfileData currentProfile;
        private CanvasGroup canvasGroup;

        private void Awake()
        {
            canvasGroup = GetComponent<CanvasGroup>();
            ValidateReferences();
            SetupButtons();
        }

        private void OnEnable()
        {
            SubscribeToEvents();
        }

        private void OnDisable()
        {
            UnsubscribeFromEvents();
        }

        private void ValidateReferences()
        {
            if (profileNameText == null)
                Debug.LogError("[ProfileCardExpanded] Profile name text is missing!");
            if (lastLoginText == null)
                Debug.LogError("[ProfileCardExpanded] Last login text is missing!");
            if (minimizeButton == null)
                Debug.LogError("[ProfileCardExpanded] Minimize button is missing!");
            if (switchProfileButton == null)
                Debug.LogError("[ProfileCardExpanded] Switch Profile button is missing!");
            if (canvasGroup == null)
                canvasGroup = gameObject.AddComponent<CanvasGroup>();
        }

        private void SetupButtons()
        {
            if (minimizeButton != null)
            {
                minimizeButton.onClick.AddListener(() => GameEvents.OnProfileCardClicked.Invoke());
                if (minimizeButtonText != null)
                    minimizeButtonText.text = "Minimize";
            }

            if (switchProfileButton != null)
            {
                switchProfileButton.onClick.AddListener(HandleSwitchProfileClick);
                if (switchProfileButtonText != null)
                    switchProfileButtonText.text = "Change Profile";
            }
        }

        private void SubscribeToEvents()
        {
            GameEvents.OnProfileCardInteractionEnabled.AddListener(SetInteractable);
        }

        private void UnsubscribeFromEvents()
        {
            GameEvents.OnProfileCardInteractionEnabled.RemoveListener(SetInteractable);
        }

        public void UpdateDisplay(ProfileData profileData)
        {
            if (profileData == null) return;

            currentProfile = profileData;

            // Update header information
            if (profileNameText != null)
                profileNameText.text = profileData.DisplayName;

            if (lastLoginText != null)
                lastLoginText.text = FormatLastLoginTime(profileData.LastLoginTime);

            // Update stats
            if (levelStatValue != null)
                levelStatValue.text = profileData.Level.ToString();

            if (timeStatValue != null)
                timeStatValue.text = FormatPlayTime(profileData.TotalPlayTime);

            if (scoreStatValue != null)
                scoreStatValue.text = profileData.HighestScore.ToString();

            // Avatar implementation can be added later
            if (avatarImage != null)
                avatarImage.gameObject.SetActive(false);
        }

        private void HandleSwitchProfileClick()
        {
            GameEvents.OnGameStateChanged.Invoke(GameState.ProfileSelection);
            GameEvents.OnProfileLoadRequested.Invoke();

        }

        public void SetInteractable(bool interactable)
        {
            if (minimizeButton != null)
                minimizeButton.interactable = interactable;

            if (switchProfileButton != null)
                switchProfileButton.interactable = interactable;

            if (canvasGroup != null)
            {
                canvasGroup.interactable = interactable;
                canvasGroup.blocksRaycasts = interactable;
            }
        }

        private string FormatPlayTime(float playTimeInSeconds)
        {
            TimeSpan time = TimeSpan.FromSeconds(playTimeInSeconds);
            if (time.TotalHours >= 1)
                return $"{(int)time.TotalHours}h {time.Minutes}m";
            else if (time.Minutes >= 1)
                return $"{time.Minutes}m {time.Seconds}s";
            else
                return $"{time.Seconds}s";
        }

        private string FormatLastLoginTime(DateTime lastLoginTime)
        {
            TimeSpan timeSince = DateTime.Now - lastLoginTime;

            if (timeSince.TotalDays >= 1)
                return $"{(int)timeSince.TotalDays} days ago";
            else if (timeSince.TotalHours >= 1)
                return $"{(int)timeSince.TotalHours} hours ago";
            else if (timeSince.TotalMinutes >= 1)
                return $"{(int)timeSince.TotalMinutes} minutes ago";
            else
                return "Just now";
        }

        private void OnDestroy()
        {
            if (minimizeButton != null)
                minimizeButton.onClick.RemoveAllListeners();

            if (switchProfileButton != null)
                switchProfileButton.onClick.RemoveAllListeners();

            UnsubscribeFromEvents();
        }
    }
}

// --- END FILE ---

// File: UI/Components/ProfileCard/ProfileCardManager.cs
// Size: 16116 characters
// ---
// File: Assets/Code/UI/Components/ProfileCard/ProfileCardManager.cs
//
// Purpose: Manages the profile card UI component states and transitions across different game screens.
// Maintains the current profile display state and handles interactions with the card.
//
// Created: 2024-02-11

using UnityEngine;
using System.Collections;
using CyberPickle.Core.Management;
using CyberPickle.Core.Interfaces;
using CyberPickle.Core.Events;
using CyberPickle.Core.Services.Authentication;
using CyberPickle.Core.Services.Authentication.Data;
using CyberPickle.Core.GameFlow.States.ProfileCard;
using CyberPickle.Core.States;

namespace CyberPickle.UI.Components.ProfileCard
{
    public class ProfileCardManager : Manager<ProfileCardManager>, IInitializable
    {
        [Header("References")]
        [SerializeField] private GameObject minimalCardPrefab;
        [SerializeField] private GameObject expandedCardPrefab;
        [SerializeField] private Canvas mainCanvas;

        [Header("Animation Settings")]
        [SerializeField] private float transitionDuration = 0.3f;
        [SerializeField] private float cornerPadding = 20f;

        private ProfileCardState currentState = ProfileCardState.Hidden;
        private GameObject currentCardInstance;
        private ProfileData currentProfileData;
        private bool isTransitioning;
        private Vector2 minimizedPosition;
        private Vector2 expandedPosition;
        private bool isInitialized;

        public ProfileCardState CurrentState => currentState;
        public bool IsTransitioning => isTransitioning;
        public ProfileData CurrentProfileData => currentProfileData;

        public void Initialize()
        {
            if (isInitialized) return;

            ValidateReferences();
            SubscribeToEvents();
            CalculatePositions();

            isInitialized = true;
            Debug.Log("[ProfileCardManager] Initialized");
        }

        private void ValidateReferences()
        {
            if (minimalCardPrefab == null)
                Debug.LogError("[ProfileCardManager] Minimal card prefab is not assigned!");
            if (expandedCardPrefab == null)
                Debug.LogError("[ProfileCardManager] Expanded card prefab is not assigned!");
            if (mainCanvas == null)
                mainCanvas = FindObjectOfType<Canvas>();
            if (mainCanvas == null)
                Debug.LogError("[ProfileCardManager] No main canvas found in scene!");
        }

        private void SubscribeToEvents()
        {
            GameEvents.OnProfileCardClicked.AddListener(HandleCardClicked);
            GameEvents.OnProfileSelected.AddListener(HandleProfileSelected);
            GameEvents.OnGameStateChanged.AddListener(HandleGameStateChanged);
            GameEvents.OnProfileLoadRequested.AddListener(HandleProfileLoadRequested);
        }
        private void HandleProfileLoadRequested()
        {
            // When returning to profile selection, hide the card
            if (currentCardInstance != null)
            {
                Debug.Log("[ProfileCardManager] Profile load requested, hiding card");
                currentCardInstance.SetActive(false);
                currentState = ProfileCardState.Hidden;
                Debug.Log($"[ProfileCardManagerHandleprofileloadrequested] Card active hidden");
            }
        }


        private void CalculatePositions()
        {
            if (mainCanvas == null) return;

            RectTransform canvasRect = mainCanvas.GetComponent<RectTransform>();

            // Top-right corner positioning
            float padding = 20f;
            minimizedPosition = new Vector2(-padding, -padding);

            // Expanded position also in top-right
            float expandedPadding = 40f;
            expandedPosition = new Vector2(-expandedPadding, -expandedPadding);
        }

        public void SetProfile(ProfileData profileData)
        {
            if (profileData == null)
            {
                Debug.LogError("[ProfileCardManager] Attempted to set null profile data");
                return;
            }

            currentProfileData = profileData;
            UpdateCardDisplay();
        }

        private void UpdateCardDisplay()
        {
            if (currentProfileData == null || isTransitioning) return;

            switch (currentState)
            {
                case ProfileCardState.Minimized:
                    UpdateMinimalCard();
                    break;
                case ProfileCardState.Expanded:
                    UpdateExpandedCard();
                    break;
            }
        }

        private void UpdateMinimalCard()
        {
            if (currentCardInstance == null ||
                currentCardInstance.GetComponent<ProfileCardMinimal>() == null)
            {
                CreateMinimalCard();
            }

            var minimalCard = currentCardInstance.GetComponent<ProfileCardMinimal>();
            if (minimalCard != null)
            {
                minimalCard.UpdateDisplay(currentProfileData);
            }
        }

        private void UpdateExpandedCard()
        {
            if (currentCardInstance == null ||
                currentCardInstance.GetComponent<ProfileCardExpanded>() == null)
            {
                CreateExpandedCard();
            }

            var expandedCard = currentCardInstance.GetComponent<ProfileCardExpanded>();
            if (expandedCard != null)
            {
                expandedCard.UpdateDisplay(currentProfileData);
            }
        }

        private void CreateMinimalCard()
        {
            Debug.Log("[ProfileCardManager] Creating minimal card...");

            if (currentCardInstance != null)
            {
                Debug.Log("[ProfileCardManager] Destroying previous card instance");
                Destroy(currentCardInstance);
            }

            currentCardInstance = Instantiate(minimalCardPrefab, mainCanvas.transform);
            Debug.Log($"[ProfileCardManager] Minimal card created. Active state: {currentCardInstance.activeSelf}");

            var cardRect = currentCardInstance.GetComponent<RectTransform>();
            SetupCardTransform(cardRect, minimizedPosition);

            // Ensure the card is active
            currentCardInstance.SetActive(true);
            Debug.Log($"[ProfileCardManager] After setup. Active state: {currentCardInstance.activeSelf}");

            var minimalCard = currentCardInstance.GetComponent<ProfileCardMinimal>();
            if (minimalCard != null && currentProfileData != null)
            {
                minimalCard.UpdateDisplay(currentProfileData);
                Debug.Log($"[ProfileCardManager] Updated minimal card display for profile: {currentProfileData.DisplayName}");
            }
            else
            {
                Debug.LogError("[ProfileCardManager] Failed to initialize minimal card display");
            }
        }

        private void CreateExpandedCard()
        {
            if (currentCardInstance != null)
                Destroy(currentCardInstance);

            currentCardInstance = Instantiate(expandedCardPrefab, mainCanvas.transform);
            var cardRect = currentCardInstance.GetComponent<RectTransform>();

            // For expanded card, we want it centered
            cardRect.anchorMin = new Vector2(0.5f, 0.5f);
            cardRect.anchorMax = new Vector2(0.5f, 0.5f);
            cardRect.pivot = new Vector2(0.5f, 0.5f);
            cardRect.anchoredPosition = Vector2.zero;

            // Update the card display immediately
            var expandedCard = currentCardInstance.GetComponent<ProfileCardExpanded>();
            if (expandedCard != null && currentProfileData != null)
            {
                expandedCard.UpdateDisplay(currentProfileData);
            }
            else
            {
                Debug.LogError("[ProfileCardManager] Failed to initialize expanded card display");
            }
        }

        private void SetupCardTransform(RectTransform cardRect, Vector2 position)
        {
            if (cardRect == null) return;

            // Set the anchors to top-right corner
            cardRect.anchorMin = Vector2.one;
            cardRect.anchorMax = Vector2.one;
            cardRect.pivot = Vector2.one;

            // When using top-right anchoring, negative values move in from the corner
            float padding = 20f;
            cardRect.anchoredPosition = new Vector2(-padding, -padding);
        }

        public void TransitionToState(ProfileCardState targetState)
        {
            if (currentState == targetState || isTransitioning) return;
            StartCoroutine(TransitionRoutine(targetState));
        }

        private IEnumerator TransitionRoutine(ProfileCardState targetState)
        {
            isTransitioning = true;
            currentState = ProfileCardState.Transitioning;
            GameEvents.OnProfileCardStateChanged.Invoke(ProfileCardState.Transitioning);
            GameEvents.OnProfileCardInteractionEnabled.Invoke(false);

            Vector3 startPosition = currentCardInstance != null ?
                currentCardInstance.transform.position : Vector3.zero;

            // Create and set up the target state card
            GameObject targetCard = null;
            RectTransform targetRect = null;

            switch (targetState)
            {
                case ProfileCardState.Minimized:
                    targetCard = Instantiate(minimalCardPrefab, mainCanvas.transform);
                    targetRect = targetCard.GetComponent<RectTransform>();
                    SetupMinimizedCardPosition(targetRect);
                    var minimalCard = targetCard.GetComponent<ProfileCardMinimal>();
                    if (minimalCard != null && currentProfileData != null)
                    {
                        minimalCard.UpdateDisplay(currentProfileData);
                    }
                    break;

                case ProfileCardState.Expanded:
                    targetCard = Instantiate(expandedCardPrefab, mainCanvas.transform);
                    targetRect = targetCard.GetComponent<RectTransform>();
                    SetupExpandedCardPosition(targetRect);
                    var expandedCard = targetCard.GetComponent<ProfileCardExpanded>();
                    if (expandedCard != null && currentProfileData != null)
                    {
                        expandedCard.UpdateDisplay(currentProfileData);
                    }
                    break;
            }

            if (targetCard != null)
            {
                // Set initial position to match current card
                targetRect.position = startPosition;

                // Get target position based on state
                Vector2 targetPosition = targetState == ProfileCardState.Minimized ?
                    minimizedPosition : expandedPosition;

                // Perform transition
                float elapsedTime = 0f;
                while (elapsedTime < transitionDuration)
                {
                    elapsedTime += Time.deltaTime;
                    float t = elapsedTime / transitionDuration;
                    float smoothT = t * t * (3f - 2f * t); // Smooth interpolation

                    targetRect.anchoredPosition = Vector2.Lerp(
                        targetRect.anchoredPosition,
                        targetPosition,
                        smoothT
                    );

                    yield return null;
                }

                // Ensure final position
                targetRect.anchoredPosition = targetPosition;

                // Cleanup old card
                if (currentCardInstance != null && currentCardInstance != targetCard)
                {
                    Destroy(currentCardInstance);
                }
                currentCardInstance = targetCard;
            }

            currentState = targetState;
            isTransitioning = false;

            GameEvents.OnProfileCardStateChanged.Invoke(currentState);
            GameEvents.OnProfileCardTransitionComplete.Invoke();
            GameEvents.OnProfileCardInteractionEnabled.Invoke(true);
        }

        private void SetupMinimizedCardPosition(RectTransform cardRect)
        {
            // Set the anchors to top-right corner
            cardRect.anchorMin = Vector2.one;
            cardRect.anchorMax = Vector2.one;
            cardRect.pivot = Vector2.one;

            // Position from top-right corner with padding
            float padding = 20f;
            minimizedPosition = new Vector2(-padding, -padding);
        }

        private void SetupExpandedCardPosition(RectTransform cardRect)
        {
            // For expanded, keep it in the top-right but with more space
            cardRect.anchorMin = Vector2.one;
            cardRect.anchorMax = Vector2.one;
            cardRect.pivot = new Vector2(1f, 1f);

            // Calculate expanded position (still in top-right, but larger)
            float xPadding = 40f;  // Increased padding for expanded state
            float yPadding = 40f;
            expandedPosition = new Vector2(-xPadding, -yPadding);
        }
        private void HandleCardClicked()
        {
            if (isTransitioning) return;

            switch (currentState)
            {
                case ProfileCardState.Minimized:
                    TransitionToState(ProfileCardState.Expanded);
                    break;
                case ProfileCardState.Expanded:
                    TransitionToState(ProfileCardState.Minimized);
                    break;
            }
        }

        private void HandleProfileSelected(string profileId)
        {
            var profileManager = ProfileManager.Instance;
            if (profileManager != null)
            {
                var profile = profileManager.GetProfile(profileId);
                if (profile != null)
                {
                    SetProfile(profile);
                    if (currentState == ProfileCardState.Hidden)
                    {
                        TransitionToState(ProfileCardState.Minimized);
                    }
                }
            }
        }

        private void HandleGameStateChanged(GameState newState)
        {
            switch (newState)
            {
                case GameState.MainMenu:
                    if (currentProfileData != null && currentState == ProfileCardState.Hidden)
                    {
                        TransitionToState(ProfileCardState.Minimized);
                    }
                    break;

                case GameState.ProfileSelection:
                    // Hide the card completely
                    if (currentCardInstance != null)
                    {
                        Destroy(currentCardInstance);
                        currentCardInstance = null;
                    }
                    currentState = ProfileCardState.Hidden;
                    Debug.Log($"[ProfileCardManagerHandleGameStateChanged] Card active hidden");
                    break;
            }
        }

        protected override void OnManagerDestroyed()
        {
            GameEvents.OnProfileCardClicked.RemoveListener(HandleCardClicked);
            GameEvents.OnProfileSelected.RemoveListener(HandleProfileSelected);
            GameEvents.OnGameStateChanged.RemoveListener(HandleGameStateChanged);
            GameEvents.OnProfileLoadRequested.RemoveListener(HandleProfileLoadRequested);

            if (currentCardInstance != null)
                Destroy(currentCardInstance);
        }
    }
}

// --- END FILE ---

// File: UI/Components/ProfileCard/ProfileCardMinimal.cs
// Size: 3676 characters
// ---
// File: Assets/Code/UI/Components/ProfileCard/ProfileCardMinimal.cs
//
// Purpose: Handles the minimized corner view of the profile card showing essential information
// and handling basic interactions.
//
// Created: 2024-02-11

using UnityEngine;
using UnityEngine.UI;
using TMPro;
using CyberPickle.Core.Events;
using CyberPickle.Core.Services.Authentication.Data;

namespace CyberPickle.UI.Components.ProfileCard
{
    public class ProfileCardMinimal : MonoBehaviour
    {
        [Header("UI Elements")]
        [SerializeField] private TextMeshProUGUI playerNameText;
        [SerializeField] private TextMeshProUGUI levelText;
        [SerializeField] private Image avatarImage;
        [SerializeField] private Button cardButton;

        [Header("Animation")]
        [SerializeField] private CanvasGroup canvasGroup;
        [SerializeField] private float hoverScaleMultiplier = 1.05f;

        private Vector3 originalScale;
        private ProfileData currentProfile;

        private void Awake()
        {
            ValidateReferences();
            SetupInteractions();
        }

        private void OnEnable()
        {
            SubscribeToEvents();
        }

        private void OnDisable()
        {
            UnsubscribeFromEvents();
        }

        private void ValidateReferences()
        {
            if (playerNameText == null)
                Debug.LogError("[ProfileCardMinimal] Player name text is missing!");
            if (levelText == null)
                Debug.LogError("[ProfileCardMinimal] Level text is missing!");
            if (cardButton == null)
                cardButton = GetComponent<Button>();
            if (canvasGroup == null)
                canvasGroup = GetComponent<CanvasGroup>();

            originalScale = transform.localScale;
        }

        private void SetupInteractions()
        {
            if (cardButton != null)
            {
                cardButton.onClick.AddListener(() => GameEvents.OnProfileCardClicked.Invoke());
            }
        }

        private void SubscribeToEvents()
        {
            GameEvents.OnProfileCardInteractionEnabled.AddListener(SetInteractable);
        }

        private void UnsubscribeFromEvents()
        {
            GameEvents.OnProfileCardInteractionEnabled.RemoveListener(SetInteractable);
        }

        public void UpdateDisplay(ProfileData profileData)
        {
            if (profileData == null) return;

            currentProfile = profileData;

            if (playerNameText != null)
                playerNameText.text = profileData.DisplayName;

            if (levelText != null)
                levelText.text = $"Level {profileData.Level}";
        }

        public void SetInteractable(bool interactable)
        {
            if (cardButton != null)
                cardButton.interactable = interactable;

            if (canvasGroup != null)
            {
                canvasGroup.interactable = interactable;
                canvasGroup.blocksRaycasts = interactable;
            }
        }

        private void OnDestroy()
        {
            if (cardButton != null)
                cardButton.onClick.RemoveAllListeners();

            UnsubscribeFromEvents();
        }

        #region Mouse Interaction Handlers

        public void OnPointerEnter()
        {
            transform.localScale = originalScale * hoverScaleMultiplier;
        }

        public void OnPointerExit()
        {
            transform.localScale = originalScale;
        }

        #endregion
    }
}
// --- END FILE ---

// File: UI/Effects/Config/GlitchTextConfig.cs
// Size: 2377 characters
// ---
using UnityEngine;

namespace CyberPickle.UI.Effects.Config
{
    [CreateAssetMenu(fileName = "GlitchTextConfig", menuName = "CyberPickle/UI/Effects/GlitchTextConfig")]
    public class GlitchTextConfig : ScriptableObject
    {
        [Header("Glitch Effect Settings")]
        [Range(0.1f, 2f)]
        public float glitchInterval = 0.95f;

        [Range(0f, 1f)]
        public float glitchIntensity;

        [Range(0f, 1f)]
        public float glitchIntensityMax;

        [Range(0f, 1f)]
        public float glitchIntensityMin;

        [Range(0f, 0.5f)]
        public float glitchAmplitude = 0.1f;

        [Range(0f, 10f)]
        public float glitchSpeed = 5f;

        [Header("Random Character Effect Settings")]
        [Range(0.1f, 2f)]
        public float randomCharIntervalMin = 0.5f;

        [Range(0.1f, 2f)]
        public float randomCharIntervalMax = 2f;

        [Range(0.01f, 0.5f)]
        public float randomCharDisplayDurationMin = 0.05f;

        [Range(0.1f, 1f)]
        public float randomCharDisplayDurationMax = 0.3f;

        [Range(0f, 1f)]
        public float randomCharIntensity = 0.5f;

        [Header("Fade-In Effect Settings")]
        [Range(0.1f, 5f)]
        public float fadeDuration = 2f;

        [Header("Pulse Animation Settings")]
        [Range(1f, 1.5f)]
        public float pulseScale = 1.1f;

        [Range(0.1f, 5f)]
        public float pulseSpeed = 1f;

        [Header("Scanline Effect Settings")]
        [Range(0f, 1f)]
        public float scanlineIntensity = 1f;

        [Range(0f, 10f)]
        public float scanlineSpeed = 4.1f;

        [Range(100f, 2000f)]
        public float scanlineFrequency = 800f;

        [Header("Chromatic Aberration Settings")]
        [Range(0f, 0.01f)]
        public float chromAberration = 0.002f;

        [Header("Color Glitch Effect Settings")]
        [Range(0f, 1f)]
        public float colorGlitchIntensity = 0.5f;

        [Range(0.1f, 2f)]
        public float colorGlitchDuration = 0.5f;

        [Header("Dynamic Glitch Intensity Settings")]
        [Range(0.1f, 5f)]
        public float glitchIntensityDuration = 2f;

        [Range(5f, 15f)]
        public float glitchIntensityInterval = 10f;

        [Range(0f, 0.05f)]
        public float rgbSplitAmount = 0.01f;
    }
}
// --- END FILE ---

// File: UI/Screens/MainMenu/CreateProfileCardController.cs
// Size: 13469 characters
// ---
// File: Assets/Code/UI/Screens/MainMenu/CreateProfileCardController.cs
//
// Purpose: Controls the create profile card UI and transitions between card content and terminal interface.
// This controller focuses solely on UI handling and delegates profile creation to the ProfileManager.
//
// Created: 2024-01-13
// Updated: 2024-01-14

using UnityEngine;
using TMPro;
using UnityEngine.UI;
using System.Collections;
using System;
using System.Threading.Tasks;
using CyberPickle.Core.Services.Authentication;
using CyberPickle.Core.Services.Authentication.Flow.Commands;
using CyberPickle.Core.Events;
using CyberPickle.Core.Services.Authentication.Flow;
using CyberPickle.Core.States;

namespace CyberPickle.UI.Screens.MainMenu
{
    public class CreateProfileCardController : MonoBehaviour
    {
        [Header("Card Content")]
        [SerializeField] private GameObject cardContent;
        [SerializeField] private CanvasGroup cardContentCanvasGroup;

        [Header("Terminal Interface")]
        [SerializeField] private GameObject terminalInterface;
        [SerializeField] private CanvasGroup terminalCanvasGroup;
        [SerializeField] private TMP_InputField inputField;
        [SerializeField] private Button confirmButton;
        [SerializeField] private Button cancelButton;
        [SerializeField] private TextMeshProUGUI statusText;

        [Header("Validation")]
        [SerializeField] private GameObject validationSection;
        [SerializeField] private TextMeshProUGUI[] validationMessages;

        [Header("Animation Settings")]
        [SerializeField] private float transitionDuration = 0.5f;
        [SerializeField] private float statusMessageDuration = 3f;

        private bool isProcessing;
        private ProfileManager profileManager;
        private AuthenticationManager authManager;
        private AuthenticationFlowManager flowManager;
        private Coroutine statusMessageCoroutine;

        private void Awake()
        {
            
            profileManager = ProfileManager.Instance;
            authManager = AuthenticationManager.Instance;
            flowManager = AuthenticationFlowManager.Instance;

            InitializeComponents();
            SetInitialState();
            SubscribeToEvents();
            Debug.Log($"[CreateProfileCardController]: Awake");
        }

        public void ResetCard()
        {
            if (statusMessageCoroutine != null)
                StopCoroutine(statusMessageCoroutine);

            isProcessing = false;

            if (inputField != null)
            {
                inputField.text = string.Empty;
                inputField.interactable = true;
                
            }

            if (statusText != null)
                statusText.text = string.Empty;

            SetInitialState();
            Debug.Log("[CreateProfileCardController] Card reset completed");
        }

        private void InitializeComponents()
        {
            InitializeCanvasGroups();
            InitializeButtons();
            InitializeInputField();
        }

        private void InitializeCanvasGroups()
        {
            if (cardContentCanvasGroup == null && cardContent != null)
                cardContentCanvasGroup = cardContent.GetComponent<CanvasGroup>() ?? cardContent.gameObject.AddComponent<CanvasGroup>();

            if (terminalCanvasGroup == null && terminalInterface != null)
                terminalCanvasGroup = terminalInterface.GetComponent<CanvasGroup>() ?? terminalInterface.gameObject.AddComponent<CanvasGroup>();
        }

        private void InitializeButtons()
        {
            // Setup card button
            Button cardButton = cardContent.GetComponent<Button>() ?? cardContent.gameObject.AddComponent<Button>();
            cardButton.onClick.AddListener(StartProfileCreation);

            // Setup other buttons
            if (confirmButton != null)
                confirmButton.onClick.AddListener(HandleProfileConfirmationAsync);

            if (cancelButton != null)
                cancelButton.onClick.AddListener(CancelProfileCreation);
        }

        private void InitializeInputField()
        {
            if (inputField != null)
                inputField.onValueChanged.AddListener(ValidateInput);
        }

        private void SubscribeToEvents()
        {
            if (profileManager != null)
            {
                profileManager.SubscribeToNewProfileCreated(HandleProfileCreated);
            }
        }

        private void SetInitialState()
        {
            // Show card content, hide terminal
            SetCardContentActive(true, 1f);
            SetTerminalInterfaceActive(false, 0f);

            if (cardContent != null)
            {
                cardContent.SetActive(true);
                var button = cardContent.GetComponent<Button>();
                if (button != null)
                    button.interactable = true;
            }

            if (terminalInterface != null)
                terminalInterface.SetActive(false);

            if (validationSection != null)
                validationSection.SetActive(false);
        }

        public void StartProfileCreation()
        {
            if (isProcessing) return;
            isProcessing = true;

            if (terminalInterface != null)
            {
                terminalInterface.SetActive(true);
                if (terminalCanvasGroup != null)
                    terminalCanvasGroup.alpha = 0f;
            }

            StartCoroutine(TransitionToTerminal());
        }

        private async void HandleProfileConfirmationAsync()
        {
            if (string.IsNullOrWhiteSpace(inputField.text)) return;

            string displayName = inputField.text.Trim();
            SetInteractable(false);
            UpdateStatus("Creating profile...");

            try
            {
                var command = new CreateProfileCommand(profileManager, displayName);
                await flowManager.ExecuteCommand(command);

                // Success will be handled in HandleProfileCreated
            }
            catch (Exception ex)
            {
                SetInteractable(true);
                ShowTemporaryStatus($"Failed to create profile: {ex.Message}", isError: true);
                Debug.LogError($"[CreateProfileCard] Error creating profile: {ex.Message}");
            }
        }

        private void HandleProfileCreated(string profileId)
        {
            if (!gameObject.activeInHierarchy) return;

            ShowTemporaryStatus("Profile created successfully!");
            Debug.Log("CreateProfileControler : ProfileCreated");
            ResetCard();
            Debug.Log("CreateProfileControler : ProfileReset");
            // Transition to main menu state just like when selecting a profile
            GameEvents.OnGameStateChanged.Invoke(GameState.MainMenu);
        }

        private void ShowTemporaryStatus(string message, bool isError = false)
        {
            if (statusMessageCoroutine != null)
                StopCoroutine(statusMessageCoroutine);

            statusMessageCoroutine = StartCoroutine(ShowStatusMessageRoutine(message, isError));
        }

        private IEnumerator ShowStatusMessageRoutine(string message, bool isError)
        {
            UpdateStatus(message);
            if (statusText != null)
                statusText.color = isError ? Color.red : Color.white;

            yield return new WaitForSeconds(statusMessageDuration);

            if (statusText != null)
            {
                statusText.text = "";
                statusText.color = Color.white;
            }
        }

        private void ValidateInput(string input)
        {
            if (string.IsNullOrEmpty(input))
            {
                SetConfirmButtonState(false);
                return;
            }

            bool isValid = true;
            isValid &= input.Length >= 3 && input.Length <= 20;
            isValid &= System.Text.RegularExpressions.Regex.IsMatch(input, "^[a-zA-Z0-9_]+$");

            SetConfirmButtonState(isValid);
            UpdateValidationMessages(input);
        }

        private IEnumerator TransitionToTerminal()
        {
            Debug.Log("[CreateProfileCard] Starting transition to terminal interface");

            float elapsedTime = 0f;
            while (elapsedTime < transitionDuration)
            {
                elapsedTime += Time.deltaTime;
                float normalizedTime = elapsedTime / transitionDuration;

                SetCardContentActive(false, 1 - normalizedTime);
                SetTerminalInterfaceActive(true, normalizedTime);

                yield return null;
            }

            if (cardContent != null)
                cardContent.SetActive(false);

            FinalizeTransition();
            isProcessing = false;
        }

        private void FinalizeTransition()
        {
            SetCardContentActive(false);
            SetTerminalInterfaceActive(true);

            if (inputField != null)
            {
                inputField.text = string.Empty;
                inputField.Select();
                inputField.ActivateInputField();
            }

            if (validationSection != null)
                validationSection.SetActive(true);
        }


        private void CancelProfileCreation()
        {
            StartCoroutine(TransitionToCard());
        }

        private IEnumerator TransitionToCard()
        {
            float elapsedTime = 0f;
            while (elapsedTime < transitionDuration)
            {
                elapsedTime += Time.deltaTime;
                float normalizedTime = elapsedTime / transitionDuration;

                SetCardContentActive(true, normalizedTime);
                SetTerminalInterfaceActive(false, 1 - normalizedTime);

                yield return null;
            }

            SetInitialState();
            isProcessing = false;
        }

        private void SetCardContentActive(bool active, float alpha = 1f)
        {
            if (cardContentCanvasGroup == null) return;

            cardContentCanvasGroup.alpha = alpha;
            cardContentCanvasGroup.interactable = active;
            cardContentCanvasGroup.blocksRaycasts = active;
        }

        private void SetTerminalInterfaceActive(bool active, float alpha = 1f)
        {
            if (terminalCanvasGroup == null) return;

            terminalCanvasGroup.alpha = alpha;
            terminalCanvasGroup.interactable = active;
            terminalCanvasGroup.blocksRaycasts = active;
        }

        private void SetConfirmButtonState(bool enabled)
        {
            if (confirmButton != null)
                confirmButton.interactable = enabled;
        }

        private void SetInteractable(bool interactable)
        {
            if (inputField != null)
                inputField.interactable = interactable;
            if (confirmButton != null)
                confirmButton.interactable = interactable;
            if (cancelButton != null)
                cancelButton.interactable = interactable;
        }

        private void UpdateStatus(string message)
        {
            if (statusText != null)
                statusText.text = message;
        }

        private void UpdateValidationMessages(string input)
        {
            if (validationMessages == null || validationMessages.Length == 0)
                return;

            if (validationMessages.Length > 0)
                validationMessages[0].text = input.Length >= 3 && input.Length <= 20 ?
                    "Length: Valid" : "Length: Must be 3-20 characters";

            if (validationMessages.Length > 1)
                validationMessages[1].text = System.Text.RegularExpressions.Regex.IsMatch(input, "^[a-zA-Z0-9_]+$") ?
                    "Characters: Valid" : "Characters: Use only letters, numbers, and underscore";
        }

        private void OnDestroy()
        {
            if (statusMessageCoroutine != null)
                StopCoroutine(statusMessageCoroutine);

            UnsubscribeFromEvents();
            CleanupEventListeners();
        }

        private void UnsubscribeFromEvents()
        {
            if (profileManager != null)
            {
                profileManager.UnsubscribeFromNewProfileCreated(HandleProfileCreated);
            }
        }

        private void CleanupEventListeners()
        {
            if (cardContent != null)
            {
                var button = cardContent.GetComponent<Button>();
                if (button != null)
                    button.onClick.RemoveListener(StartProfileCreation);
            }

            if (confirmButton != null)
                confirmButton.onClick.RemoveListener(HandleProfileConfirmationAsync);

            if (cancelButton != null)
                cancelButton.onClick.RemoveListener(CancelProfileCreation);

            if (inputField != null)
                inputField.onValueChanged.RemoveListener(ValidateInput);
        }
    }
}

// --- END FILE ---

// File: UI/Screens/MainMenu/MainMenuButtonsController.cs
// Size: 9119 characters
// ---
using UnityEngine;
using UnityEngine.UI;
using TMPro;
using CyberPickle.Core.Events;
using CyberPickle.Core.States;
using System.Collections;
using CyberPickle.Core;
using CyberPickle.Core.Services.Authentication;

namespace CyberPickle.UI.Screens.MainMenu
{
    /// <summary>
    /// Controls the main menu buttons behavior and animations.
    /// Assumes it's attached to the MainMenuButtonsPanel GameObject.
    /// </summary>
    public class MainMenuButtonsController : MonoBehaviour
    {
        [Header("Button References")]
        [SerializeField] private Button startButton;
        [SerializeField] private Button optionsButton;
        [SerializeField] private Button quitButton;

        private CanvasGroup buttonsPanelCanvasGroup;
        private bool isTransitioning = false;

        private void Awake()
        {
            Debug.Log("[MainMenuButtonsController] Awake called");
            ValidateReferences();
            InitializeButtonStates();
        }

        private void OnEnable()
        {
            Debug.Log("[MainMenuButtonsController] OnEnable called - Current game state: " + GameManager.Instance.CurrentState);
            SubscribeToEvents();
            SetupButtonListeners();

            // Force check current state
            if (GameManager.Instance.CurrentState == GameState.MainMenu)
            {
                Debug.Log("[MainMenuButtonsController] Already in MainMenu state, forcing button activation");
                ForceActivateButtons();
            }
        }

        private void ValidateReferences()
        {
            buttonsPanelCanvasGroup = GetComponent<CanvasGroup>();
            if (buttonsPanelCanvasGroup == null)
            {
                buttonsPanelCanvasGroup = gameObject.AddComponent<CanvasGroup>();
            }

            Debug.Log($"[MainMenuButtonsController] Start Button: {(startButton != null ? "Found" : "Missing")}");
            Debug.Log($"[MainMenuButtonsController] Options Button: {(optionsButton != null ? "Found" : "Missing")}");
            Debug.Log($"[MainMenuButtonsController] Quit Button: {(quitButton != null ? "Found" : "Missing")}");

            if (buttonsPanelCanvasGroup != null)
            {
                Debug.Log($"[MainMenuButtonsController] CanvasGroup - interactable: {buttonsPanelCanvasGroup.interactable}, blocksRaycasts: {buttonsPanelCanvasGroup.blocksRaycasts}, alpha: {buttonsPanelCanvasGroup.alpha}");
            }
        }

        private void InitializeButtonStates()
        {
            Debug.Log("[MainMenuButtonsController] Initializing button states");
            SetButtonsInteractable(true); // Start with buttons interactable
            if (buttonsPanelCanvasGroup != null)
            {
                buttonsPanelCanvasGroup.alpha = 1f;
                buttonsPanelCanvasGroup.interactable = true;
                buttonsPanelCanvasGroup.blocksRaycasts = true;
                Debug.Log("[MainMenuButtonsController] CanvasGroup initialized and set to interactive");
            }
        }

        private void SubscribeToEvents()
        {
            GameEvents.OnGameStateChanged.AddListener(HandleGameStateChanged);
            GameEvents.OnUIAnimationCompleted.AddListener(HandleUIAnimationCompleted);
            GameEvents.OnProfileSelected.AddListener(HandleProfileSelected);
            Debug.Log("[MainMenuButtonsController] Events subscribed");
        }

        private void SetupButtonListeners()
        {
            if (startButton != null)
            {
                startButton.onClick.RemoveAllListeners();
                startButton.onClick.AddListener(OnStartClicked);
            }
            if (optionsButton != null)
            {
                optionsButton.onClick.RemoveAllListeners();
                optionsButton.onClick.AddListener(OnOptionsClicked);
            }
            if (quitButton != null)
            {
                quitButton.onClick.RemoveAllListeners();
                quitButton.onClick.AddListener(OnQuitClicked);
            }
            Debug.Log("[MainMenuButtonsController] Button listeners setup complete");
        }

        private void HandleGameStateChanged(GameState newState)
        {
            Debug.Log($"[MainMenuButtonsController] Game state changed to: {newState}");

            if (newState == GameState.MainMenu)
            {
                Debug.Log("[MainMenuButtonsController] Transitioning to MainMenu state");
                ForceActivateButtons();
            }
        }

        private void HandleUIAnimationCompleted()
        {
            Debug.Log("[MainMenuButtonsController] UI Animation completed");
            if (GameManager.Instance.CurrentState == GameState.MainMenu)
            {
                Debug.Log("[MainMenuButtonsController] UI Animation completed in MainMenu state - Activating buttons");
                ForceActivateButtons();
            }
        }

        private void HandleProfileSelected(string profileId)
        {
            Debug.Log($"[MainMenuButtonsController] Profile selected: {profileId}");
            if (!string.IsNullOrEmpty(profileId) && GameManager.Instance.CurrentState == GameState.MainMenu)
            {
                ForceActivateButtons();
            }
        }

        private void ForceActivateButtons()
        {
            Debug.Log("[MainMenuButtonsController] Force activating buttons");

            // Log button states before activation
            LogButtonStates("Before activation");

            if (buttonsPanelCanvasGroup != null)
            {
                buttonsPanelCanvasGroup.alpha = 1f;
                buttonsPanelCanvasGroup.interactable = true;
                buttonsPanelCanvasGroup.blocksRaycasts = true;
            }

            SetButtonsInteractable(true);

            // Log button states after activation
            LogButtonStates("After activation");
        }

        private void SetButtonsInteractable(bool interactable)
        {
            if (startButton != null)
            {
                startButton.interactable = interactable;
                Debug.Log($"[MainMenuButtonsController] Set Start button interactable: {interactable}");
            }
            if (optionsButton != null)
            {
                optionsButton.interactable = interactable;
            }
            if (quitButton != null)
            {
                quitButton.interactable = interactable;
            }

            if (buttonsPanelCanvasGroup != null)
            {
                buttonsPanelCanvasGroup.interactable = interactable;
                buttonsPanelCanvasGroup.blocksRaycasts = interactable;
                Debug.Log($"[MainMenuButtonsController] Set CanvasGroup - interactable: {interactable}, blocksRaycasts: {interactable}");
            }
        }

        private void LogButtonStates(string context)
        {
            Debug.Log($"[MainMenuButtonsController] Button States ({context}):");
            if (startButton != null)
                Debug.Log($"[MainMenuButtonsController] Start button interactable: {startButton.interactable}");
            if (optionsButton != null)
                Debug.Log($"[MainMenuButtonsController] Options button interactable: {optionsButton.interactable}");
            if (quitButton != null)
                Debug.Log($"[MainMenuButtonsController] Quit button interactable: {quitButton.interactable}");
            if (buttonsPanelCanvasGroup != null)
                Debug.Log($"[MainMenuButtonsController] CanvasGroup - interactable: {buttonsPanelCanvasGroup.interactable}, blocksRaycasts: {buttonsPanelCanvasGroup.blocksRaycasts}, alpha: {buttonsPanelCanvasGroup.alpha}");
        }

        private void OnStartClicked()
        {
            Debug.Log("[MainMenuButtonsController] Start button clicked");
            Debug.Log($"[MainMenu] Starting character select. Active profile: {ProfileManager.Instance.ActiveProfile?.ProfileId}");
            GameEvents.OnGameStateChanged.Invoke(GameState.CharacterSelect);            
        }

        private void OnOptionsClicked()
        {
            Debug.Log("[MainMenuButtonsController] Options button clicked");
            // TODO: Implement options menu
        }

        private void OnQuitClicked()
        {
            Debug.Log("[MainMenuButtonsController] Quit button clicked");
#if UNITY_EDITOR
            UnityEditor.EditorApplication.isPlaying = false;
#else
            Application.Quit();
#endif
        }

        private void OnDisable()
        {
            GameEvents.OnGameStateChanged.RemoveListener(HandleGameStateChanged);
            GameEvents.OnUIAnimationCompleted.RemoveListener(HandleUIAnimationCompleted);
            GameEvents.OnProfileSelected.RemoveListener(HandleProfileSelected);
            Debug.Log("[MainMenuButtonsController] Events unsubscribed");
        }
    }
}
// --- END FILE ---

// File: UI/Screens/MainMenu/MainMenuController.cs
// Size: 10126 characters
// ---
// File: Assets/Code/UI/Screens/MainMenu/MainMenuController.cs
// Namespace: CyberPickle.UI.Screens.MainMenu
//
// Purpose: Controls the main menu flow and transitions to authentication
// Handles the "Press Any Button" state and triggers authentication process via events

using UnityEngine;
using TMPro;
using CyberPickle.Core.Events;
using CyberPickle.Core.States;
using System.Collections;

namespace CyberPickle.UI.Screens.MainMenu
{
    public class MainMenuController : MonoBehaviour
    {
        [Header("UI References")]
        [SerializeField] private TextMeshProUGUI pressAnyButtonText;
        [SerializeField] private GameObject authPanel;
        [SerializeField] private GameObject profileSelectionPanel;
        [SerializeField] private GameObject mainMenuButtonsPanel;

        [Header("Animation")]
        [SerializeField] private float fadeOutDuration = 0.5f;
        [SerializeField] private float panelTransitionDuration = 0.3f;

        [Header("Title Animation")]
        [SerializeField] private RectTransform titleRectTransform;
        [SerializeField] private float titleAnimationDuration = 0.5f;
        [SerializeField] private Vector2 titleMainMenuPosition = new Vector2(0, 500);
        [SerializeField] private Vector2 titleProfileSelectPosition = new Vector2(0, 954);

        private bool isWaitingForInput = true;
        private CanvasGroup pressButtonCanvasGroup;

        private void Awake()
        {
            Debug.Log("[MainMenuController] Awake");
            pressButtonCanvasGroup = pressAnyButtonText.gameObject.GetComponent<CanvasGroup>();
            if (pressButtonCanvasGroup == null)
            {
                pressButtonCanvasGroup = pressAnyButtonText.gameObject.AddComponent<CanvasGroup>();
            }
        }

        private void Start()
        {
            InitializeUI();
            SubscribeToEvents();
            Debug.Log("[MainMenuController] Start completed");
        }

        private void InitializeUI()
        {
            Debug.Log("[MainMenuController] Initializing UI");
            pressButtonCanvasGroup.alpha = 1f;
            isWaitingForInput = true;

            // Hide all panels initially
            if (authPanel != null)
            {
                authPanel.SetActive(false);
                Debug.Log("[MainMenuController] Auth panel hidden");
            }
            if (profileSelectionPanel != null)
            {
                profileSelectionPanel.SetActive(false);
                Debug.Log("[MainMenuController] Profile selection panel hidden");
            }
            if (mainMenuButtonsPanel != null)
            {
                mainMenuButtonsPanel.SetActive(false);
                Debug.Log("[MainMenuController] Main menu buttons panel hidden");
            }
        }

        private void SubscribeToEvents()
        {
            GameEvents.OnProfileLoadRequested.AddListener(HandleProfileLoadRequested);
            GameEvents.OnGameStateChanged.AddListener(HandleGameStateChanged);
            Debug.Log("[MainMenuController] Events subscribed");
        }

        private void Update()
        {
            if (isWaitingForInput && (Input.anyKeyDown || Input.GetMouseButtonDown(0)))
            {
                HandleMainMenuInput();
            }
        }

        private void HandleMainMenuInput()
        {
            Debug.Log("[MainMenuController] Main menu input detected");
            isWaitingForInput = false;
            StartCoroutine(TransitionToAuth());
        }

        private IEnumerator TransitionToAuth()
        {
            Debug.Log("[MainMenuController] Starting transition to auth");
            GameEvents.OnUIAnimationStarted.Invoke();

            float elapsedTime = 0f;
            while (elapsedTime < fadeOutDuration)
            {
                elapsedTime += Time.deltaTime;
                pressButtonCanvasGroup.alpha = Mathf.Lerp(1f, 0f, elapsedTime / fadeOutDuration);
                yield return null;
            }

            pressAnyButtonText.gameObject.SetActive(false);
            if (authPanel != null)
            {
                authPanel.SetActive(true);
                Debug.Log("[MainMenuController] Auth panel activated");
            }

            Debug.Log("[MainMenuController] Auth transition complete");
            GameEvents.OnUIAnimationCompleted.Invoke();
            GameEvents.OnAuthenticationRequested.Invoke();
        }

        private void HandleProfileLoadRequested()
        {
            Debug.Log("[MainMenuController] Profile load requested");
            StartCoroutine(TransitionToPanels(authPanel, profileSelectionPanel));
            StartCoroutine(AnimateTitlePosition(titleProfileSelectPosition));
        }

        private void HandleGameStateChanged(GameState newState)
        {
            Debug.Log($"[MainMenuController] Game state changed to: {newState}");
            switch (newState)
            {
                case GameState.MainMenu:
                    StartCoroutine(AnimateTitlePosition(titleMainMenuPosition));
                    StartCoroutine(TransitionToPanels(profileSelectionPanel, mainMenuButtonsPanel));
                    break;

                case GameState.ProfileSelection:
                    StartCoroutine(AnimateTitlePosition(titleProfileSelectPosition));
                    StartCoroutine(TransitionToPanels(mainMenuButtonsPanel, profileSelectionPanel));
                    break;

                case GameState.CharacterSelect:
                case GameState.EquipmentSelect:
                case GameState.LevelSelect:
                    HideAllPanels();
                    break;
            }
        }

        private IEnumerator AnimateTitlePosition(Vector2 targetPosition)
        {
            if (titleRectTransform == null) yield break;

            Debug.Log($"[MainMenuController] Starting title animation to position: {targetPosition}");
            Vector2 startPosition = titleRectTransform.anchoredPosition;
            float elapsedTime = 0f;

            while (elapsedTime < titleAnimationDuration)
            {
                elapsedTime += Time.deltaTime;
                float progress = elapsedTime / titleAnimationDuration;
                float smoothProgress = Mathf.SmoothStep(0, 1, progress);
                titleRectTransform.anchoredPosition = Vector2.Lerp(startPosition, targetPosition, smoothProgress);
                yield return null;
            }

            titleRectTransform.anchoredPosition = targetPosition;
            Debug.Log("[MainMenuController] Title animation completed");
        }
        //ASDF
        private IEnumerator TransitionToPanels(GameObject panelToHide, GameObject panelToShow)
        {
            Debug.Log($"[MainMenuController] Starting panel transition - Hide: {panelToHide?.name}, Show: {panelToShow?.name}");
            GameEvents.OnUIAnimationStarted.Invoke();

            if (panelToHide != null)
            {
                CanvasGroup hideCanvasGroup = panelToHide.GetComponent<CanvasGroup>();
                if (hideCanvasGroup == null)
                {
                    hideCanvasGroup = panelToHide.AddComponent<CanvasGroup>();
                    Debug.Log($"[MainMenuController] Added CanvasGroup to {panelToHide.name}");
                }

                float elapsedTime = 0f;
                while (elapsedTime < panelTransitionDuration)
                {
                    elapsedTime += Time.deltaTime;
                    hideCanvasGroup.alpha = Mathf.Lerp(1f, 0f, elapsedTime / panelTransitionDuration);
                    yield return null;
                }

                panelToHide.SetActive(false);
                Debug.Log($"[MainMenuController] Panel {panelToHide.name} hidden");
            }

            if (panelToShow != null)
            {
                CanvasGroup showCanvasGroup = panelToShow.GetComponent<CanvasGroup>();
                if (showCanvasGroup == null)
                {
                    showCanvasGroup = panelToShow.AddComponent<CanvasGroup>();
                    Debug.Log($"[MainMenuController] Added CanvasGroup to {panelToShow.name}");
                }

                showCanvasGroup.alpha = 0f;
                panelToShow.SetActive(true);

                // Important: Set these immediately when showing the panel
                showCanvasGroup.interactable = true;
                showCanvasGroup.blocksRaycasts = true;

                float elapsedTime = 0f;
                while (elapsedTime < panelTransitionDuration)
                {
                    elapsedTime += Time.deltaTime;
                    showCanvasGroup.alpha = Mathf.Lerp(0f, 1f, elapsedTime / panelTransitionDuration);
                    yield return null;
                }

                showCanvasGroup.alpha = 1f;
                Debug.Log($"[MainMenuController] Panel {panelToShow.name} shown and activated");
            }

            GameEvents.OnUIAnimationCompleted.Invoke();
            Debug.Log("[MainMenuController] Panel transition complete");
        }

        private void HideAllPanels()
        {
            Debug.Log("[MainMenuController] Hiding all panels");
            if (pressAnyButtonText != null) pressAnyButtonText.gameObject.SetActive(false);
            if (authPanel != null) authPanel.SetActive(false);
            if (profileSelectionPanel != null) profileSelectionPanel.SetActive(false);
            if (mainMenuButtonsPanel != null) mainMenuButtonsPanel.SetActive(false);
        }

        private void OnDestroy()
        {
            GameEvents.OnProfileLoadRequested.RemoveListener(HandleProfileLoadRequested);
            GameEvents.OnGameStateChanged.RemoveListener(HandleGameStateChanged);
            StopAllCoroutines();
            Debug.Log("[MainMenuController] Cleaned up and destroyed");
        }
    }
}
// --- END FILE ---

// File: UI/Screens/MainMenu/ProfileCardController.cs
// Size: 4146 characters
// ---
// File: Assets/Code/UI/Screens/MainMenu/ProfileCardController.cs
//
// Purpose: Controls the profile card UI, displays profile information, and handles user interactions such as selection and deletion.
// This controller focuses solely on UI handling and delegates profile actions to the ProfileSelectionController.
//
// Created: 2024-01-15
// Updated: 2024-01-15
//
// Dependencies:
// - TMPro for TextMeshProUGUI components
// - UnityEngine.UI for UI elements like Button
// - CyberPickle.Core.Services.Authentication.Data for ProfileData
// - System for event handling

using UnityEngine;
using UnityEngine.UI;
using TMPro;
using System;
using CyberPickle.Core.Services.Authentication.Data;

namespace CyberPickle.UI.Screens.MainMenu
{
    public class ProfileCardController : MonoBehaviour
    {
        // Header Section
        [Header("Header Section")]
        [SerializeField] private TextMeshProUGUI profileNameText;
        [SerializeField] private TextMeshProUGUI lastLoginText;

        // Stats Grid
        [Header("Stats Grid")]
        [SerializeField] private TextMeshProUGUI levelValueText;
        [SerializeField] private TextMeshProUGUI timeValueText;
        [SerializeField] private TextMeshProUGUI scoreValueText;

        // Buttons
        [Header("Buttons")]
        [SerializeField] private Button selectButton;
        [SerializeField] private Button deleteButton;

        // Events
        public event Action<ProfileData> OnProfileSelected;
        public event Action<ProfileData> OnProfileDeleted;

        // Private variables
        private ProfileData profileData;

        // Public property to expose profileData
        public ProfileData ProfileData => profileData;

        /// <summary>
        /// Initializes the profile card with profile data.
        /// </summary>
        /// <param name="profile">The profile data to display.</param>
        public void Initialize(ProfileData profile)
        {
            profileData = profile;

            // Set header information
            profileNameText.text = profile.DisplayName;
            lastLoginText.text = FormatLastLoginTime(profile.LastLoginTime);

            // Set stats
            levelValueText.text = profile.Level.ToString();
            timeValueText.text = FormatPlayTime(profile.TotalPlayTime);
            scoreValueText.text = profile.HighestScore.ToString();

            // Set up button listeners
            selectButton.onClick.AddListener(OnSelectButtonClicked);
            deleteButton.onClick.AddListener(OnDeleteButtonClicked);
        }

        private void OnSelectButtonClicked()
        {
            OnProfileSelected?.Invoke(profileData);
        }

        private void OnDeleteButtonClicked()
        {
            OnProfileDeleted?.Invoke(profileData);
        }

        private string FormatLastLoginTime(DateTime lastLoginTime)
        {
            TimeSpan timeSinceLastLogin = DateTime.Now - lastLoginTime;
            if (timeSinceLastLogin.TotalDays >= 1)
                return $"{(int)timeSinceLastLogin.TotalDays} days ago";
            else if (timeSinceLastLogin.TotalHours >= 1)
                return $"{(int)timeSinceLastLogin.TotalHours} hours ago";
            else if (timeSinceLastLogin.TotalMinutes >= 1)
                return $"{(int)timeSinceLastLogin.TotalMinutes} minutes ago";
            else
                return "Just now";
        }

        private string FormatPlayTime(float playTimeInSeconds)
        {
            TimeSpan time = TimeSpan.FromSeconds(playTimeInSeconds);
            if (time.TotalHours >= 1)
                return $"{(int)time.TotalHours}h {time.Minutes}m";
            else if (time.Minutes >= 1)
                return $"{time.Minutes}m {time.Seconds}s";
            else
                return $"{time.Seconds}s";
        }

        private void OnDestroy()
        {
            selectButton.onClick.RemoveListener(OnSelectButtonClicked);
            deleteButton.onClick.RemoveListener(OnDeleteButtonClicked);
        }
    }
}


// --- END FILE ---

// File: UI/Screens/MainMenu/ProfileSelectionController.cs
// Size: 23662 characters
// ---
// File: Assets/Code/UI/Screens/MainMenu/ProfileSelectionController.cs
//
// Purpose: Handles the profile selection interface and transitions to main menu.
// Manages profile card creation, selection, and animation.
//
// Created: 2024-01-13
// Updated: 2024-01-15
//
// Dependencies:
// - CyberPickle.Core.Services.Authentication for authentication management
// - CyberPickle.Core.Services.Authentication for profile management
// - CyberPickle.Core.Events for game-wide event system

using UnityEngine;
using TMPro;
using UnityEngine.UI;
using System.Collections;
using System.Linq;
using System.Threading.Tasks;
using System.Collections.Generic;
using CyberPickle.Core.Services.Authentication;
using CyberPickle.Core.Services.Authentication.Data;
using CyberPickle.Core.Services.Authentication.Flow;
using CyberPickle.Core.Services.Authentication.Flow.Commands;
using CyberPickle.Core.Events;
using CyberPickle.Core.States;
using System;
using CyberPickle.UI.Components.ProfileCard;
using CyberPickle.Core.GameFlow.States.ProfileCard;

namespace CyberPickle.UI.Screens.MainMenu
{
    public class ProfileSelectionController : MonoBehaviour
    {
        [Header("Panel References")]
        [SerializeField] private GameObject profileSelectionPanel;
        [SerializeField] private Transform profilesContainer;
        [SerializeField] private GameObject profileCardPrefab;
        [SerializeField] private GameObject createProfileCardPrefab;

        [Header("Header Elements")]
        [SerializeField] private TextMeshProUGUI playerIdText;
        [SerializeField] private TextMeshProUGUI statusText;
        [SerializeField] private TextMeshProUGUI titleText;

        [Header("UI Elements")]
        [SerializeField] private Button backButton;
        [SerializeField] private CanvasGroup mainMenuButtonsGroup;
        [SerializeField] private CanvasGroup deleteConfirmationDialog;

        [Header("Animation Settings")]
        [SerializeField] private float transitionDuration = 0.5f;
        [SerializeField] private Vector3 cornerPosition = new Vector3(800f, 400f, 0f);
        [SerializeField] private Vector3 cornerScale = new Vector3(0.7f, 0.7f, 0.7f);
        [SerializeField] private float statusMessageDuration = 3f;

        [Header("Canvas References")]
        [SerializeField] private Canvas mainCanvas;
        

        private AuthenticationManager authManager;
        private ProfileManager profileManager;
        private ProfileCardManager profileCardManager;
        private AuthenticationFlowManager flowManager;
        private List<GameObject> instantiatedCards = new List<GameObject>();
        private CreateProfileCardController createProfileCard;
        private bool isTransitioning;
        private Coroutine statusMessageCoroutine;
        

        #region Initialization

        private void Awake()
        {
            if (deleteConfirmationDialog != null)
            {
                deleteConfirmationDialog.alpha = 0f;
                deleteConfirmationDialog.interactable = false;
                deleteConfirmationDialog.blocksRaycasts = false;
            }
            Debug.Log("[ProfileSelection] Awake called");
            InitializeManagers();
            ValidateReferences();
        }

        private void Start()
        {
            Debug.Log("[ProfileSelection] Start called");
            if (!ValidateManagers()) return;

            InitializeUI();
            SubscribeToEvents();
        }

        private void InitializeManagers()
        {
            authManager = AuthenticationManager.Instance;
            profileManager = ProfileManager.Instance;
            flowManager = AuthenticationFlowManager.Instance;
            profileCardManager = ProfileCardManager.Instance;
        }

        private bool ValidateManagers()
        {
            if (authManager == null || profileManager == null || flowManager == null || profileCardManager == null)
            {
                Debug.LogError("[ProfileSelection] Required managers are null!");
                return false;
            }
            return true;
        }

        private void ValidateReferences()
        {
            if (profilesContainer == null)
                Debug.LogError("[ProfileSelection] profilesContainer is null!");
            if (profileCardPrefab == null)
                Debug.LogError("[ProfileSelection] profileCardPrefab is null!");
            if (createProfileCardPrefab == null)
                Debug.LogError("[ProfileSelection] createProfileCardPrefab is null!");
        }

        private void InitializeUI()
        {
            if (!ValidateManagers()) return;

            Debug.Log("[ProfileSelection] Initializing UI");

            // Only handle the profile-specific UI elements
            mainMenuButtonsGroup.alpha = 0f;
            mainMenuButtonsGroup.interactable = false;

            UpdateHeaderInfo();
            backButton.onClick.AddListener(HandleBackButton);

            // Initialize cards container
            InitializeCreateProfileCard();
        }

        private void InitializeCreateProfileCard()
        {
            GameObject createCardObject = Instantiate(createProfileCardPrefab, profilesContainer);
            createProfileCard = createCardObject.GetComponent<CreateProfileCardController>();
        }

        #endregion

        #region Event Handling

        private void SubscribeToEvents()
        {
            Debug.Log("[ProfileSelectionController] Subscribing to events");

            if (authManager != null)
            {
                Debug.Log("[ProfileSelectionController] Subscribing to AuthManager events");
                authManager.SubscribeToAuthenticationStateChanged(HandleAuthStateChanged);
                authManager.SubscribeToAuthenticationCompleted(HandleAuthenticationCompleted);
            }

            if (profileManager != null)
            {
                Debug.Log("[ProfileSelectionController] Subscribing to ProfileManager events");
                profileManager.SubscribeToNewProfileCreated(HandleProfileCreated);
                profileManager.SubscribeToProfileSwitched(HandleProfileSwitched);
            }

            GameEvents.OnProfileLoadRequested.AddListener(HandleProfileLoadRequested);
            GameEvents.OnProfileNavigationInput.AddListener(HandleProfileNavigation);
        }

        private void UnsubscribeFromEvents()
        {
            if (profileManager != null)
            {
                profileManager.UnsubscribeFromNewProfileCreated(HandleProfileCreated);
                profileManager.UnsubscribeFromProfileSwitched(HandleProfileSwitched);
            }

            if (authManager != null)
            {
                authManager.UnsubscribeFromAuthenticationStateChanged(HandleAuthStateChanged);
                authManager.UnsubscribeFromAuthenticationCompleted(HandleAuthenticationCompleted);
            }

            GameEvents.OnProfileLoadRequested.RemoveListener(HandleProfileLoadRequested);
            GameEvents.OnProfileNavigationInput.RemoveListener(HandleProfileNavigation);
        }

        private void HandleAuthStateChanged(AuthenticationState state)
        {
            Debug.Log($"[ProfileSelectionController] Auth state changed to: {state}");

            if (state == AuthenticationState.Authenticated)
            {
                Debug.Log("[ProfileSelectionController] Authentication completed, waiting for UI readiness");
                GameEvents.OnUIAnimationCompleted.AddListener(OnPanelTransitionComplete);
            }
        }

        private void OnPanelTransitionComplete()
        {
            GameEvents.OnUIAnimationCompleted.RemoveListener(OnPanelTransitionComplete);

            // Only load profiles if our container is active
            if (profilesContainer != null && profilesContainer.gameObject.activeInHierarchy)
            {
                Debug.Log("[ProfileSelection] Panel transition complete, loading profiles");
                LoadProfiles();
            }
        }
       


        private IEnumerator ExecuteCommandCoroutine(IAuthCommand command)
        {
            Task commandTask = flowManager.ExecuteCommand(command);

            while (!commandTask.IsCompleted)
            {
                yield return null;
            }

            if (commandTask.IsFaulted)
            {
                Debug.LogError($"[ProfileSelection] Failed to load profiles: {commandTask.Exception?.InnerException?.Message}");
                ShowTemporaryStatus("Failed to load profiles", true);
                yield break;
            }

            // After profiles are loaded successfully, update UI
            UpdateUIState();
        }
        private void HandleAuthenticationCompleted(string playerId)
        {
            Debug.Log($"[ProfileSelection] Authentication completed for player: {playerId}");
            // Remove this LoadProfiles() call since HandleAuthStateChanged will handle it
        }

        private void HandleProfileCreated(string profileId)
        {
            if (!gameObject.activeInHierarchy) return;

            Debug.Log($"[ProfileSelection] HandleProfileCreated called for profile: {profileId}");

            // Get the new profile and set it as active
            var profiles = profileManager.GetAllProfiles();
            var newProfile = profiles.FirstOrDefault(p => p.ProfileId == profileId);
            if (newProfile != null)
            {
                profileCardManager.SetProfile(newProfile);
                profileCardManager.TransitionToState(ProfileCardState.Minimized);
            }

            // Transition to main menu
            GameEvents.OnGameStateChanged.Invoke(GameState.MainMenu);
        }
        private void HandleProfileLoadRequested()
        {
            Debug.Log("[ProfileSelection] Profile load requested, reloading state");
            ReloadProfileSelectionState();
        }
        private void HandleProfileSwitched(string profileId)
        {
            if (isTransitioning) return;
            UpdateUIState();
        }

        #endregion

        #region Profile Management
        private void ReloadProfileSelectionState()
        {
            Debug.Log("[ProfileSelectionController] Reloading profile selection state");

            // Clear existing cards
            ClearExistingProfiles();

            // Reset create profile card
            if (createProfileCard != null)
            {
                createProfileCard.ResetCard();
            }

            // Force reload all profiles from ProfileManager
            var allProfiles = profileManager.GetAllProfiles();
            Debug.Log($"[ProfileSelectionController] Found {allProfiles.Count} profiles to load");

            foreach (var profile in allProfiles)
            {
                CreateProfileCard(profile);
            }
        }

        private void LoadProfiles()
        {
            if (isTransitioning)
            {
                Debug.LogWarning("[ProfileSelectionController] Cannot load profiles - transitioning");
                return;
            }

            Debug.Log("[ProfileSelectionController] Starting LoadProfiles");
            ClearExistingProfiles();

            var profiles = profileManager.GetAllProfiles();
            if (profiles == null)
            {
                Debug.LogError("[ProfileSelectionController] GetAllProfiles returned null!");
                return;
            }

            Debug.Log($"[ProfileSelectionController] Found {profiles.Count} profiles");

            var sortedProfiles = profiles
                .OrderBy(p => p.ProfileId == "default" ? 0 : 1)
                .ThenBy(p => p.CreatedAt)
                .ToList();

            foreach (var profile in sortedProfiles)
            {
                CreateProfileCard(profile);
            }
        }



        private async void HandleProfileSelection(ProfileData profile)
        {
            if (isTransitioning) return;

            try
            {
                isTransitioning = true;
                var command = new SelectProfileCommand(profileManager, profile.ProfileId);
                await flowManager.ExecuteCommand(command);
                profileCardManager.SetProfile(profile);
                profileCardManager.TransitionToState(ProfileCardState.Minimized);

                // Let's let the MainMenuController handle the state change
                GameEvents.OnGameStateChanged.Invoke(GameState.MainMenu);
            }
            catch (Exception ex)
            {
                Debug.LogError($"[ProfileSelection] Error selecting profile: {ex.Message}");
                ShowTemporaryStatus("Failed to select profile", true);
            }
            finally
            {
                isTransitioning = false;
            }
        }

        private async void HandleProfileDeletion(ProfileData profile)
        {
            if (profile == null) return;

            // Show confirmation dialog first
            var confirmed = await ShowDeleteConfirmationDialog(profile.DisplayName);
            if (!confirmed) return;

            try
            {
                // Execute the delete command
                var command = new DeleteProfileCommand(profileManager, profile.ProfileId);
                await flowManager.ExecuteCommand(command);

                // Just refresh the profiles list
                LoadProfiles();
                ShowTemporaryStatus("Profile deleted successfully");
            }
            catch (Exception ex)
            {
                Debug.LogError($"[ProfileSelection] Error deleting profile: {ex.Message}");
                ShowTemporaryStatus("Failed to delete profile", true);
            }
        }

        private async Task<bool> ShowDeleteConfirmationDialog(string profileName)
        {
            // Create a TaskCompletionSource to handle the async dialog result
            var tcs = new TaskCompletionSource<bool>();

            // Find the dialog in your scene
            var dialogPanel = GameObject.Find("DeleteConfirmationDialog")?.GetComponent<CanvasGroup>();
            if (dialogPanel == null)
            {
                Debug.LogError("[ProfileSelection] DeleteConfirmationDialog not found in scene!");
                return false;
            }

            // Get button references from the dialog panel
            var confirmButton = dialogPanel.GetComponentInChildren<Button>(true);
            var cancelButton = dialogPanel.GetComponentsInChildren<Button>(true)[1];
            var messageText = dialogPanel.GetComponentInChildren<TextMeshProUGUI>(true);

            // Show dialog
            dialogPanel.alpha = 1f;
            dialogPanel.interactable = true;
            dialogPanel.blocksRaycasts = true;

            // Set message
            messageText.text = $"Are you sure you want to delete profile {profileName}?";

            // Setup button listeners
            void OnConfirm()
            {
                tcs.SetResult(true);
                CleanupDialog();
            }

            void OnCancel()
            {
                tcs.SetResult(false);
                CleanupDialog();
            }

            void CleanupDialog()
            {
                // Remove listeners
                confirmButton.onClick.RemoveListener(OnConfirm);
                cancelButton.onClick.RemoveListener(OnCancel);

                // Hide dialog
                dialogPanel.alpha = 0f;
                dialogPanel.interactable = false;
                dialogPanel.blocksRaycasts = false;
            }

            // Add listeners
            confirmButton.onClick.AddListener(OnConfirm);
            cancelButton.onClick.AddListener(OnCancel);

            // Return the task
            return await tcs.Task;
        }
        private void ClearExistingProfiles()
        {
            foreach (var card in instantiatedCards.Where(card => card != null))
            {
                var cardController = card.GetComponent<ProfileCardController>();
                if (cardController != null)
                {
                    cardController.OnProfileSelected -= HandleProfileSelection;
                    cardController.OnProfileDeleted -= HandleProfileDeletion;
                }
                Destroy(card);
            }

            instantiatedCards.Clear();
            Debug.Log("[ProfileSelection] Cleared existing profile cards");
        }

        #endregion

        #region Profile Card Management

        private void CreateProfileCard(ProfileData profile)
        {
            if (profile == null || !gameObject.activeInHierarchy) return;

            Debug.Log($"[ProfileSelection] Creating profile card for {profile.DisplayName}");

            GameObject cardObject = Instantiate(profileCardPrefab, profilesContainer);
            if (cardObject == null)
            {
                Debug.LogError("[ProfileSelection] Failed to instantiate profile card prefab");
                return;
            }

            cardObject.name = $"ProfileCard_{profile.DisplayName}";

            var cardController = cardObject.GetComponent<ProfileCardController>();
            if (cardController != null)
            {
                cardController.Initialize(profile);
                cardController.OnProfileSelected += HandleProfileSelection;
                cardController.OnProfileDeleted += HandleProfileDeletion;
            }
            else
            {
                Debug.LogError("[ProfileSelection] ProfileCardController component not found on prefab");
            }

            instantiatedCards.Add(cardObject);
        }

        #endregion

        #region UI Updates

        private void UpdateHeaderInfo()
        {
            if (playerIdText != null)
                playerIdText.text = $"ID: #{authManager.CurrentPlayerId}";

            if (statusText != null)
                statusText.text = authManager.IsSignedIn ? "SYSTEM STATUS: ONLINE" : "SYSTEM STATUS: OFFLINE";
        }

        private void UpdateUIState()
        {
            if (isTransitioning) return;

            UpdateHeaderInfo();

            if (createProfileCard != null)
                createProfileCard.gameObject.SetActive(authManager.IsSignedIn);
        }

        private void ShowTemporaryStatus(string message, bool isError = false)
        {
            if (statusMessageCoroutine != null)
                StopCoroutine(statusMessageCoroutine);

            statusMessageCoroutine = StartCoroutine(ShowStatusMessageRoutine(message, isError));
        }

        private IEnumerator ShowStatusMessageRoutine(string message, bool isError)
        {
            if (statusText != null)
            {
                statusText.text = message;
                statusText.color = isError ? Color.red : Color.white;
            }

            yield return new WaitForSeconds(statusMessageDuration);

            if (statusText != null)
            {
                statusText.text = authManager.IsSignedIn ? "SYSTEM STATUS: ONLINE" : "SYSTEM STATUS: OFFLINE";
                statusText.color = Color.white;
            }
        }

        private void HandleBackButton()
        {
            if (isTransitioning) return;

            // If there's an active profile, ensure the card is hidden
            if (profileCardManager.CurrentState != ProfileCardState.Hidden)
            {
                profileCardManager.TransitionToState(ProfileCardState.Hidden);
                Debug.Log($"[ProfileCardManagerHandlebackbutton] Card hidden");
            }

            GameEvents.OnProfileLoadRequested.Invoke();
        }

        private void HandleProfileNavigation(float direction)
        {
            if (instantiatedCards.Count == 0) return;

            int currentIndex = -1;

            // Find currently selected card or first card if none selected
            for (int i = 0; i < instantiatedCards.Count; i++)
            {
                var cardController = instantiatedCards[i].GetComponent<ProfileCardController>();
                if (cardController?.ProfileData == profileManager.ActiveProfile)
                {
                    currentIndex = i;
                    break;
                }
            }

            if (currentIndex == -1)
                currentIndex = 0;

            // Calculate new index
            int newIndex = currentIndex;
            if (direction > 0) // Down arrow
            {
                newIndex = Mathf.Min(instantiatedCards.Count - 1, currentIndex + 1);
            }
            else if (direction < 0) // Up arrow
            {
                newIndex = Mathf.Max(0, currentIndex - 1);
            }

            if (newIndex != currentIndex)
            {
                var cardController = instantiatedCards[newIndex].GetComponent<ProfileCardController>();
                if (cardController != null)
                {
                    // Scroll to the selected card
                    ScrollToCard(instantiatedCards[newIndex]);
                }
            }
        }
        private void ScrollToCard(GameObject cardObject)
        {
            if (cardObject == null) return;

            // Get the ScrollRect component
            var scrollRect = profilesContainer.GetComponentInParent<ScrollRect>();
            if (scrollRect == null) return;

            // Get the card's RectTransform
            var cardRect = cardObject.GetComponent<RectTransform>();
            if (cardRect == null) return;

            // Calculate the card's position in the scroll view
            var contentPanel = scrollRect.content;
            var viewportHeight = scrollRect.viewport.rect.height;
            var contentHeight = contentPanel.rect.height;

            // Convert the card's position to normalized coordinates (0-1)
            var cardPosition = contentPanel.InverseTransformPoint(cardRect.position);
            var normalizedPosition = (cardPosition.y + contentHeight / 2) / contentHeight;

            // Adjust scroll position to show the card
            scrollRect.verticalNormalizedPosition = 1 - normalizedPosition;
        }
        #endregion


        #region Cleanup

        private void OnDestroy()
        {
            if (statusMessageCoroutine != null)
                StopCoroutine(statusMessageCoroutine);

            UnsubscribeFromEvents();
            backButton.onClick.RemoveListener(HandleBackButton);

            foreach (var card in instantiatedCards)
            {
                if (card != null)
                {
                    var cardController = card.GetComponent<ProfileCardController>();
                    if (cardController != null)
                    {
                        cardController.OnProfileSelected -= HandleProfileSelection;
                        cardController.OnProfileDeleted -= HandleProfileDeletion;
                    }
                }
            }
        }

        #endregion
    }
}


// --- END FILE ---

// File: UI/Windows/Auth/AuthPanelController.cs
// Size: 7962 characters
// ---
// File: Assets/Code/UI/Windows/Auth/AuthPanelController.cs
// Namespace: CyberPickle.UI.Windows.Auth
//
// Purpose: Controls the authentication panel UI and process.
// Responds to authentication events and manages the terminal display.
//
// Created: 2024-01-13
// Updated: 2024-01-14

using UnityEngine;
using TMPro;
using UnityEngine.UI;
using CyberPickle.Core.Services.Authentication;
using CyberPickle.Core.Events;
using System.Collections;

namespace CyberPickle.UI.Windows.Auth
{
    public class AuthPanelController : MonoBehaviour
    {
        [Header("Panel References")]
        [SerializeField] private GameObject terminalWindowPanel;
        [SerializeField] private TextMeshProUGUI debugConsole;
        [SerializeField] private TextMeshProUGUI resultText;
        [SerializeField] private TextMeshProUGUI statusText;

        [Header("Loading Indicator")]
        [SerializeField] private Slider loadingSlider;
        [SerializeField] private float loadingAnimationSpeed = 1f;

        [Header("Animation Settings")]
        [SerializeField] private float typewriterSpeed = 0.05f;
        [SerializeField] private float messageDisplayDuration = 2f;
        [SerializeField] private float panelFadeInDuration = 0.5f;

        private AuthenticationManager authManager;
        private ProfileManager profileManager;
        private bool isInitialized;
        private Coroutine currentTypewriterCoroutine;
        private Coroutine loadingCoroutine;
        private CanvasGroup panelCanvasGroup;

        private void Awake()
        {
            authManager = AuthenticationManager.Instance;
            profileManager = ProfileManager.Instance;
            SetupCanvasGroup();
        }

        private void OnEnable()
        {
            SubscribeToEvents();
        }

        private void OnDisable()
        {
            UnsubscribeFromEvents();
        }

        private void SetupCanvasGroup()
        {
            panelCanvasGroup = GetComponent<CanvasGroup>();
            if (panelCanvasGroup == null)
            {
                panelCanvasGroup = gameObject.AddComponent<CanvasGroup>();
            }
            panelCanvasGroup.alpha = 0f;
        }

        private void SubscribeToEvents()
        {
            GameEvents.OnAuthenticationRequested.AddListener(InitializeAuthentication);

            if (authManager != null)
            {
                authManager.SubscribeToAuthenticationCompleted(OnAuthenticationCompleted);
                authManager.SubscribeToAuthenticationFailed(OnAuthenticationFailed);
            }

            if (profileManager != null)
            {
                profileManager.SubscribeToProfileSwitched(OnProfileSwitched);
            }
        }

        private void UnsubscribeFromEvents()
        {
            GameEvents.OnAuthenticationRequested.RemoveListener(InitializeAuthentication);

            if (authManager != null)
            {
                authManager.UnsubscribeFromAuthenticationCompleted(OnAuthenticationCompleted);
                authManager.UnsubscribeFromAuthenticationFailed(OnAuthenticationFailed);
            }

            if (profileManager != null)
            {
                profileManager.UnsubscribeFromProfileSwitched(OnProfileSwitched);
            }
        }

        public void InitializeAuthentication()
        {
            if (!isInitialized)
            {
                StartCoroutine(InitializationSequence());
                isInitialized = true;
            }
        }

        private IEnumerator InitializationSequence()
        {
            // Reset state
            isInitialized = false;
            ClearConsole();
            loadingSlider.value = 0f;

            // Fade in the panel
            yield return StartCoroutine(FadeInPanel());

            // Initial boot sequence
            yield return StartCoroutine(TypewriterEffect(debugConsole, "> Initializing terminal..."));
            yield return new WaitForSeconds(messageDisplayDuration);

            yield return StartCoroutine(TypewriterEffect(debugConsole, "> Checking authentication service..."));

            // Start loading animation
            if (loadingCoroutine != null) StopCoroutine(loadingCoroutine);
            loadingCoroutine = StartCoroutine(AnimateLoading());

            // Begin authentication
            StartAuthentication();
        }

        private IEnumerator FadeInPanel()
        {
            float elapsedTime = 0f;
            while (elapsedTime < panelFadeInDuration)
            {
                elapsedTime += Time.deltaTime;
                panelCanvasGroup.alpha = Mathf.Lerp(0f, 1f, elapsedTime / panelFadeInDuration);
                yield return null;
            }
            panelCanvasGroup.alpha = 1f;
        }

        private void StartAuthentication()
        {
            UpdateStatus("Authenticating...");
            _ = authManager.SignInAnonymouslyAsync();
        }

        private IEnumerator AnimateLoading()
        {
            while (true)
            {
                loadingSlider.value = Mathf.PingPong(Time.time * loadingAnimationSpeed, 1f);
                yield return null;
            }
        }

        private IEnumerator TypewriterEffect(TextMeshProUGUI textComponent, string message)
        {
            if (currentTypewriterCoroutine != null)
            {
                StopCoroutine(currentTypewriterCoroutine);
            }

            // Store the existing text
            string existingText = textComponent.text;

            // Add a new line if there's existing text
            if (!string.IsNullOrEmpty(existingText) && !existingText.EndsWith("\n"))
            {
                existingText += "\n";
            }

            // Build the new line character by character
            string currentMessage = "";
            foreach (char c in message)
            {
                currentMessage += c;
                textComponent.text = existingText + currentMessage;
                yield return new WaitForSeconds(typewriterSpeed);
            }

            // Add a new line at the end for the next message
            textComponent.text += "\n";
        }

        #region Event Handlers

        private void OnAuthenticationCompleted(string playerId)
        {
            if (loadingCoroutine != null) StopCoroutine(loadingCoroutine);
            loadingSlider.value = 1f;

            StartCoroutine(TypewriterEffect(debugConsole, $"> Authentication successful. PlayerID: {playerId}"));
            UpdateStatus("Authentication Complete");

            // Trigger profile selection panel or next step
            GameEvents.OnProfileLoadRequested.Invoke();
        }

        private void OnAuthenticationFailed(string error)
        {
            if (loadingCoroutine != null) StopCoroutine(loadingCoroutine);
            loadingSlider.value = 0f;

            StartCoroutine(TypewriterEffect(debugConsole, $"> Authentication failed: {error}"));
            UpdateStatus("Authentication Failed");
        }

        private void OnProfileSwitched(string profileId)
        {
            StartCoroutine(TypewriterEffect(debugConsole, $"> Profile switched to: {profileId}"));
        }

        #endregion

        private void UpdateStatus(string status)
        {
            if (statusText != null)
                statusText.text = $"> {status}";
        }

        private void ClearConsole()
        {
            if (debugConsole != null) debugConsole.text = "";
            if (statusText != null) statusText.text = "";
            if (resultText != null) resultText.text = "";
        }

        private void OnDestroy()
        {
            StopAllCoroutines();
        }
    }
}

// --- END FILE ---

// File: Core/GameFlow/States/ProfileCard/ProfileCardState.cs
// Size: 997 characters
// ---
// File: Assets/Code/Core/GameFlow/States/ProfileCard/ProfileCardState.cs
//
// Purpose: Defines the possible states of the profile card UI component
// Used to manage the card's visibility and interaction states across different game screens
//
// Created: 2024-02-11

namespace CyberPickle.Core.GameFlow.States.ProfileCard
{
    /// <summary>
    /// Represents the different states of the profile card UI component
    /// </summary>
    public enum ProfileCardState
    {
        /// <summary>
        /// Card is not visible
        /// </summary>
        Hidden,

        /// <summary>
        /// Card is visible in minimized form (corner display)
        /// </summary>
        Minimized,

        /// <summary>
        /// Card is visible in expanded form showing full details
        /// </summary>
        Expanded,

        /// <summary>
        /// Card is currently transitioning between states
        /// </summary>
        Transitioning
    }
}

// --- END FILE ---

// File: Core/Services/Authentication/Data/AuthenticationEvents.cs
// Size: 1198 characters
// ---
using System;

namespace CyberPickle.Core.Services.Authentication
{
    public class AuthenticationEvents
    {
        // Authentication state events
        public event Action<AuthenticationState> OnAuthenticationStateChanged;
        public event Action<string> OnAuthenticationCompleted;
        public event Action<string> OnAuthenticationFailed;

        // Session events
        public event Action<string> OnSessionTokenFound;
        public event Action OnSessionExpired;
        public event Action OnSignedOut;

        // Internal methods to invoke events
        internal void InvokeAuthenticationStateChanged(AuthenticationState state) => OnAuthenticationStateChanged?.Invoke(state);
        internal void InvokeAuthenticationCompleted(string playerId) => OnAuthenticationCompleted?.Invoke(playerId);
        internal void InvokeAuthenticationFailed(string error) => OnAuthenticationFailed?.Invoke(error);
        internal void InvokeSessionTokenFound(string token) => OnSessionTokenFound?.Invoke(token);
        internal void InvokeSessionExpired() => OnSessionExpired?.Invoke();
        internal void InvokeSignedOut() => OnSignedOut?.Invoke();
    }
}


// --- END FILE ---

// File: Core/Services/Authentication/Data/AuthenticationState.cs
// Size: 331 characters
// ---
using UnityEngine;

namespace CyberPickle.Core.Services.Authentication
{
    public enum AuthenticationState
    {
        NotInitialized,
        NotAuthenticated,
        AuthenticationInProgress,
        Authenticated,
        AuthenticationFailed,
        ProfileSwitchInProgress,
        SessionExpired
    }
}

// --- END FILE ---

// File: Core/Services/Authentication/Data/ProfileContainer.cs
// Size: 8664 characters
// ---
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using UnityEngine;

namespace CyberPickle.Core.Services.Authentication.Data
{
    /// <summary>
    /// Container class for managing player profiles with Json.NET serialization support.
    /// Handles profile storage, retrieval, and persistence.
    /// </summary>
    [Serializable]
    public class ProfileContainer
    {
        [JsonProperty("Profiles")]
        private List<ProfileData> profiles = new List<ProfileData>();

        private static string profilesFilePath;

        /// <summary>
        /// Lazy-initialized file path for profile storage
        /// </summary>
        private static string ProfilesFilePath
        {
            get
            {
                if (string.IsNullOrEmpty(profilesFilePath))
                {
                    profilesFilePath = Path.Combine(Application.persistentDataPath, "profiles.json");
                }
                return profilesFilePath;
            }
        }

        /// <summary>
        /// Read-only access to all profiles
        /// </summary>
        [JsonIgnore]
        public IReadOnlyList<ProfileData> Profiles => profiles.AsReadOnly();

        /// <summary>
        /// Currently active profile
        /// </summary>
        [JsonIgnore]
        public ProfileData ActiveProfile => profiles.FirstOrDefault(p => p.IsActive);

        /// <summary>
        /// Adds a new profile if it doesn't exist
        /// </summary>
        public void AddProfile(ProfileData profile)
        {
            if (!profiles.Any(p => p.ProfileId == profile.ProfileId))
            {
                Debug.Log($"[ProfileContainer] Adding new profile: {profile.ProfileId}");
                profiles.Add(profile);
                SaveProfiles();
            }
        }

        /// <summary>
        /// Retrieves a profile by ID
        /// </summary>
        public ProfileData GetProfile(string profileId)
        {
            return profiles.FirstOrDefault(p => p.ProfileId == profileId);
        }

        /// <summary>
        /// Sets the active profile and deactivates all others
        /// </summary>
        public void SetActiveProfile(string profileId)
        {
            Debug.Log($"[ProfileContainer] Setting active profile to {profileId}. Before change - Active profile: {ActiveProfile?.ProfileId}");

            foreach (var profile in profiles)
            {
                bool shouldBeActive = profile.ProfileId == profileId;
                profile.SetActive(shouldBeActive);
                Debug.Log($"[ProfileContainer] Profile {profile.ProfileId} - Setting active to: {shouldBeActive}");
            }

            SaveProfiles();

            // Verify the change
            var activeProfile = ActiveProfile;
            if (activeProfile != null)
            {
                Debug.Log($"[ProfileContainer] Active profile is now: {activeProfile.ProfileId}");
            }
            else
            {
                Debug.LogError("[ProfileContainer] No active profile found after setting active profile.");
            }
        }

        /// <summary>
        /// Updates an existing profile
        /// </summary>
        public void UpdateProfile(ProfileData updatedProfile)
        {
            var index = profiles.FindIndex(p => p.ProfileId == updatedProfile.ProfileId);
            if (index != -1)
            {
                Debug.Log($"[ProfileContainer] Updating profile: {updatedProfile.ProfileId}");
                profiles[index] = updatedProfile;
                SaveProfiles();
            }
        }

        /// <summary>
        /// Removes a profile by ID
        /// </summary>
        public void RemoveProfile(string profileId)
        {
            profiles.RemoveAll(p => p.ProfileId == profileId);
            SaveProfiles();
        }

        /// <summary>
        /// Saves all profiles to disk using Json.NET
        /// </summary>
        public void SaveProfiles()
        {
            try
            {
                var settings = new JsonSerializerSettings
                {
                    Formatting = Formatting.Indented,
                    ReferenceLoopHandling = ReferenceLoopHandling.Ignore,
                    NullValueHandling = NullValueHandling.Include,
                    ObjectCreationHandling = ObjectCreationHandling.Replace
                };

                var json = JsonConvert.SerializeObject(this, settings);
                File.WriteAllText(ProfilesFilePath, json);

                Debug.Log($"[ProfileContainer] Profiles saved successfully to {ProfilesFilePath}");
                Debug.Log($"[ProfileContainer] Saved {profiles.Count} profiles, Active profile: {ActiveProfile?.ProfileId}");
            }
            catch (Exception e)
            {
                Debug.LogError($"[ProfileContainer] Failed to save profiles: {e.Message}\nStack trace: {e.StackTrace}");
            }
        }

        /// <summary>
        /// Loads profiles from disk using Json.NET
        /// </summary>
        public static ProfileContainer Load()
        {
            try
            {
                Debug.Log($"[ProfileContainer] Attempting to load from: {ProfilesFilePath}");

                if (!File.Exists(ProfilesFilePath))
                {
                    Debug.Log($"[ProfileContainer] No profile file found at: {ProfilesFilePath}");
                    return new ProfileContainer();
                }

                var json = File.ReadAllText(ProfilesFilePath);
                Debug.Log($"[ProfileContainer] Loaded JSON content: {json}");

                var settings = new JsonSerializerSettings
                {
                    ObjectCreationHandling = ObjectCreationHandling.Replace,
                    NullValueHandling = NullValueHandling.Ignore,
                    DefaultValueHandling = DefaultValueHandling.Populate
                };

                var container = JsonConvert.DeserializeObject<ProfileContainer>(json, settings);

                if (container == null)
                {
                    Debug.LogError("[ProfileContainer] Deserialization returned null container");
                    return new ProfileContainer();
                }

                Debug.Log($"[ProfileContainer] Successfully loaded {container.profiles.Count} profiles");
                foreach (var profile in container.profiles)
                {
                    // Initialize collections if they're null
                    profile.InitializeCollectionsIfNeeded();
                    Debug.Log($"[ProfileContainer] Loaded profile: {profile.ProfileId}, Active: {profile.IsActive}");
                }

                return container;
            }
            catch (Exception e)
            {
                Debug.LogError($"[ProfileContainer] Error loading profiles: {e.Message}\nStack trace: {e.StackTrace}");
                return new ProfileContainer();
            }
        }

        /// <summary>
        /// Clears all profiles and deletes the save file
        /// </summary>
        public void ClearAll()
        {
            Debug.Log("[ProfileContainer] Clearing all profiles");
            profiles.Clear();
            if (File.Exists(ProfilesFilePath))
            {
                File.Delete(ProfilesFilePath);
            }
        }

        /// <summary>
        /// Verifies the integrity of the profile container and repairs if needed
        /// </summary>
        public void VerifyIntegrity()
        {
            Debug.Log("[ProfileContainer] Verifying profile container integrity");

            // Ensure no duplicate active profiles
            var activeProfiles = profiles.Count(p => p.IsActive);
            if (activeProfiles > 1)
            {
                Debug.LogWarning("[ProfileContainer] Found multiple active profiles, fixing...");
                var firstActive = profiles.First(p => p.IsActive);
                foreach (var profile in profiles.Where(p => p.IsActive && p.ProfileId != firstActive.ProfileId))
                {
                    profile.SetActive(false);
                }
            }

            // Initialize collections for all profiles
            foreach (var profile in profiles)
            {
                profile.InitializeCollectionsIfNeeded();
            }

            SaveProfiles();
        }
    }
}
// --- END FILE ---

// File: Core/Services/Authentication/Data/ProfileData.cs
// Size: 9466 characters
// ---
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using UnityEngine;

namespace CyberPickle.Core.Services.Authentication.Data
{
    [Serializable]
    public class CharacterProgressionData
    {
        [JsonProperty("characterId")]
        private string characterId;

        [JsonProperty("characterLevel")]
        private int characterLevel;

        [JsonProperty("experience")]
        private float experience;

        [JsonProperty("stats")]
        private Dictionary<string, float> stats;

        [JsonProperty("unlockedSkills")]
        private List<string> unlockedSkills;

        [JsonProperty("equippedWeaponId")]
        private string equippedWeaponId;

        [JsonProperty("equippedPowerupIds")]
        private List<string> equippedPowerupIds;

        // Public Properties
        [JsonIgnore] public string CharacterId => characterId;
        [JsonIgnore] public int CharacterLevel => characterLevel;
        [JsonIgnore] public float Experience => experience;
        [JsonIgnore] public IReadOnlyDictionary<string, float> Stats => stats;
        [JsonIgnore] public IReadOnlyList<string> UnlockedSkills => unlockedSkills;
        [JsonIgnore] public string EquippedWeaponId => equippedWeaponId;
        [JsonIgnore] public IReadOnlyList<string> EquippedPowerupIds => equippedPowerupIds;

        public CharacterProgressionData(string characterId)
        {
            this.characterId = characterId;
            InitializeCollections();
        }

        private void InitializeCollections()
        {
            characterLevel = 1;
            experience = 0f;
            stats = new Dictionary<string, float>();
            unlockedSkills = new List<string>();
            equippedPowerupIds = new List<string>();
        }
    }

    [Serializable]
    public class MiningNodeData
    {
        [JsonProperty("nodeId")]
        private string nodeId;

        [JsonProperty("level")]
        private int level;

        [JsonProperty("baseRate")]
        private float baseRate;

        [JsonProperty("multiplier")]
        private float multiplier;

        // Public Properties
        [JsonIgnore] public string NodeId => nodeId;
        [JsonIgnore] public int Level => level;
        [JsonIgnore] public float BaseRate => baseRate;
        [JsonIgnore] public float Multiplier => multiplier;

        public MiningNodeData(string nodeId)
        {
            this.nodeId = nodeId;
            this.level = 1;
            this.baseRate = 10f;
            this.multiplier = 1f;
        }
    }

    [Serializable]
    public class ProfileData
    {
        #region Private Fields

        [JsonProperty("ProfileId")]
        private string profileId;

        [JsonProperty("PlayerId")]
        private string playerId;

        [JsonProperty("DisplayName")]
        private string displayName;

        [JsonProperty("IsActive")]
        private bool isActive;

        [JsonProperty("CreatedAtTicks")]
        private long createdAtTicks;

        [JsonProperty("LastLoginAtTicks")]
        private long lastLoginAtTicks;

        [JsonProperty("TotalPlayTime")]
        private float totalPlayTime;

        [JsonProperty("HighestScore")]
        private int highestScore;

        [JsonProperty("FurthestDistance")]
        private float furthestDistance;

        [JsonProperty("Level")]
        private int level;

        [JsonProperty("HasSaveData")]
        private bool hasSaveData;

        [JsonProperty("CyberCoins")]
        private float cyberCoins;

        [JsonProperty("NeuralCredits")]
        private float neuralCredits;

        [JsonProperty("CharacterProgress")]
        private Dictionary<string, CharacterProgressionData> characterProgress;

        [JsonProperty("MiningNodes")]
        private Dictionary<string, MiningNodeData> miningNodes;

        [JsonProperty("UnlockedEquipment")]
        private HashSet<string> unlockedEquipment;

        [JsonProperty("Achievements")]
        private HashSet<string> achievements;

        [JsonProperty("GlobalMultipliers")]
        private Dictionary<string, float> globalMultipliers;

        #endregion

        #region Public Properties

        [JsonIgnore] public string ProfileId => profileId;
        [JsonIgnore] public string PlayerId => playerId;
        [JsonIgnore] public string DisplayName => displayName;
        [JsonIgnore] public bool HasSaveData => hasSaveData;
        [JsonIgnore] public float TotalPlayTime => totalPlayTime;
        [JsonIgnore] public int HighestScore => highestScore;
        [JsonIgnore] public float FurthestDistance => furthestDistance;
        [JsonIgnore] public int Level => level;
        [JsonIgnore] public bool IsActive => isActive;
        [JsonIgnore] public DateTime CreatedAt => new DateTime(createdAtTicks);
        [JsonIgnore] public DateTime LastLoginTime => new DateTime(lastLoginAtTicks);
        [JsonIgnore] public float CyberCoins => cyberCoins;
        [JsonIgnore] public float NeuralCredits => neuralCredits;

        [JsonIgnore] public IReadOnlyDictionary<string, CharacterProgressionData> CharacterProgress => characterProgress;
        [JsonIgnore] public IReadOnlyDictionary<string, MiningNodeData> MiningNodes => miningNodes;
        [JsonIgnore] public IReadOnlyCollection<string> UnlockedEquipment => unlockedEquipment;
        [JsonIgnore] public IReadOnlyCollection<string> Achievements => achievements;
        [JsonIgnore] public IReadOnlyDictionary<string, float> GlobalMultipliers => globalMultipliers;

        #endregion

        #region Constructor and Initialization

        public ProfileData(string profileId, string playerId, string displayName)
        {
            this.profileId = profileId;
            this.playerId = playerId;
            this.displayName = displayName;
            this.createdAtTicks = DateTime.UtcNow.Ticks;
            this.lastLoginAtTicks = DateTime.UtcNow.Ticks;

            InitializeCollectionsIfNeeded();
            SetDefaultValues();
        }

        /// <summary>
        /// Ensures all collections are properly initialized
        /// Called after deserialization to prevent null collections
        /// </summary>
        public void InitializeCollectionsIfNeeded()
        {
            Debug.Log($"[ProfileData] Initializing collections for profile: {profileId}");

            characterProgress ??= new Dictionary<string, CharacterProgressionData>();
            miningNodes ??= new Dictionary<string, MiningNodeData>();
            unlockedEquipment ??= new HashSet<string>();
            achievements ??= new HashSet<string>();
            globalMultipliers ??= new Dictionary<string, float>();
        }

        private void SetDefaultValues()
        {
            isActive = false;
            hasSaveData = false;
            totalPlayTime = 0f;
            highestScore = 0;
            furthestDistance = 0f;
            level = 1;
            cyberCoins = 0f;
            neuralCredits = 0f;
        }

        #endregion

        #region Public Methods

        public void UpdateLoginTime()
        {
            lastLoginAtTicks = DateTime.UtcNow.Ticks;
        }

        public void UpdateDisplayName(string name)
        {
            if (!string.IsNullOrEmpty(name))
            {
                displayName = name;
            }
        }

        public void UpdateProgress(float playTime, int score, float distance, int level)
        {
            totalPlayTime = playTime;
            if (score > highestScore) highestScore = score;
            if (distance > furthestDistance) furthestDistance = distance;
            this.level = level;
            hasSaveData = true;
        }

        public void UpdateCharacterProgress(string characterId, CharacterProgressionData progression)
        {
            InitializeCollectionsIfNeeded();
            characterProgress[characterId] = progression;
            Debug.Log($"[ProfileData] Updated character progress for {characterId} in profile {profileId}");
        }

        public void UpdateMiningNode(string nodeId, MiningNodeData nodeData)
        {
            InitializeCollectionsIfNeeded();
            miningNodes[nodeId] = nodeData;
        }

        public void UpdateCurrency(float cyberCoins, float neuralCredits)
        {
            this.cyberCoins = cyberCoins;
            this.neuralCredits = neuralCredits;
        }

        public void ClearProgress()
        {
            totalPlayTime = 0f;
            highestScore = 0;
            furthestDistance = 0f;
            level = 1;
            cyberCoins = 0f;
            neuralCredits = 0f;

            InitializeCollectionsIfNeeded();
            characterProgress.Clear();
            miningNodes.Clear();
            unlockedEquipment.Clear();
            achievements.Clear();
            globalMultipliers.Clear();

            hasSaveData = false;
            Debug.Log($"[ProfileData] Cleared progress for profile: {profileId}");
        }

        public void SetActive(bool active)
        {
            isActive = active;
            Debug.Log($"[ProfileData] Profile {profileId} active state set to: {active}");
        }

        #endregion
    }
}
// --- END FILE ---

// File: Core/Services/Authentication/Data/ProfileManagementEvents.cs
// Size: 843 characters
// ---
using System;

namespace CyberPickle.Core.Services.Authentication
{
    public class ProfileManagementEvents
    {
        // Profile events
        public event Action<string> OnProfileLoaded;
        public event Action<string> OnProfileSwitched;
        public event Action<string> OnNewProfileCreated;
        public event Action<string> OnProfileDeleted;

        // Internal methods to invoke events
        internal void InvokeProfileLoaded(string profileId) => OnProfileLoaded?.Invoke(profileId);
        internal void InvokeProfileSwitched(string profileId) => OnProfileSwitched?.Invoke(profileId);
        internal void InvokeNewProfileCreated(string profileId) => OnNewProfileCreated?.Invoke(profileId);
        internal void InvokeProfileDeleted(string profileId) => OnProfileDeleted?.Invoke(profileId);
    }
}

// --- END FILE ---

// File: Core/Services/Authentication/Flow/AuthenticationFlowManager.cs
// Size: 3288 characters
// ---
// File: Assets/_CyberPickle/Code/Core/Services/Authentication/Flow/AuthenticationFlowManager.cs
using UnityEngine;
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using CyberPickle.Core.Management;
using CyberPickle.Core.Events;
using CyberPickle.Core.Interfaces;
using CyberPickle.Core.Services.Authentication.Flow.States;
using CyberPickle.Core.Services.Authentication.Flow.Commands;



namespace CyberPickle.Core.Services.Authentication.Flow
{
    public class AuthenticationFlowManager : Manager<AuthenticationFlowManager>, IInitializable
    {
        private IAuthenticationState currentState;
        private Stack<IAuthCommand> executedCommands = new Stack<IAuthCommand>();
        private Dictionary<Type, IAuthenticationState> states;
        private bool isInitialized;

        public IAuthenticationState CurrentState => currentState;
        public event Action<IAuthenticationState> OnStateChanged;

        public void Initialize()
        {
            if (isInitialized) return;

            Debug.Log("[AuthFlowManager] Initializing");
            InitializeStates();
            isInitialized = true;
            TransitionTo<InitialState>();
        }

        private void InitializeStates()
        {
            states = new Dictionary<Type, IAuthenticationState>
            {
                { typeof(InitialState), new InitialState(this) },
                { typeof(AuthenticatingState), new AuthenticatingState(this) },
                { typeof(ProfileSelectionState), new ProfileSelectionState(this) },
                { typeof(MainMenuState), new MainMenuState(this) }
            };
        }

        public async Task ExecuteCommand(IAuthCommand command)
        {
            try
            {
                Debug.Log($"[AuthFlowManager] Executing command: {command.GetType().Name}");
                await command.Execute();
                executedCommands.Push(command);
                Debug.Log($"[AuthFlowManager] Command executed successfully: {command.GetType().Name}");
            }
            catch (Exception ex)
            {
                Debug.LogError($"[AuthFlowManager] Command execution failed: {ex.Message}");
                throw;
            }
        }

        public void TransitionTo<T>() where T : IAuthenticationState
        {
            var nextState = states[typeof(T)];

            Debug.Log($"[AuthFlowManager] Attempting transition from {currentState?.GetType().Name ?? "null"} to {typeof(T).Name}");

            if (currentState?.CanTransitionTo(nextState) ?? true)
            {
                currentState?.Exit();
                currentState = nextState;
                OnStateChanged?.Invoke(currentState);
                currentState.Enter();

                Debug.Log($"[AuthFlowManager] Transitioned to {typeof(T).Name}");
            }
            else
            {
                Debug.LogWarning($"[AuthFlowManager] Invalid state transition from {currentState.GetType().Name} to {typeof(T).Name}");
            }
        }

        public bool IsInState<T>() where T : IAuthenticationState
        {
            return currentState?.GetType() == typeof(T);
        }
    }
}
// --- END FILE ---

// File: Core/Services/Authentication/Flow/IAuthenticationState.cs
// Size: 345 characters
// ---
// File: Assets/_CyberPickle/Code/Core/Services/Authentication/Flow/IAuthenticationState.cs
namespace CyberPickle.Core.Services.Authentication.Flow
{
    public interface IAuthenticationState
    {
        void Enter();
        void Exit();
        void Update();
        bool CanTransitionTo(IAuthenticationState nextState);
    }
}

// --- END FILE ---

// File: Core/Services/Authentication/Flow/Commands/ClearProfilesCommand.cs
// Size: 1860 characters
// ---
// File: Assets/_CyberPickle/Code/Core/Services/Authentication/Flow/Commands/ClearProfilesCommand.cs
using UnityEngine;
using System;
using System.Threading.Tasks;
using System.Collections.Generic;
using System.Linq;
using CyberPickle.Core.Services.Authentication.Data;

namespace CyberPickle.Core.Services.Authentication.Flow.Commands
{
    public class ClearProfilesCommand : IAuthCommand
    {
        private readonly ProfileManager profileManager;
        private List<ProfileData> backupProfiles;

        public ClearProfilesCommand(ProfileManager profileManager)
        {
            this.profileManager = profileManager;
        }

        public async Task Execute()
        {
            Debug.Log("[ClearProfilesCommand] Executing profile clear");
            // Backup current profiles before clearing
            backupProfiles = profileManager.GetAllProfiles().ToList();
            await profileManager.ClearAllProfilesAsync();
            Debug.Log("[ClearProfilesCommand] Profiles cleared successfully");
        }

        public void Undo()
        {
            if (backupProfiles != null)
            {
                Debug.Log("[ClearProfilesCommand] Undoing profile clear");
                foreach (var profile in backupProfiles)
                {
                    try
                    {
                        var addTask = profileManager.AddProfileAsync(profile);
                        addTask.Wait();
                    }
                    catch (Exception ex)
                    {
                        Debug.LogError($"[ClearProfilesCommand] Failed to restore profile during undo: {ex.Message}");
                    }
                }
                Debug.Log($"[ClearProfilesCommand] Restored {backupProfiles.Count} profiles");
            }
        }
    }
}
// --- END FILE ---

// File: Core/Services/Authentication/Flow/Commands/CreateProfileCommand.cs
// Size: 2706 characters
// ---
// File: Assets/_CyberPickle/Code/Core/Services/Authentication/Flow/Commands/CreateProfileCommand.cs
using UnityEngine;
using System;
using System.Threading.Tasks;

namespace CyberPickle.Core.Services.Authentication.Flow.Commands
{
    public class CreateProfileCommand : IAuthCommand
    {
        private readonly ProfileManager profileManager;
        private readonly string displayName;
        private string createdProfileId;
        private bool wasSuccessful;

        public CreateProfileCommand(ProfileManager profileManager, string displayName)
        {
            this.profileManager = profileManager;
            this.displayName = displayName;
        }

        public async Task Execute()
        {
            Debug.Log($"[CreateProfileCommand] Creating profile for: {displayName}");

            try
            {
                // Generate a unique profile ID
                createdProfileId = $"{displayName.ToLower()}_{DateTime.UtcNow.Ticks}";

                // Get the current authenticated player ID
                string playerId = AuthenticationManager.Instance.CurrentPlayerId;

                // Create the profile
                var result = await profileManager.CreateProfileAsync(createdProfileId, playerId, displayName);

                if (!result.Success)
                {
                    throw new Exception(result.Message);
                }

                wasSuccessful = true;
                Debug.Log($"[CreateProfileCommand] Profile created successfully: {createdProfileId}");
            }
            catch (Exception ex)
            {
                Debug.LogError($"[CreateProfileCommand] Failed to create profile: {ex.Message}");
                wasSuccessful = false;
                throw;
            }
        }

        public void Undo()
        {
            if (wasSuccessful && !string.IsNullOrEmpty(createdProfileId))
            {
                try
                {
                    Debug.Log($"[CreateProfileCommand] Undoing profile creation: {createdProfileId}");

                    // Execute synchronously since we're in Undo
                    var deleteTask = profileManager.DeleteProfileAsync(createdProfileId);
                    deleteTask.Wait(); // Wait for the async operation to complete

                    Debug.Log($"[CreateProfileCommand] Successfully undid profile creation: {createdProfileId}");
                }
                catch (Exception ex)
                {
                    Debug.LogError($"[CreateProfileCommand] Failed to undo profile creation: {ex.Message}");
                }
            }
        }
    }
}

// --- END FILE ---

// File: Core/Services/Authentication/Flow/Commands/DeleteProfileCommand.cs
// Size: 3331 characters
// ---
// File: Assets/_CyberPickle/Code/Core/Services/Authentication/Flow/Commands/DeleteProfileCommand.cs
using UnityEngine;
using System;
using System.Threading.Tasks;
using System.Linq;
using CyberPickle.Core.Events;
using CyberPickle.Core.Services.Authentication.Data;

namespace CyberPickle.Core.Services.Authentication.Flow.Commands
{
    public class DeleteProfileCommand : IAuthCommand
    {
        private readonly ProfileManager profileManager;
        private readonly string profileId;
        private ProfileData deletedProfileBackup;
        private bool wasActiveProfile;

        public DeleteProfileCommand(ProfileManager profileManager, string profileId)
        {
            this.profileManager = profileManager;
            this.profileId = profileId;
        }

        public async Task Execute()
        {
            Debug.Log($"[DeleteProfileCommand] Preparing to delete profile: {profileId}");

            try
            {
                // Store a backup of the profile before deletion
                var profileToDelete = profileManager.GetProfile(profileId);
                if (profileToDelete == null)
                {
                    throw new Exception($"Profile not found: {profileId}");
                }

                // Create backup
                deletedProfileBackup = profileToDelete;

                // Execute the delete operation
                var result = await profileManager.DeleteProfileAsync(profileId);
                if (!result.Success)
                {
                    throw new Exception(result.Message);
                }

                // Notify that the profile was deleted
                GameEvents.OnProfileDeleted.Invoke(profileId);
            }
            catch (Exception ex)
            {
                Debug.LogError($"[DeleteProfileCommand] Failed to delete profile: {ex.Message}");
                throw;
            }
        }


        public void Undo()
        {
            if (deletedProfileBackup != null)
            {
                try
                {
                    Debug.Log($"[DeleteProfileCommand] Restoring deleted profile: {profileId}");

                    // Restore the profile
                    RestoreProfileCommand restoreCommand = new RestoreProfileCommand(
                        profileManager,
                        deletedProfileBackup);

                    // Execute synchronously since we're in Undo
                    restoreCommand.Execute().GetAwaiter().GetResult();

                    // If this was the active profile, switch back to it
                    if (wasActiveProfile)
                    {
                        SelectProfileCommand selectCommand = new SelectProfileCommand(
                            profileManager,
                            profileId);
                        selectCommand.Execute().GetAwaiter().GetResult();
                    }

                    Debug.Log($"[DeleteProfileCommand] Profile restored successfully: {profileId}");
                }
                catch (Exception ex)
                {
                    Debug.LogError($"[DeleteProfileCommand] Failed to restore profile: {ex.Message}");
                }
            }
        }
    }
}
// --- END FILE ---

// File: Core/Services/Authentication/Flow/Commands/IAuthCommand.cs
// Size: 295 characters
// ---
// File: Assets/_CyberPickle/Code/Core/Services/Authentication/Flow/Commands/IAuthCommand.cs
using System.Threading.Tasks;

namespace CyberPickle.Core.Services.Authentication.Flow.Commands
{
    public interface IAuthCommand
    {
        Task Execute();
        void Undo();
    }
}

// --- END FILE ---

// File: Core/Services/Authentication/Flow/Commands/LoadProfilesCommand.cs
// Size: 1781 characters
// ---
// File: Assets/_CyberPickle/Code/Core/Services/Authentication/Flow/Commands/LoadProfilesCommand.cs
using UnityEngine;
using System;
using System.Threading.Tasks;
using System.Collections.Generic;
using System.Linq;
using CyberPickle.Core.Events;
using CyberPickle.Core.Services.Authentication.Data;

namespace CyberPickle.Core.Services.Authentication.Flow.Commands
{
    public class LoadProfilesCommand : IAuthCommand
    {
        private readonly ProfileManager profileManager;
        private List<ProfileData> loadedProfiles;

        public LoadProfilesCommand(ProfileManager profileManager)
        {
            this.profileManager = profileManager;
        }

        public async Task Execute()
        {
            Debug.Log("[LoadProfilesCommand] Loading profiles");

            try
            {
                // Wait for profile container to load
                await Task.Yield(); // Ensure we're not blocking the main thread

                loadedProfiles = profileManager.GetAllProfiles().ToList();
                Debug.Log($"[LoadProfilesCommand] Successfully loaded {loadedProfiles.Count} profiles");

                // Notify UI that profiles are loaded
                GameEvents.OnProfilesLoaded?.Invoke(loadedProfiles);

                // Give time for any UI updates to complete
                await Task.Yield();
            }
            catch (Exception ex)
            {
                Debug.LogError($"[LoadProfilesCommand] Failed to load profiles: {ex.Message}");
                throw;
            }
        }

        public void Undo()
        {
            Debug.Log("[LoadProfilesCommand] Undoing profile load");
            GameEvents.OnProfilesCleared?.Invoke();
        }
    }
}
// --- END FILE ---

// File: Core/Services/Authentication/Flow/Commands/RestoreProfileCommand.cs
// Size: 3566 characters
// ---
// File: Assets/_CyberPickle/Code/Core/Services/Authentication/Flow/Commands/RestoreProfileCommand.cs
using UnityEngine;
using System;
using System.Threading.Tasks;
using CyberPickle.Core.Events;
using CyberPickle.Core.Services.Authentication.Data;

namespace CyberPickle.Core.Services.Authentication.Flow.Commands
{
    public class RestoreProfileCommand : IAuthCommand
    {
        private readonly ProfileManager profileManager;
        private readonly ProfileData profileToRestore;
        private ProfileData existingProfileBackup;

        public RestoreProfileCommand(ProfileManager profileManager, ProfileData profileToRestore)
        {
            this.profileManager = profileManager;
            this.profileToRestore = profileToRestore;
        }

        public async Task Execute()
        {
            Debug.Log($"[RestoreProfileCommand] Restoring profile: {profileToRestore.ProfileId}");

            try
            {
                // Check if a profile with this ID already exists
                var existingProfile = profileManager.GetProfile(profileToRestore.ProfileId);
                if (existingProfile != null)
                {
                    // Backup the existing profile before overwriting
                    existingProfileBackup = existingProfile;

                    // Delete existing profile
                    var deleteResult = await profileManager.DeleteProfileAsync(existingProfile.ProfileId);
                    if (!deleteResult.Success)
                    {
                        throw new Exception($"Failed to delete existing profile: {deleteResult.Message}");
                    }
                }

                // Restore the profile
                var addResult = await profileManager.AddProfileAsync(profileToRestore);
                if (!addResult.Success)
                {
                    throw new Exception($"Failed to restore profile: {addResult.Message}");
                }

                // Notify that the profile was restored
                GameEvents.OnProfileRestored?.Invoke(profileToRestore.ProfileId);

                Debug.Log($"[RestoreProfileCommand] Profile restored successfully: {profileToRestore.ProfileId}");
            }
            catch (Exception ex)
            {
                Debug.LogError($"[RestoreProfileCommand] Failed to restore profile: {ex.Message}");
                throw;
            }
        }

        public void Undo()
        {
            try
            {
                Debug.Log($"[RestoreProfileCommand] Undoing profile restoration: {profileToRestore.ProfileId}");

                // Remove the restored profile
                var deleteTask = profileManager.DeleteProfileAsync(profileToRestore.ProfileId);
                deleteTask.Wait(); // Wait for the async operation to complete

                // If we backed up an existing profile, restore it
                if (existingProfileBackup != null)
                {
                    var restoreTask = profileManager.AddProfileAsync(existingProfileBackup);
                    restoreTask.Wait(); // Wait for the async operation to complete
                }

                Debug.Log($"[RestoreProfileCommand] Restoration undone for profile: {profileToRestore.ProfileId}");
            }
            catch (Exception ex)
            {
                Debug.LogError($"[RestoreProfileCommand] Failed to undo profile restoration: {ex.Message}");
            }
        }
    }
}


// --- END FILE ---

// File: Core/Services/Authentication/Flow/Commands/SelectProfileCommand.cs
// Size: 2459 characters
// ---
// File: Assets/_CyberPickle/Code/Core/Services/Authentication/Flow/Commands/SelectProfileCommand.cs
using UnityEngine;
using System;
using System.Threading.Tasks;

namespace CyberPickle.Core.Services.Authentication.Flow.Commands
{
    public class SelectProfileCommand : IAuthCommand
    {
        private readonly ProfileManager profileManager;
        private readonly string profileId;
        private string previousProfileId;

        public SelectProfileCommand(ProfileManager profileManager, string profileId)
        {
            this.profileManager = profileManager;
            this.profileId = profileId;
        }

        public async Task Execute()
        {
            Debug.Log($"[SelectProfileCommand] Selecting profile: {profileId}");

            try
            {
                // Store the previously active profile ID for undo
                previousProfileId = profileManager.ActiveProfile?.ProfileId;

                // Switch to the new profile
                var result = await profileManager.SwitchActiveProfileAsync(profileId);

                if (!result.Success)
                {
                    throw new Exception($"Failed to switch profile: {result.Message}");
                }

                Debug.Log($"[SelectProfileCommand] Profile selected successfully: {profileId}");
            }
            catch (Exception ex)
            {
                Debug.LogError($"[SelectProfileCommand] Failed to select profile: {ex.Message}");
                throw;
            }
        }

        public void Undo()
        {
            if (!string.IsNullOrEmpty(previousProfileId))
            {
                try
                {
                    Debug.Log($"[SelectProfileCommand] Reverting to previous profile: {previousProfileId}");

                    // Execute synchronously since we're in Undo
                    var switchTask = profileManager.SwitchActiveProfileAsync(previousProfileId);
                    switchTask.Wait(); // Wait for the async operation to complete

                    Debug.Log($"[SelectProfileCommand] Successfully reverted to previous profile: {previousProfileId}");
                }
                catch (Exception ex)
                {
                    Debug.LogError($"[SelectProfileCommand] Failed to revert to previous profile: {ex.Message}");
                }
            }
        }
    }
}

// --- END FILE ---

// File: Core/Services/Authentication/Flow/Commands/StartAuthenticationCommand.cs
// Size: 1261 characters
// ---
// File: Assets/_CyberPickle/Code/Core/Services/Authentication/Flow/Commands/StartAuthenticationCommand.cs
using UnityEngine;
using System;
using System.Threading.Tasks;

namespace CyberPickle.Core.Services.Authentication.Flow.Commands
{
    public class StartAuthenticationCommand : IAuthCommand
    {
        private readonly AuthenticationManager authManager;
        private bool isAuthenticated;

        public StartAuthenticationCommand(AuthenticationManager authManager)
        {
            this.authManager = authManager;
        }

        public async Task Execute()
        {
            Debug.Log("[StartAuthCommand] Starting authentication");
            isAuthenticated = await authManager.SignInAnonymouslyAsync();

            if (isAuthenticated)
            {
                Debug.Log("[StartAuthCommand] Authentication successful");
            }
            else
            {
                Debug.LogError("[StartAuthCommand] Authentication failed");
                throw new Exception("Authentication failed");
            }
        }

        public void Undo()
        {
            if (isAuthenticated)
            {
                authManager.SignOut();
            }
        }
    }
}

// --- END FILE ---

// File: Core/Services/Authentication/Flow/States/AuthenticatingState.cs
// Size: 1599 characters
// ---
// File: Assets/_CyberPickle/Code/Core/Services/Authentication/Flow/States/AuthenticatingState.cs
using UnityEngine;
using System.Threading.Tasks;
using CyberPickle.Core.Services.Authentication.Flow.Commands;

namespace CyberPickle.Core.Services.Authentication.Flow.States
{
    public class AuthenticatingState : IAuthenticationState
    {
        private readonly AuthenticationFlowManager flowManager;
        private readonly AuthenticationManager authManager;

        public AuthenticatingState(AuthenticationFlowManager flowManager)
        {
            this.flowManager = flowManager;
            this.authManager = AuthenticationManager.Instance;
        }

        public async void Enter()
        {
            Debug.Log("[AuthenticatingState] Starting authentication");
            var command = new StartAuthenticationCommand(authManager);
            await flowManager.ExecuteCommand(command);

            // Only transition to ProfileSelectionState after successful authentication
            if (authManager.IsSignedIn)
            {
                flowManager.TransitionTo<ProfileSelectionState>();
            }
        }

        public void Exit()
        {
            Debug.Log("[AuthenticatingState] Authentication completed");
        }

        public void Update() { }

        public bool CanTransitionTo(IAuthenticationState nextState)
        {
            // Can only transition to ProfileSelectionState if authenticated
            return nextState is ProfileSelectionState && authManager.IsSignedIn;
        }
    }
}

// --- END FILE ---

// File: Core/Services/Authentication/Flow/States/InitialState.cs
// Size: 902 characters
// ---
// File: Assets/_CyberPickle/Code/Core/Services/Authentication/Flow/States/InitialState.cs
using UnityEngine;

namespace CyberPickle.Core.Services.Authentication.Flow.States
{
    public class InitialState : IAuthenticationState
    {
        private readonly AuthenticationFlowManager flowManager;

        public InitialState(AuthenticationFlowManager flowManager)
        {
            this.flowManager = flowManager;
        }

        public void Enter()
        {
            Debug.Log("[InitialState] Entered");
        }

        public void Exit()
        {
            Debug.Log("[InitialState] Exited");
        }

        public void Update() { }

        public bool CanTransitionTo(IAuthenticationState nextState)
        {
            // Allow transition to AuthenticatingState only
            return nextState is AuthenticatingState;
        }
    }
}

// --- END FILE ---

// File: Core/Services/Authentication/Flow/States/MainMenuState.cs
// Size: 1005 characters
// ---
// File: Assets/_CyberPickle/Code/Core/Services/Authentication/Flow/States/MainMenuState.cs
using CyberPickle.Core.Events;
using CyberPickle.Core.States;
using UnityEngine;

namespace CyberPickle.Core.Services.Authentication.Flow.States
{
    public class MainMenuState : IAuthenticationState
    {
        private readonly AuthenticationFlowManager flowManager;

        public MainMenuState(AuthenticationFlowManager flowManager)
        {
            this.flowManager = flowManager;
        }

        public void Enter()
        {
            Debug.Log("[MainMenuState] Entering main menu");
            GameEvents.OnGameStateChanged.Invoke(GameState.MainMenu);
        }

        public void Exit()
        {
            Debug.Log("[MainMenuState] Exiting main menu");
        }

        public void Update() { }

        public bool CanTransitionTo(IAuthenticationState nextState)
        {
            return nextState is ProfileSelectionState;
        }
    }
}

// --- END FILE ---

// File: Core/Services/Authentication/Flow/States/ProfileSelectionState.cs
// Size: 1266 characters
// ---
// File: Assets/_CyberPickle/Code/Core/Services/Authentication/Flow/States/ProfileSelectionState.cs
using UnityEngine;
using CyberPickle.Core.Services.Authentication.Flow.Commands;

namespace CyberPickle.Core.Services.Authentication.Flow.States
{
    public class ProfileSelectionState : IAuthenticationState
    {
        private readonly AuthenticationFlowManager flowManager;
        private readonly ProfileManager profileManager;

        public ProfileSelectionState(AuthenticationFlowManager flowManager)
        {
            this.flowManager = flowManager;
            this.profileManager = ProfileManager.Instance;
        }

        public async void Enter()
        {
            Debug.Log("[ProfileSelectionState] Entering profile selection");
            var command = new LoadProfilesCommand(profileManager);
            await flowManager.ExecuteCommand(command);
        }

        public void Exit()
        {
            Debug.Log("[ProfileSelectionState] Exiting profile selection");
        }

        public void Update() { }

        public bool CanTransitionTo(IAuthenticationState nextState)
        {
            return nextState is MainMenuState || nextState is AuthenticatingState;
        }
    }
}


// --- END FILE ---

