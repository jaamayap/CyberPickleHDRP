// File: Achievements/AchievementManager.cs
// Size: 349 characters
// ---
using CyberPickle.Core.Management;
using CyberPickle.Core.Interfaces;
using UnityEngine;

namespace CyberPickle.Achievements
{
    public class AchievementManager : Manager<AchievementManager>, IInitializable
    {
        public void Initialize()
        {
            Debug.Log("Initializing Achievement Manager");
        }
    }
}

// --- END FILE ---

// File: Characters/CharacterManager.cs
// Size: 331 characters
// ---
using CyberPickle.Core.Management;
using CyberPickle.Core.Interfaces;

namespace CyberPickle.Characters
{
    public class CharacterManager : Manager<CharacterManager>, IInitializable
    {
        public void Initialize()
        {
            UnityEngine.Debug.Log("CharacterManager initialized");
        }
    }
}

// --- END FILE ---

// File: Progression/ProgressionManager.cs
// Size: 338 characters
// ---
using CyberPickle.Core.Management;
using CyberPickle.Core.Interfaces;

namespace CyberPickle.Progression
{
    public class ProgressionManager : Manager<ProgressionManager>, IInitializable
    {
        public void Initialize()
        {
            UnityEngine.Debug.Log("ProgressionManager initialized");
        }
    }
}

// --- END FILE ---

// File: Shop/ShopManager.cs
// Size: 18307 characters
// ---
// File: Assets/Code/Shop/ShopManager.cs
//
// Purpose: Manages the game's shop system, handling purchase requests,
// equipment upgrades, and shop interface integration.
// Integrates with EquipmentManager and CurrencyManager.
//
// Created: 2025-02-25
// Updated: 2025-02-25

using UnityEngine;
using System;
using System.Threading.Tasks;
using CyberPickle.Core.Management;
using CyberPickle.Core.Interfaces;
using CyberPickle.Core.Services.Authentication;
using CyberPickle.Core.Services.Authentication.Data;
using CyberPickle.Shop.Equipment;
using CyberPickle.Shop.Equipment.Data;
using CyberPickle.Shop.Currency;
using System.Collections.Generic;

namespace CyberPickle.Shop
{
    /// <summary>
    /// Result of a shop transaction
    /// </summary>
    public class ShopTransactionResult
    {
        /// <summary>
        /// Whether the transaction was successful
        /// </summary>
        public bool Success { get; private set; }

        /// <summary>
        /// Description of the result
        /// </summary>
        public string Message { get; private set; }

        /// <summary>
        /// The cost of the transaction
        /// </summary>
        public float Cost { get; private set; }

        /// <summary>
        /// The type of currency used
        /// </summary>
        public CurrencyType CurrencyType { get; private set; }

        /// <summary>
        /// The equipment that was purchased/upgraded
        /// </summary>
        public EquipmentData Equipment { get; private set; }

        private ShopTransactionResult(bool success, string message, float cost = 0, CurrencyType currencyType = CurrencyType.NeuralCredits, EquipmentData equipment = null)
        {
            Success = success;
            Message = message;
            Cost = cost;
            CurrencyType = currencyType;
            Equipment = equipment;
        }

        /// <summary>
        /// Create a successful transaction result
        /// </summary>
        public static ShopTransactionResult Succeeded(string message, float cost, CurrencyType currencyType, EquipmentData equipment = null)
        {
            return new ShopTransactionResult(true, message, cost, currencyType, equipment);
        }

        /// <summary>
        /// Create a failed transaction result
        /// </summary>
        public static ShopTransactionResult Failed(string message)
        {
            return new ShopTransactionResult(false, message);
        }
    }

    /// <summary>
    /// Type of shop transaction
    /// </summary>
    public enum ShopTransactionType
    {
        Purchase,
        Upgrade,
        Unlock
    }

    /// <summary>
    /// Manager class for the shop system
    /// </summary>
    public class ShopManager : Manager<ShopManager>, IInitializable
    {
        [Header("Shop Settings")]
        [SerializeField] private float upgradeBaseCostMultiplier = 0.5f;
        [SerializeField] private float upgradeLevelCostMultiplier = 1.5f;

        // Events
        public event Action<EquipmentData, ShopTransactionType> OnPurchaseCompleted;
        public event Action<EquipmentData, ShopTransactionType, string> OnPurchaseFailed;

        // Dependencies
        private EquipmentManager equipmentManager;
        private CurrencyManager currencyManager;
        private ProfileManager profileManager;

        // Initialization flag
        private bool isInitialized = false;

        /// <summary>
        /// Initialize the Shop Manager
        /// </summary>
        public void Initialize()
        {
            if (isInitialized) return;

            Debug.Log("[ShopManager] Initializing...");

            // Get dependencies
            equipmentManager = EquipmentManager.Instance;
            currencyManager = CurrencyManager.Instance;
            profileManager = ProfileManager.Instance;

            if (equipmentManager == null)
            {
                Debug.LogError("[ShopManager] EquipmentManager not found!");
                return;
            }

            if (currencyManager == null)
            {
                Debug.LogError("[ShopManager] CurrencyManager not found!");
                return;
            }

            if (profileManager == null)
            {
                Debug.LogError("[ShopManager] ProfileManager not found!");
                return;
            }

            isInitialized = true;
            Debug.Log("[ShopManager] Initialized successfully");
        }

        #region Purchase Methods

        /// <summary>
        /// Purchase a new equipment item
        /// </summary>
        /// <param name="equipmentId">ID of the equipment to purchase</param>
        /// <param name="currencyType">Type of currency to use</param>
        /// <returns>Result of the transaction</returns>
        public async Task<ShopTransactionResult> PurchaseEquipment(string equipmentId, CurrencyType currencyType)
        {
            if (!isInitialized)
                return ShopTransactionResult.Failed("Shop manager not initialized");

            // Get equipment data
            var equipment = equipmentManager.GetEquipmentById(equipmentId);
            if (equipment == null)
                return ShopTransactionResult.Failed($"Equipment with ID {equipmentId} not found");

            // Check if already unlocked
            var profile = profileManager.ActiveProfile;
            if (profile == null)
                return ShopTransactionResult.Failed("No active profile");

            if (profile.IsEquipmentUnlocked(equipmentId))
                return ShopTransactionResult.Failed($"{equipment.displayName} is already unlocked");

            // Calculate cost based on currency type
            float cost = currencyType == CurrencyType.NeuralCredits ? equipment.neuralCreditCost : equipment.cyberCoinCost;
            if (cost <= 0)
                return ShopTransactionResult.Failed($"{equipment.displayName} cannot be purchased with {currencyType}");

            // Check if player has enough currency
            if (!currencyManager.HasSufficientFunds(cost, currencyType))
            {
                string message = $"Insufficient {currencyType} for {equipment.displayName}. Required: {cost}, Available: {(currencyType == CurrencyType.NeuralCredits ? currencyManager.NeuralCredits : currencyManager.CyberCoins)}";
                OnPurchaseFailed?.Invoke(equipment, ShopTransactionType.Purchase, message);
                return ShopTransactionResult.Failed(message);
            }

            // Spend currency
            bool spentSuccess = await currencyManager.SpendCurrency(cost, currencyType);
            if (!spentSuccess)
                return ShopTransactionResult.Failed($"Failed to spend {currencyType} for {equipment.displayName}");

            // Unlock equipment
            bool unlockSuccess = equipmentManager.UnlockEquipment(equipmentId);
            if (!unlockSuccess)
            {
                // Refund currency if unlock fails
                await currencyManager.AddCurrency(cost, currencyType);
                return ShopTransactionResult.Failed($"Failed to unlock {equipment.displayName}");
            }

            // Notify purchase completed
            OnPurchaseCompleted?.Invoke(equipment, ShopTransactionType.Purchase);

            return ShopTransactionResult.Succeeded(
                $"Successfully purchased {equipment.displayName}",
                cost,
                currencyType,
                equipment
            );
        }

        /// <summary>
        /// Unlocks equipment without spending currency (for rewards, achievements, etc.)
        /// </summary>
        /// <param name="equipmentId">ID of the equipment to unlock</param>
        /// <returns>Result of the transaction</returns>
        public async Task<ShopTransactionResult> UnlockEquipmentFree(string equipmentId)
        {
            if (!isInitialized)
                return ShopTransactionResult.Failed("Shop manager not initialized");

            // Get equipment data
            var equipment = equipmentManager.GetEquipmentById(equipmentId);
            if (equipment == null)
                return ShopTransactionResult.Failed($"Equipment with ID {equipmentId} not found");

            // Check if already unlocked
            var profile = profileManager.ActiveProfile;
            if (profile == null)
                return ShopTransactionResult.Failed("No active profile");

            if (profile.IsEquipmentUnlocked(equipmentId))
                return ShopTransactionResult.Failed($"{equipment.displayName} is already unlocked");

            // Unlock equipment
            bool unlockSuccess = equipmentManager.UnlockEquipment(equipmentId);
            if (!unlockSuccess)
                return ShopTransactionResult.Failed($"Failed to unlock {equipment.displayName}");

            // Notify purchase completed (as an unlock)
            OnPurchaseCompleted?.Invoke(equipment, ShopTransactionType.Unlock);

            return ShopTransactionResult.Succeeded(
                $"Successfully unlocked {equipment.displayName}",
                0,
                CurrencyType.NeuralCredits,
                equipment
            );
        }

        /// <summary>
        /// Calculates the cost to upgrade a piece of equipment
        /// </summary>
        /// <param name="equipment">The equipment to upgrade</param>
        /// <param name="currentLevel">Current level of the equipment</param>
        /// <param name="targetLevel">Target level to upgrade to</param>
        /// <returns>The cost in Neural Credits</returns>
        public int CalculateUpgradeCost(EquipmentData equipment, int currentLevel, int targetLevel)
        {
            if (equipment == null || currentLevel >= targetLevel || currentLevel < 1 || targetLevel > equipment.maxUpgradeLevel)
                return 0;

            return equipment.GetUpgradeCost(currentLevel, targetLevel);
        }

        /// <summary>
        /// Upgrade an equipment item to a higher level
        /// </summary>
        /// <param name="equipmentId">ID of the equipment to upgrade</param>
        /// <param name="targetLevel">Target level to upgrade to</param>
        /// <returns>Result of the transaction</returns>
        /// <summary>
        /// Upgrade an equipment item to a higher level
        /// </summary>
        /// <param name="equipmentId">ID of the equipment to upgrade</param>
        /// <param name="targetLevel">Target level to upgrade to</param>
        /// <returns>Result of the transaction</returns>
        public async Task<ShopTransactionResult> UpgradeEquipment(string equipmentId, int targetLevel)
        {
            if (!isInitialized)
                return ShopTransactionResult.Failed("Shop manager not initialized");

            // Get equipment data
            var equipment = equipmentManager.GetEquipmentById(equipmentId);
            if (equipment == null)
                return ShopTransactionResult.Failed($"Equipment with ID {equipmentId} not found");

            // Check if equipment is unlocked
            var profile = profileManager.ActiveProfile;
            if (profile == null)
                return ShopTransactionResult.Failed("No active profile");

            if (!profile.IsEquipmentUnlocked(equipmentId) && !equipment.unlockedByDefault)
                return ShopTransactionResult.Failed($"{equipment.displayName} is not unlocked yet");

            // Get current equipment level
            int currentLevel = profile.GetEquipmentLevel(equipmentId);

            // If no progression data exists yet, create it (level 1)
            if (currentLevel == 0)
            {
                profile.GetOrCreateEquipmentProgression(equipmentId);
                currentLevel = 1;
            }

            // Validate target level
            if (targetLevel <= currentLevel)
                return ShopTransactionResult.Failed($"{equipment.displayName} is already at level {currentLevel}");

            if (targetLevel > equipment.maxUpgradeLevel)
                return ShopTransactionResult.Failed($"Cannot upgrade {equipment.displayName} beyond level {equipment.maxUpgradeLevel}");

            // Calculate upgrade cost
            int cost = CalculateUpgradeCost(equipment, currentLevel, targetLevel);
            if (cost <= 0)
                return ShopTransactionResult.Failed($"Invalid upgrade cost for {equipment.displayName}");

            // Check if player has enough currency (always Neural Credits for upgrades)
            if (!currencyManager.HasSufficientFunds(cost, CurrencyType.NeuralCredits))
            {
                string message = $"Insufficient Neural Credits for upgrading {equipment.displayName}. Required: {cost}, Available: {currencyManager.NeuralCredits}";
                OnPurchaseFailed?.Invoke(equipment, ShopTransactionType.Upgrade, message);
                return ShopTransactionResult.Failed(message);
            }

            // Spend currency
            bool spentSuccess = await currencyManager.SpendCurrency(cost, CurrencyType.NeuralCredits);
            if (!spentSuccess)
                return ShopTransactionResult.Failed($"Failed to spend Neural Credits for {equipment.displayName} upgrade");

            // Update equipment level in profile data
            bool upgradeSuccess = profile.UpgradeEquipment(equipmentId, targetLevel);
            if (!upgradeSuccess)
            {
                // Refund currency if upgrade fails
                await currencyManager.AddCurrency(cost, CurrencyType.NeuralCredits);
                return ShopTransactionResult.Failed($"Failed to upgrade {equipment.displayName}");
            }

            // Update the profile
            var updateResult = await profileManager.UpdateProfileAsync(profile);
            if (!updateResult.Success)
            {
                // Refund currency if profile update fails
                await currencyManager.AddCurrency(cost, CurrencyType.NeuralCredits);
                return ShopTransactionResult.Failed($"Failed to save {equipment.displayName} upgrade: {updateResult.Message}");
            }

            // Notify purchase completed
            OnPurchaseCompleted?.Invoke(equipment, ShopTransactionType.Upgrade);

            return ShopTransactionResult.Succeeded(
                $"Successfully upgraded {equipment.displayName} to level {targetLevel}",
                cost,
                CurrencyType.NeuralCredits,
                equipment
            );
        }


        #endregion

        #region Shop Query Methods

        /// <summary>
        /// Gets all equipment available for purchase (not yet unlocked)
        /// </summary>
        /// <returns>List of available equipment</returns>
        public Dictionary<EquipmentSlotType, List<EquipmentData>> GetAvailableEquipment()
        {
            Dictionary<EquipmentSlotType, List<EquipmentData>> result = new Dictionary<EquipmentSlotType, List<EquipmentData>>();

            // Initialize all slot types with empty lists
            foreach (EquipmentSlotType slotType in Enum.GetValues(typeof(EquipmentSlotType)))
            {
                result[slotType] = new List<EquipmentData>();
            }

            if (!isInitialized || profileManager.ActiveProfile == null)
                return result;

            var profile = profileManager.ActiveProfile;

            // Get all equipment by slot type
            foreach (EquipmentSlotType slotType in Enum.GetValues(typeof(EquipmentSlotType)))
            {
                // Get all equipment of this type
                var equipmentList = equipmentManager.GetEquipmentBySlotType(slotType);

                // Filter out already unlocked equipment
                foreach (var equipment in equipmentList)
                {
                    if (!profile.IsEquipmentUnlocked(equipment.equipmentId) && !equipment.unlockedByDefault)
                    {
                        // Check if player meets level requirement
                        if (profile.Level >= equipment.requiredPlayerLevel)
                        {
                            result[slotType].Add(equipment);
                        }
                    }
                }
            }

            return result;
        }

        /// <summary>
        /// Gets all equipment that can be upgraded
        /// </summary>
        /// <returns>List of upgradeable equipment</returns>
        /// <summary>
        /// Gets all equipment that can be upgraded
        /// </summary>
        /// <returns>List of upgradeable equipment</returns>
        public List<EquipmentData> GetUpgradeableEquipment()
        {
            List<EquipmentData> result = new List<EquipmentData>();

            if (!isInitialized || profileManager.ActiveProfile == null)
                return result;

            var profile = profileManager.ActiveProfile;

            // Get all unlocked equipment
            var unlockedEquipment = equipmentManager.GetUnlockedEquipment();

            foreach (var equipment in unlockedEquipment)
            {
                // Check current equipment level from profile data
                int currentLevel = profile.GetEquipmentLevel(equipment.equipmentId);

                // If level is 0, it means no progression data exists yet, so it's level 1
                if (currentLevel == 0)
                    currentLevel = 1;

                // Can upgrade if current level is less than max level
                if (currentLevel < equipment.maxUpgradeLevel)
                {
                    result.Add(equipment);
                }
            }

            return result;
        }

        #endregion

        protected override void OnManagerDestroyed()
        {
            base.OnManagerDestroyed();
        }
    }
}
// --- END FILE ---

// File: Characters/Data/CharacterData.cs
// Size: 5601 characters
// ---
// File: Assets/Code/Characters/Data/CharacterData.cs
//
// Purpose: Defines the base data structure for playable characters in Cyber Pickle.
// This ScriptableObject stores character attributes, stats, unlock requirements,
// and visual references. Stats are aligned with the core gameplay design and 
// character progression systems.
//
// Created: 2024-02-11
// Updated: 2024-02-11

using UnityEngine;
using System;

namespace CyberPickle.Characters.Data
{
    /// <summary>
    /// ScriptableObject that defines the base data for a playable character.
    /// Contains all permanent character data including base stats, unlock requirements,
    /// and visual references. Runtime character state and progression are stored separately
    /// in ProfileData.
    /// </summary>
    [CreateAssetMenu(fileName = "Character", menuName = "CyberPickle/Characters/CharacterData")]
    public class CharacterData : ScriptableObject
    {
        [Header("Basic Info")]
        [Tooltip("Unique identifier for the character")]
        public string characterId;

        [Tooltip("Display name shown in the UI")]
        public string displayName;

        [Tooltip("Short description for character selection screen")]
        [TextArea(3, 5)]
        public string description;

        [Tooltip("Extended character backstory and lore")]
        [TextArea(5, 10)]
        public string lore;

        [Header("Visual References")]
        [Tooltip("The character's prefab containing model and required components")]
        public GameObject characterPrefab;

        [Tooltip("2D icon for UI elements")]
        public Sprite characterIcon;

        [Tooltip("Material applied when character is locked")]
        public Material lockedMaterial;

        [Header("Base Stats")]
        [Tooltip("Maximum health points")]
        public float maxHealth = 100f;

        [Tooltip("Rate of health recovery over time")]
        public float healthRegeneration = 1f;

        [Tooltip("Reduces incoming damage")]
        public float defense = 10f;

        [Tooltip("Enhances weapon damage")]
        public float power = 10f;

        [Tooltip("Affects movement speed")]
        public float speed = 5f;

        [Tooltip("Increases item attraction radius")]
        public float magneticField = 1f;

        [Tooltip("Influences rate of fire")]
        public float dexterity = 10f;

        [Tooltip("Affects drop rates and item rarity")]
        public float luck = 1f;

        [Tooltip("Increases explosion radius and effect areas")]
        public float areaOfEffect = 1f;

        [Header("Unlock Requirements")]
        [Tooltip("If true, character is available from the start")]
        public bool unlockedByDefault;

        [Tooltip("Minimum player level required to unlock")]
        public int requiredPlayerLevel;

        [Tooltip("Achievement IDs required to unlock this character")]
        public string[] requiredAchievements;

        [Header("Animation Parameters")]
        [Tooltip("Trigger parameter for idle animation")]
        public string idleAnimationTrigger = "Idle";

        [Tooltip("Trigger parameter for hover/preview animation")]
        public string hoverAnimationTrigger = "Dance";

        [Tooltip("Trigger parameter for selection animation")]
        public string selectAnimationTrigger = "Selected";

        [Tooltip("Trigger parameter for locked state animation")]
        public string lockedAnimationTrigger = "Locked";

        /// <summary>
        /// Validates the CharacterData when it's created or modified in the editor.
        /// Automatically generates a characterId if none is provided.
        /// </summary>
        private void OnValidate()
        {
            if (string.IsNullOrEmpty(characterId))
            {
                characterId = displayName?.ToLower().Replace(" ", "_") ?? "undefined";
                Debug.Log($"[CharacterData] Auto-generated characterId: {characterId}");
            }

            ValidateStats();
        }

        /// <summary>
        /// Ensures all stats are within valid ranges
        /// </summary>
        private void ValidateStats()
        {
            maxHealth = Mathf.Max(1f, maxHealth);
            healthRegeneration = Mathf.Max(0f, healthRegeneration);
            defense = Mathf.Max(0f, defense);
            power = Mathf.Max(0f, power);
            speed = Mathf.Max(0.1f, speed);
            magneticField = Mathf.Max(0.1f, magneticField);
            dexterity = Mathf.Max(0f, dexterity);
            luck = Mathf.Max(0f, luck);
            areaOfEffect = Mathf.Max(0.1f, areaOfEffect);
        }

#if UNITY_EDITOR
        /// <summary>
        /// Validates required references are assigned in the editor
        /// </summary>
        public bool ValidateReferences()
        {
            if (characterPrefab == null)
            {
                Debug.LogError($"[CharacterData] Character prefab is missing for {displayName}");
                return false;
            }

            if (characterIcon == null)
            {
                Debug.LogError($"[CharacterData] Character icon is missing for {displayName}");
                return false;
            }

            if (lockedMaterial == null)
            {
                Debug.LogError($"[CharacterData] Locked material is missing for {displayName}");
                return false;
            }

            return true;
        }
#endif
    }
}

// --- END FILE ---

// File: Characters/Logic/CharacterDisplayManager.cs
// Size: 13164 characters
// ---
using UnityEngine;
using System;
using System.Threading.Tasks;
using System.Collections.Generic;
using CyberPickle.Core.Management;
using CyberPickle.Core.Events;
using CyberPickle.Characters.Data;
using DG.Tweening;
using UnityEngine.EventSystems;

namespace CyberPickle.Characters.Logic
{
    /// <summary>
    /// Manages character visualization and interaction infrastructure in the selection screen.
    /// Responsible for spawning character models, controlling animations,
    /// applying materials, and handling spotlight logic (purely visual aspects).
    /// </summary>
    public class CharacterDisplayManager : Manager<CharacterDisplayManager>
    {
        #region Serialized Fields

        [Header("Animation Settings")]
        [SerializeField] private float transitionDuration = 0.5f;
        [SerializeField] private float idleAnimationSpeed = 1f;
        [SerializeField] private float hoverAnimationSpeed = 1.2f;

        [Header("Visual Effects")]
        [SerializeField] private float highlightIntensity = 1.5f;
        [SerializeField] private float dimmedIntensity = 0.5f;
        [SerializeField] private Material lockedMaterial;

        [Header("Spotlight Settings")]
        [SerializeField] private float spotlightIntensity = 5000f;
        [SerializeField] private float spotlightRange = 10f;
        [SerializeField] private float spotlightAngle = 30f;

        #endregion

        #region Private Fields

        private Dictionary<GameObject, Animator> characterAnimators = new Dictionary<GameObject, Animator>();
        private Dictionary<GameObject, Material[]> originalMaterials = new Dictionary<GameObject, Material[]>();
        private Dictionary<GameObject, SkinnedMeshRenderer> characterRenderers = new Dictionary<GameObject, SkinnedMeshRenderer>();
        private bool isInitialized;

        #endregion

        #region Manager Lifecycle

        protected override void OnManagerAwake()
        {
            base.OnManagerAwake();
            ValidateReferences();
        }

        /// <summary>
        /// Called once before use. Prepares pointer interaction and related
        /// display infrastructure.
        /// </summary>
        public void Initialize()
        {
            if (isInitialized) return;

            SetupPointerInteraction();
            isInitialized = true;
            Debug.Log("[CharacterDisplayManager] Initialized successfully");
        }

        private void ValidateReferences()
        {
            if (lockedMaterial == null)
            {
                Debug.LogError("[CharacterDisplayManager] Locked material is not assigned!");
            }
        }

        /// <summary>
        /// Optionally set up physics raycasting on the main camera, etc.
        /// </summary>
        private void SetupPointerInteraction()
        {
            var camera = Camera.main;
            if (camera != null && camera.GetComponent<PhysicsRaycaster>() == null)
            {
                var raycaster = camera.gameObject.AddComponent<PhysicsRaycaster>();
                raycaster.eventMask = LayerMask.GetMask("Character");
                Debug.Log("[CharacterDisplayManager] Added PhysicsRaycaster to main camera");
            }

            if (FindObjectOfType<EventSystem>() == null)
            {
                var eventSystem = new GameObject("Event System");
                eventSystem.AddComponent<EventSystem>();
                eventSystem.AddComponent<StandaloneInputModule>();
                Debug.Log("[CharacterDisplayManager] Created EventSystem");
            }
        }

        #endregion

        #region Character Spawning and Setup

        /// <summary>
        /// Spawns and initializes a character model with visual components.
        /// </summary>
        public async Task<GameObject> SpawnCharacter(CharacterData characterData, Vector3 position, Quaternion rotation)
        {
            if (characterData == null || characterData.characterPrefab == null)
            {
                Debug.LogError("[CharacterDisplayManager] Invalid character data for spawning!");
                return null;
            }

            try
            {
                // Instantiate
                Quaternion targetRotation = Quaternion.Euler(0, 180, 0);
                GameObject characterInstance = Instantiate(characterData.characterPrefab, position, targetRotation);
                characterInstance.name = $"Character_{characterData.characterId}";

                // Cache animator, renderer, etc.
                CacheCharacterComponents(characterInstance);
                await InitializeCharacterVisuals(characterInstance, characterData);

                Debug.Log($"[CharacterDisplayManager] Spawned character: {characterData.characterId}");
                return characterInstance;
            }
            catch (Exception e)
            {
                Debug.LogError($"[CharacterDisplayManager] Failed to spawn character: {e.Message}");
                return null;
            }
        }

        private void CacheCharacterComponents(GameObject character)
        {
            var animator = character.GetComponent<Animator>();
            if (animator != null)
            {
                characterAnimators[character] = animator;
            }

            var renderer = character.GetComponentInChildren<SkinnedMeshRenderer>();
            if (renderer != null)
            {
                characterRenderers[character] = renderer;
                originalMaterials[character] = renderer.materials;
            }
        }

        private async Task InitializeCharacterVisuals(GameObject character, CharacterData characterData)
        {
            if (characterAnimators.TryGetValue(character, out var animator))
            {
                animator.SetTrigger(characterData.idleAnimationTrigger);
                animator.speed = idleAnimationSpeed;
            }
            await Task.Yield(); // Simple async yield
        }

        #endregion

        #region Visual State Management

        /// <summary>
        /// Updates the visual state (materials, animation, lighting) for a character.
        /// </summary>
        public void UpdateCharacterState(GameObject character, CharacterDisplayState state)
        {
            if (character == null) return;
            UpdateAnimation(character, state);
            UpdateMaterials(character, state);
            UpdateLighting(character, state);
        }

        private void UpdateAnimation(GameObject character, CharacterDisplayState state)
        {
            if (!characterAnimators.TryGetValue(character, out var animator)) return;

            // Reset triggers
            animator.ResetTrigger("Idle");
            animator.ResetTrigger("Dance");
            animator.ResetTrigger("Selected");
            animator.ResetTrigger("Locked");

            string charId = character.name.Replace("Character_", "");

            // Check lock status by consulting the selection manager
            bool isLocked = !CharacterSelectionManager.Instance.IsCharacterUnlocked(charId);

            if (isLocked)
            {
                // If the selection manager always passes "Hover" even for locked,
                // we can do locked hover logic here
                if (state == CharacterDisplayState.Hover)
                {
                    // E.g. "LockedHover" if your animator needs a separate state, or just "Locked"
                    animator.SetTrigger("Locked");
                    animator.speed = 0.5f;
                }
                else
                {
                    animator.SetTrigger("Idle");
                    animator.speed = idleAnimationSpeed;
                }
            }
            else
            {
                // Normal unlocked logic
                switch (state)
                {
                    case CharacterDisplayState.Idle:
                        animator.SetTrigger("Idle");
                        animator.speed = idleAnimationSpeed;
                        break;
                    case CharacterDisplayState.Hover:
                        animator.SetTrigger("Dance");
                        animator.speed = hoverAnimationSpeed;
                        break;
                    case CharacterDisplayState.Selected:
                        animator.SetTrigger("Selected");
                        animator.speed = 1f;
                        break;
                    case CharacterDisplayState.Locked:
                        // Just in case
                        animator.SetTrigger("Locked");
                        animator.speed = 0.5f;
                        break;
                }
            }
        }


        private void UpdateMaterials(GameObject character, CharacterDisplayState state)
        {
            if (!characterRenderers.TryGetValue(character, out var renderer) ||
                !originalMaterials.ContainsKey(character))
            {
                return;
            }

            // 1) Figure out if itï¿½s truly locked
            string charId = character.name.Replace("Character_", "");
            bool isLocked = !CharacterSelectionManager.Instance.IsCharacterUnlocked(charId);

            // 2) If locked, apply lockedMaterial
            if (isLocked && lockedMaterial != null)
            {
                var lockedMats = new Material[renderer.materials.Length];
                for (int i = 0; i < lockedMats.Length; i++)
                {
                    lockedMats[i] = lockedMaterial;
                }
                renderer.materials = lockedMats;
            }
            else
            {
                // 3) Otherwise, normal logic
                float intensity = (state == CharacterDisplayState.Hover || state == CharacterDisplayState.Selected)
                    ? highlightIntensity
                    : 1f;

                var currentMaterials = originalMaterials[character];
                foreach (var mat in currentMaterials)
                {
                    if (mat.HasProperty("_EmissionIntensity"))
                    {
                        mat.SetFloat("_EmissionIntensity", intensity);
                    }
                }
                renderer.materials = currentMaterials;
            }
        }

        private void UpdateLighting(GameObject character, CharacterDisplayState state)
        {
            float targetIntensity = (state == CharacterDisplayState.Hover || state == CharacterDisplayState.Selected)
                ? highlightIntensity : dimmedIntensity;

            var characterLights = character.GetComponentsInChildren<Light>();
            foreach (var light in characterLights)
            {
                light.intensity = targetIntensity;
            }
        }

        #endregion

        #region Spotlight Control

        /// <summary>
        /// Rotates the given spotlight to a target rotation over time.
        /// Adjust intensity, range, angle, etc. as needed.
        /// </summary>
        public async Task RotateSpotlight(Light spotlight, float targetRotation, float duration)
        {
            if (spotlight == null) return;

            try
            {
                Vector3 currentRotation = spotlight.transform.localEulerAngles;
                Vector3 targetRotationVector = new Vector3(currentRotation.x, targetRotation, currentRotation.z);

                await spotlight.transform
                    .DOLocalRotate(targetRotationVector, duration)
                    .SetEase(Ease.InOutQuad)
                    .AsyncWaitForCompletion();

                spotlight.intensity = spotlightIntensity;
                spotlight.range = spotlightRange;
                spotlight.spotAngle = spotlightAngle;
            }
            catch (Exception e)
            {
                Debug.LogError($"[CharacterDisplayManager] Failed to rotate spotlight: {e.Message}");
            }
        }

        #endregion

        #region Cleanup

        /// <summary>
        /// Clears all cached character data and resets internal state.
        /// </summary>
        public void Cleanup()
        {
            characterAnimators.Clear();
            characterRenderers.Clear();
            originalMaterials.Clear();
            isInitialized = false;
        }

        protected override void OnManagerDestroyed()
        {
            base.OnManagerDestroyed();
            Cleanup();
        }

        #endregion
    }

    /// <summary>
    /// Defines display states used by CharacterDisplayManager.
    /// Typically, "Locked" is used if the character is not unlocked in the profile.
    /// </summary>
    public enum CharacterDisplayState
    {
        Hidden,
        Locked,
        Idle,
        Hover,
        Selected
    }
}

// --- END FILE ---

// File: Characters/Logic/CharacterPointerHandler.cs
// Size: 4006 characters
// ---
using UnityEngine;
using UnityEngine.EventSystems;
using CyberPickle.Core.Events;

namespace CyberPickle.Characters.Logic
{
    /// <summary>
    /// Handles pointer interactions with character models in the selection screen.
    /// Requires a BoxCollider component for physics raycasting.
    /// </summary>
    [RequireComponent(typeof(BoxCollider))]
    public class CharacterPointerHandler : MonoBehaviour,
        IPointerEnterHandler,
        IPointerExitHandler,
        IPointerClickHandler
    {
        private BoxCollider pointerCollider;
        private string characterId;
        private bool isInteractable = true;

        private void Awake()
        {
            Debug.Log($"[CharacterPointerHandler] Initializing for GameObject: {gameObject.name}");

            pointerCollider = GetComponent<BoxCollider>();
            if (pointerCollider == null)
            {
                pointerCollider = gameObject.AddComponent<BoxCollider>();
                pointerCollider.size = new Vector3(2f, 4f, 2f);
                pointerCollider.center = new Vector3(0f, 2f, 0f);
                pointerCollider.isTrigger = true;
                Debug.Log($"[CharacterPointerHandler] Added BoxCollider to {gameObject.name}");
            }
        }

        /// <summary>
        /// Sets up character-specific data.
        /// </summary>
        public void Initialize(string charId)
        {
            characterId = charId;
            Debug.Log($"[CharacterPointerHandler] Initialized for character: {characterId}");
        }

        /// <summary>
        /// Enables or disables pointer interactions with the character.
        /// </summary>
        /// <param name="interactable">Whether the character should respond to pointer events.</param>
        /// <param name="allowHover">If false, hover events are also disabled.</param>
        public void SetInteractable(bool interactable, bool allowHover = true)
        {
            isInteractable = interactable;
            // If we only want hover, we keep the collider as a trigger but block clicks
            pointerCollider.isTrigger = !interactable || allowHover;
            Debug.Log($"[CharacterPointerHandler] Interactable set to {interactable}, AllowHover: {allowHover}");
        }

        public bool IsInteractable => isInteractable;

        public void OnPointerEnter(PointerEventData eventData)
        {
            Debug.Log($"[CharacterPointerHandler] POINTER ENTER - {characterId}");
            GameEvents.OnCharacterHoverEnter?.Invoke(characterId);
        }

        public void OnPointerExit(PointerEventData eventData)
        {
            Debug.Log($"[CharacterPointerHandler] POINTER EXIT - {characterId}");
            if (!isInteractable) return;
            GameEvents.OnCharacterHoverExit?.Invoke(characterId);
        }

        public void OnPointerClick(PointerEventData eventData)
        {
            Debug.Log($"[CharacterPointerHandler] POINTER CLICK - {characterId}, Button: {eventData.button}");
            if (!isInteractable) return;

            switch (eventData.button)
            {
                case PointerEventData.InputButton.Left:
                    GameEvents.OnCharacterSelected?.Invoke(characterId);
                    break;
                case PointerEventData.InputButton.Right:
                    GameEvents.OnCharacterDetailsRequested?.Invoke(characterId);
                    break;
            }
        }

        /// <summary>
        /// Adjusts the collider size at runtime to match character model scale.
        /// </summary>
        public void AdjustColliderSize(Vector3 size, Vector3 center)
        {
            if (pointerCollider == null) return;
            pointerCollider.size = size;
            pointerCollider.center = center;
            Debug.Log($"[CharacterPointerHandler] Adjusted collider size for {characterId}");
        }
    }
}

// --- END FILE ---

// File: Characters/Logic/CharacterSelectionManager.cs
// Size: 21019 characters
// ---
using UnityEngine;
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using CyberPickle.Core.Management;
using CyberPickle.Core.Events;
using CyberPickle.Core.States;
using CyberPickle.Core.Camera;
using CyberPickle.Core.Services.Authentication;
using CyberPickle.Core.Services.Authentication.Data;
using CyberPickle.Characters.Data;
using CyberPickle.Characters.UI;     // For CharacterUIManager
using DG.Tweening;
using System.Collections;

namespace CyberPickle.Characters.Logic
{
    /// <summary>
    /// Manages the character selection flow: spawns characters, checks unlock status,
    /// updates display states, and coordinates with UI/Display managers. 
    /// </summary>
    public class CharacterSelectionManager : Manager<CharacterSelectionManager>
    {
        [Header("Scene References")]
        [SerializeField] private Transform[] characterPositions;
        [SerializeField] private Light spotLight;

        [Header("Character References")]
        [SerializeField] private CharacterData[] availableCharacters;

        [Header("Managers")]
        [SerializeField] private CharacterDisplayManager displayManager;
        [SerializeField] private CharacterUIManager uiManager;

        [Header("Camera Focus Settings")]
        [SerializeField] private Vector3 cameraFocusOffset = new Vector3(0, 2, -3);
        [SerializeField] private float cameraFocusFieldOfView = 40f;
        [SerializeField] private float focusTransitionDuration = 1f;
        [SerializeField] private float focusDistance = -5f;
        [SerializeField] private float focusHeightOffset = 0f;
        [SerializeField] private float lookOffset = 2f;
        [SerializeField] private float panelTransitionDuration = 0.8f; // add to the top
        [SerializeField] private float defaultFieldOfView = 60f; // fallback FOV

        // Core references
        private ProfileManager profileManager;
        private CameraManager cameraManager;
        private Coroutine spotlightFollowCoroutine;
        // State
        private Dictionary<string, GameObject> spawnedCharacters = new Dictionary<string, GameObject>();
        private Dictionary<string, CharacterDisplayState> characterStates = new Dictionary<string, CharacterDisplayState>();
        private string currentlySelectedCharacterId;
        private string currentlyHoveredCharacterId;
        private bool isTransitioning;
        private bool cameraFocused;

        #region Manager Overrides

        protected override void OnManagerAwake()
        {
            base.OnManagerAwake();
            if (!ValidateManagers()) return;
            displayManager.Initialize();
            InitializeEvents();
        }

        protected override void OnManagerDestroyed()
        {
            base.OnManagerDestroyed();
            CleanupEvents();
            CleanupCharacterSelection();
        }

        #endregion

        #region Initialization

        private bool ValidateManagers()
        {
            profileManager = ProfileManager.Instance;
            cameraManager = CameraManager.Instance;

            bool valid = true;
            if (!profileManager) { Debug.LogError("[CharacterSelectionManager] Missing ProfileManager"); valid = false; }
            if (!cameraManager) { Debug.LogError("[CharacterSelectionManager] Missing CameraManager"); valid = false; }
            if (!displayManager) { Debug.LogError("[CharacterSelectionManager] Missing DisplayManager"); valid = false; }
            if (!uiManager) { Debug.LogError("[CharacterSelectionManager] Missing UIManager"); valid = false; }
            if (characterPositions == null || characterPositions.Length == 0)
            {
                Debug.LogError("[CharacterSelectionManager] No character positions assigned!");
                valid = false;
            }
            if (availableCharacters == null || availableCharacters.Length == 0)
            {
                Debug.LogError("[CharacterSelectionManager] No available characters configured!");
                valid = false;
            }
            return valid;
        }

        private void InitializeEvents()
        {
            GameEvents.OnGameStateChanged.AddListener(HandleGameStateChanged);
            GameEvents.OnCharacterHoverEnter.AddListener(HandleCharacterHoverEnter);
            GameEvents.OnCharacterHoverExit.AddListener(HandleCharacterHoverExit);
            GameEvents.OnCharacterSelected.AddListener(HandleCharacterSelected);
            GameEvents.OnCharacterDetailsRequested.AddListener(HandleCharacterDetails);
            GameEvents.OnCharacterSelectionCancelled.AddListener(HandleSelectionCancelled);
            GameEvents.OnCharacterConfirmed.AddListener(HandleCharacterConfirmed);
            Debug.Log("[CharacterSelectionManager] Events subscribed.");
        }

        private void CleanupEvents()
        {
            GameEvents.OnGameStateChanged.RemoveListener(HandleGameStateChanged);
            GameEvents.OnCharacterHoverEnter.RemoveListener(HandleCharacterHoverEnter);
            GameEvents.OnCharacterHoverExit.RemoveListener(HandleCharacterHoverExit);
            GameEvents.OnCharacterSelected.RemoveListener(HandleCharacterSelected);
            GameEvents.OnCharacterDetailsRequested.RemoveListener(HandleCharacterDetails);
            GameEvents.OnCharacterSelectionCancelled.RemoveListener(HandleSelectionCancelled);
            GameEvents.OnCharacterConfirmed.RemoveListener(HandleCharacterConfirmed);
            Debug.Log("[CharacterSelectionManager] Events unsubscribed.");
        }

        #endregion

        #region GameState Handling

        private void HandleGameStateChanged(GameState newState)
        {
            switch (newState)
            {
                case GameState.CharacterSelect:
                    InitializeCharacterSelection();
                    break;
                case GameState.LevelSelect:
                case GameState.MainMenu:
                    CleanupCharacterSelection();
                    break;
            }
        }

        /// <summary>
        /// Spawns and sets up all characters for selection.
        /// </summary>
        private async void InitializeCharacterSelection()
        {
            if (profileManager?.ActiveProfile == null)
            {
                Debug.LogError("[CharacterSelectionManager] No active profile, cannot init character selection.");
                return;
            }


            isTransitioning = true;
            CleanupCharacterSelection();

            // Actually spawn each character
            for (int i = 0; i < availableCharacters.Length; i++)
            {
                var cData = availableCharacters[i];
                GameObject instance = await displayManager.SpawnCharacter(
                    cData, characterPositions[i].position, characterPositions[i].rotation
                );

                if (!instance) continue;

                // Layer and name
                instance.layer = LayerMask.NameToLayer("Character");
                // Set pointer handler
                var pointerHandler = instance.GetComponent<CharacterPointerHandler>();
                if (pointerHandler == null)
                {
                    pointerHandler = instance.AddComponent<CharacterPointerHandler>();
                }
                pointerHandler.Initialize(cData.characterId);

                // Store references
                spawnedCharacters[cData.characterId] = instance;

                // Determine initial display state
                bool unlocked = IsCharacterUnlocked(cData.characterId);
                characterStates[cData.characterId] = unlocked ? CharacterDisplayState.Idle : CharacterDisplayState.Locked;

                // Let pointer handler block clicks if locked
                pointerHandler.SetInteractable(unlocked, allowHover: true);
                // Update visuals
                displayManager.UpdateCharacterState(instance, characterStates[cData.characterId]);
            }

            // Pass data to UI manager
            uiManager.Initialize(availableCharacters);

            isTransitioning = false;
        }

        private void CleanupCharacterSelection()
        {
            foreach (var characterGO in spawnedCharacters.Values)
            {
                if (characterGO) Destroy(characterGO);
            }
            spawnedCharacters.Clear();
            characterStates.Clear();

            // Reset local state
            currentlySelectedCharacterId = null;
            currentlyHoveredCharacterId = null;
            cameraFocused = false;
            isTransitioning = false;

            // UI cleanup
            uiManager?.Cleanup();
        }

        #endregion

        #region Character Unlock / Profile

        public bool IsCharacterUnlocked(string characterId)
        {
            if (string.IsNullOrEmpty(characterId)) return false;
            var cData = Array.Find(availableCharacters, c => c.characterId == characterId);
            if (!cData) return false;

            // If unlocked by default
            if (cData.unlockedByDefault) return true;

            // Check profile data
            var profile = profileManager?.ActiveProfile;
            if (profile?.CharacterProgress == null) return false;
            return profile.CharacterProgress.ContainsKey(characterId);
        }

        #endregion

        #region Hover / Selection Event Handlers

        /// <summary>
        /// Pointer hovers over a character.
        /// </summary>
        private void HandleCharacterHoverEnter(string characterId)
        {
            if (spotlightFollowCoroutine != null) StopCoroutine(spotlightFollowCoroutine);
            var characterTransform = spawnedCharacters[characterId].transform;
            spotlightFollowCoroutine = StartCoroutine(SmoothlyTrackCharacter(characterTransform));

            if (isTransitioning || cameraFocused) return;

            currentlyHoveredCharacterId = characterId;
            if (!spawnedCharacters.TryGetValue(characterId, out var characterGO)) return;

            bool unlocked = IsCharacterUnlocked(characterId);
            characterStates[characterId] = CharacterDisplayState.Hover;
            displayManager.UpdateCharacterState(characterGO, characterStates[characterId]);

            // Show the preview or unlock panel
            var cData = Array.Find(availableCharacters, c => c.characterId == characterId);
            uiManager.ShowCharacterPreview(cData, unlocked);

            // <--- CRITICAL: position the hover panel over the correct character
            uiManager.UpdatePanelPositions(characterGO.transform);
        }

        private IEnumerator SmoothlyTrackCharacter(Transform characterRootTransform) // Parameter is the root transform of the character
        {
            if (characterRootTransform == null)
            {
                Debug.LogError("[CharacterSelectionManager] SmoothlyTrackCharacter: characterRootTransform is null.");
                yield break;
            }

            SkinnedMeshRenderer smr = characterRootTransform.GetComponentInChildren<SkinnedMeshRenderer>();

            if (smr == null)
            {
                Debug.LogWarning($"[CharacterSelectionManager] No SkinnedMeshRenderer found on '{characterRootTransform.name}' or its children. Spotlight will track the root transform's position. Animation movement might not be followed.");
                // Fallback to tracking the root transform's position if no SkinnedMeshRenderer is found
                while (true)
                {
                    if (!characterRootTransform.gameObject.activeInHierarchy) yield break; // Stop if character is destroyed

                    Vector3 targetPos = characterRootTransform.position + Vector3.up * 1.5f; // offset above character's feet
                    Quaternion targetRotation = Quaternion.LookRotation(targetPos - spotLight.transform.position);
                    spotLight.transform.rotation = Quaternion.Slerp(spotLight.transform.rotation, targetRotation, Time.deltaTime * 5f); // Increased Slerp speed slightly
                    yield return null;
                }
            }
            else
            {
                // Track the center of the SkinnedMeshRenderer's bounds
                while (true)
                {
                    if (!smr.gameObject.activeInHierarchy) yield break; // Stop if character is destroyed or SMR becomes inactive

                    Vector3 targetPos = smr.bounds.center; // This gives the world space center of the renderer's bounding box
                                                           // You might want a slight upward offset from the bounds.center if it's too low
                                                           // targetPos += Vector3.up * 0.2f; // Example offset, adjust as needed

                    Quaternion targetRotation = Quaternion.LookRotation(targetPos - spotLight.transform.position);
                    spotLight.transform.rotation = Quaternion.Slerp(spotLight.transform.rotation, targetRotation, Time.deltaTime * 5f); // Increased Slerp speed slightly for responsiveness
                    yield return null;
                }
            }
        }

        /// <summary>
        /// Pointer no longer hovering over a character.
        /// </summary>
        private void HandleCharacterHoverExit(string characterId)
        {
            if (!spawnedCharacters.ContainsKey(characterId)) return;

            bool unlocked = IsCharacterUnlocked(characterId);
            characterStates[characterId] = unlocked ? CharacterDisplayState.Idle : CharacterDisplayState.Locked;

            displayManager.UpdateCharacterState(spawnedCharacters[characterId], characterStates[characterId]);
            uiManager.HideUnlockPanel();
            currentlyHoveredCharacterId = null;
        }

        /// <summary>
        /// Left click on character => select the character.
        /// </summary>
        private async void HandleCharacterSelected(string characterId)
        {
            // Guard clauses
            if (isTransitioning || !spawnedCharacters.ContainsKey(characterId)) return;
            if (!IsCharacterUnlocked(characterId)) return;

            isTransitioning = true;

            // If there's already a panel visible for another character, hide it immediately
            // so we don't see the old overhead tween from the previous character to the new one.
            uiManager.HideAllPanelsImmediate();

            currentlySelectedCharacterId = characterId;

            // Visually mark as selected
            characterStates[characterId] = CharacterDisplayState.Selected;
            displayManager.UpdateCharacterState(spawnedCharacters[characterId], CharacterDisplayState.Selected);

            // Grab transform for positioning
            var charTransform = spawnedCharacters[characterId].transform;

            // Fire off two asynchronous tasks in parallel:

            // 1) Camera focusing task
            var cameraTask = cameraManager.FocusCameraOnCharacter(
                charTransform,
                focusHeightOffset,
                focusDistance,
                focusTransitionDuration,
                cameraFocusFieldOfView,
                lookOffset
            );

            // 2) Panel animation task (first show details text, then slide/scale to left side)
            var cData = Array.Find(availableCharacters, c => c.characterId == characterId);
            uiManager.ShowDetails(cData);  // sets text/lore but doesn't do overhead offset
            var panelTask = uiManager.AnimatePanelToFocusedPosition(charTransform, panelTransitionDuration);

            // Wait for both the camera and panel animations to finish
            await Task.WhenAll(cameraTask, panelTask);

            // Now that both are done, show the confirmation panel on top
            uiManager.ShowConfirmationPanel(true);

            // Ensure the confirmation panel (and others) remain positioned correctly
            uiManager.UpdatePanelPositions(charTransform);

            cameraFocused = true;
            isTransitioning = false;
        }


        /// <summary>
        /// Right click => request details without fully selecting.
        /// </summary>
        private async void HandleCharacterDetails(string characterId)
        {
            if (isTransitioning || !IsCharacterUnlocked(characterId)) return;

            currentlyHoveredCharacterId = characterId;
            var cData = Array.Find(availableCharacters, c => c.characterId == characterId);
            uiManager.ShowDetails(cData);
            await uiManager.AnimatePanelOverheadPosition(spawnedCharacters[characterId].transform, 0.3f);
            // <--- CRITICAL: again, update panel position for the details panel
            if (spawnedCharacters.TryGetValue(characterId, out var characterGO))
            {
                uiManager.UpdatePanelPositions(characterGO.transform);
            }
        }

        /// <summary>
        /// The "Cancel" button or event was triggered.
        /// </summary>
        private async void HandleSelectionCancelled()
        {
            if (isTransitioning) return;
            isTransitioning = true;

            // Hide the confirmation panel right away
            uiManager.ShowConfirmationPanel(false);

            // If there's a currently selected character, we'll animate the panel + camera in parallel
            if (!string.IsNullOrEmpty(currentlySelectedCharacterId) &&
                spawnedCharacters.TryGetValue(currentlySelectedCharacterId, out var selectedGO))
            {
                // Kick off two async tasks in parallel:
                // 1) Panel returning overhead at full scale
                var overheadTask = uiManager.AnimatePanelReturnToOverhead(selectedGO.transform, 0.5f);

                // 2) Camera returning to wide âcharacter selectionâ view
                var cameraTask = cameraManager.ResetToCharacterSelectionView(focusTransitionDuration, defaultFieldOfView);

                // Wait for both to finish
                await Task.WhenAll(overheadTask, cameraTask);

                // Once both animations complete, reset display state to Idle/Locked
                bool unlocked = IsCharacterUnlocked(currentlySelectedCharacterId);
                characterStates[currentlySelectedCharacterId] = unlocked ? CharacterDisplayState.Idle : CharacterDisplayState.Locked;
                displayManager.UpdateCharacterState(selectedGO, characterStates[currentlySelectedCharacterId]);
            }
            else
            {
                // If there's no selected character, we only need to reset the camera
                await cameraManager.ResetToCharacterSelectionView(focusTransitionDuration, defaultFieldOfView);
            }

            currentlySelectedCharacterId = null;
            cameraFocused = false;
            isTransitioning = false;
        }



        /// <summary>
        /// The "Confirm" button was pressed => finalize selection.
        /// </summary>
        private async void HandleCharacterConfirmed()
        {
            if (string.IsNullOrEmpty(currentlySelectedCharacterId)) return;

            // Mark selection in profile if needed
            var profile = profileManager?.ActiveProfile;
            if (profile != null)
            {
                // For example: "profile.LastSelectedCharacterId = currentlySelectedCharacterId;"
                await profileManager.UpdateProfileAsync(profile);
            }

            // Hide UI, go to next state
            uiManager.ShowConfirmationPanel(false);
            uiManager.HideAllPanels();

            // Switch game state to level select
            GameEvents.OnGameStateChanged.Invoke(GameState.LevelSelect);
        }

        #endregion

        #region External Helpers

        /// <summary>
        /// For external checks: is a character ID currently selected?
        /// </summary>
        public bool IsCharacterSelected(string characterId)
        {
            return (characterId == currentlySelectedCharacterId);
        }

        /// <summary>
        /// If other scripts need the actual character instance.
        /// </summary>
        public GameObject GetCharacterGameObject(string characterId)
        {
            spawnedCharacters.TryGetValue(characterId, out var result);
            return result;
        }

        #endregion
    }
}

// --- END FILE ---

// File: Characters/UI/CharacterUIManager.cs
// Size: 19357 characters
// ---
using UnityEngine;
using UnityEngine.UI;
using TMPro;
using System.Collections.Generic;
using CyberPickle.Core.Management;
using CyberPickle.Core.Services.Authentication;
using CyberPickle.Characters.Data;
using DG.Tweening;
using CyberPickle.Core.Services.Authentication.Data;
using CyberPickle.Core.Events;
using System.Threading.Tasks;

namespace CyberPickle.Characters.UI
{
    /// <summary>
    /// Manages UI elements for character selection: hover panel, details panel,
    /// unlock requirements, and confirmation prompts.
    /// Only responsible for UI feedback/animationsï¿½logic or selection rules
    /// live in other managers.
    /// </summary>
    public class CharacterUIManager : Manager<CharacterUIManager>
    {
        [Header("Details Panel")]
        [SerializeField] private CanvasGroup detailsPanel;
        [SerializeField] private TextMeshProUGUI detailsCharacterNameText;
        [SerializeField] private TextMeshProUGUI levelText;
        [SerializeField] private Transform statsContainer;
        [SerializeField] private TextMeshProUGUI loreText;
        [SerializeField] private GameObject statRowPrefab;

        [Header("Hover Panel")]
        [SerializeField] private CanvasGroup hoverPanel;
        [SerializeField] private TextMeshProUGUI hoverCharacterNameText;
        [SerializeField] private GameObject leftClickPrompt;
        [SerializeField] private GameObject rightClickPrompt;

        [Header("Unlock Panel")]
        [SerializeField] private CanvasGroup unlockPanel;
        [SerializeField] private TextMeshProUGUI unlockRequirementsText;

        [Header("Confirm Selection Panel")]
        [SerializeField] private CanvasGroup confirmationPanelPrefab; // Prefab reference
        private CanvasGroup confirmationPanel; // Runtime reference

        [Header("Animation Settings")]
        [SerializeField] private float panelFadeDuration = 0.3f;
        [SerializeField] private float statUpdateDuration = 0.5f;
        [SerializeField] private float panelTransitionDuration = 0.8f;
        
        [Header("Positioning")]
        [SerializeField] private Vector3 hoverPanelOffset = new Vector3(0, 2, 0);
        [SerializeField] private Vector3 detailsPanelOffsetGeneral = new Vector3(2, 1, 0);
        [SerializeField] private Vector3 detailsPanelOffsetFocused = new Vector3(-1, 0, 0);
        [SerializeField] private Vector3 confirmationPanelOffset = new Vector3(0, 2, 0);

        // Dependencies
        private ProfileManager profileManager;

        // State
        private string currentCharacterId;
        private Dictionary<string, TextMeshProUGUI> statTextCache;
        private Dictionary<string, CharacterProgressionData> progressionCache;

        #region Manager Overrides

        protected override void OnManagerAwake()
        {
            base.OnManagerAwake();
            profileManager = ProfileManager.Instance;  // if needed for progression
            ValidateReferences();
            InitializeCache();
        }

        protected override void OnManagerDestroyed()
        {
            base.OnManagerDestroyed();
            Cleanup();
        }

        #endregion

        #region Initialization

        private void ValidateReferences()
        {
            if (!detailsPanel) Debug.LogError("[CharacterUIManager] Details panel is missing!");
            if (!hoverPanel) Debug.LogError("[CharacterUIManager] Hover panel is missing!");
            if (!unlockPanel) Debug.LogError("[CharacterUIManager] Unlock panel is missing!");
            if (!statsContainer) Debug.LogError("[CharacterUIManager] Stats container is missing!");
            if (!statRowPrefab) Debug.LogError("[CharacterUIManager] Stat row prefab is missing!");
        }

        private void InitializeCache()
        {
            statTextCache = new Dictionary<string, TextMeshProUGUI>();
            progressionCache = new Dictionary<string, CharacterProgressionData>();
            HideAllPanelsImmediate();
        }

        /// <summary>
        /// Called externally once. Prepares progression data if needed, etc.
        /// </summary>
        public void Initialize(CharacterData[] characters)
        {
            ClearUI();
            foreach (var character in characters)
            {
                if (character != null)
                {
                    progressionCache[character.characterId] = GetCharacterProgression(character.characterId);
                }
            }
            Debug.Log($"[CharacterUIManager] Initialized with {characters.Length} characters");
        }

        #endregion

        #region Public UI Handling

        /// <summary>
        /// Updates the panel positions relative to the given character's transform.
        /// Should be called each frame or on hover/selection changes.
        /// </summary>
        public void UpdatePanelPositions(Transform characterPosition)
        {
            if (!characterPosition) return;

            // Keep the hover/unlock/confirmation panels updated if you like
            if (hoverPanel)
            {
                hoverPanel.transform.position = characterPosition.position + hoverPanelOffset;
            }

            if (unlockPanel)
            {
                unlockPanel.transform.position = characterPosition.position + hoverPanelOffset;
            }

            if (confirmationPanel)
            {
                confirmationPanel.transform.position = characterPosition.position + confirmationPanelOffset;
            }

            // SKIP MOVING THE DETAILS PANEL HERE, to avoid overriding the tween
        }

        /// <summary>
        /// Shows the hover panel or unlock panel depending on unlock status.
        /// </summary>
        public void ShowCharacterPreview(CharacterData character, bool isUnlocked)
        {
            if (!character) return;
            currentCharacterId = character.characterId;

            // Reset panels first
            HideAllPanelsImmediate();

            if (hoverCharacterNameText) hoverCharacterNameText.text = character.displayName;
            if (leftClickPrompt) leftClickPrompt.SetActive(isUnlocked);
            if (rightClickPrompt) rightClickPrompt.SetActive(isUnlocked);

            // Show hover panel if unlocked, else show unlock requirements
            if (isUnlocked)
            {
                SetPanelState(hoverPanel, true);
            }
            else
            {
                ShowUnlockRequirements(character);
            }
        }

        /// <summary>
        /// Fills and shows the character details panel: name, lore, stats, etc.
        /// </summary>
        public void ShowDetails(CharacterData character)
        {
            if (!character) return;
            currentCharacterId = character.characterId;

            if (detailsCharacterNameText) detailsCharacterNameText.text = character.displayName;
            if (loreText) loreText.text = character.lore;

            var progression = progressionCache.TryGetValue(character.characterId, out var cachedProg)
                ? cachedProg
                : GetCharacterProgression(character.characterId);

            if (levelText && progression != null)
            {
                levelText.text = $"Level {progression.CharacterLevel}";
            }

            UpdateCharacterStats(character, progression);
            SetPanelState(detailsPanel, true);

            // Hide other panels
            SetPanelState(hoverPanel, false);
            SetPanelState(unlockPanel, false);
        }

        /// <summary>
        /// Displays the confirmation panel prefab for final selection,
        /// or hides it if show=false.
        /// </summary>
        public void ShowConfirmationPanel(bool show)
        {
            if (!show)
            {
                if (confirmationPanel)
                {
                    var buttons = confirmationPanel.GetComponentsInChildren<Button>();
                    foreach (var b in buttons) b.onClick.RemoveAllListeners();
                    Destroy(confirmationPanel.gameObject);
                    confirmationPanel = null;
                }
                return;
            }

            if (!confirmationPanel && confirmationPanelPrefab)
            {
                var instance = Instantiate(confirmationPanelPrefab, hoverPanel.transform.parent);
                confirmationPanel = instance.GetComponent<CanvasGroup>();

                // Positioning
                if (confirmationPanel)
                {
                    SetPanelState(confirmationPanel, true);
                }

                // Hook up confirm/cancel buttons
                var buttons = instance.GetComponentsInChildren<Button>();
                foreach (var button in buttons)
                {
                    button.onClick.RemoveAllListeners(); // clear existing
                    if (button.gameObject.name.Contains("Confirm"))
                    {
                        button.onClick.AddListener(() => GameEvents.OnCharacterConfirmed?.Invoke());
                    }
                    else if (button.gameObject.name.Contains("Cancel"))
                    {
                        button.onClick.AddListener(() => GameEvents.OnCharacterSelectionCancelled?.Invoke());
                    }
                }
            }
            else if (confirmationPanel)
            {
                confirmationPanel.gameObject.SetActive(true);
                SetPanelState(confirmationPanel, true);
            }
        }

        /// <summary>
        /// Displays requirements for locked characters.
        /// </summary>
        public void ShowUnlockRequirements(CharacterData character)
        {
            if (!unlockRequirementsText) return;
            string requirements = "Requirements to unlock:\n";

            if (character.requiredPlayerLevel > 1)
            {
                requirements += $"ï¿½ Level {character.requiredPlayerLevel}\n";
            }
            if (character.requiredAchievements != null && character.requiredAchievements.Length > 0)
            {
                foreach (var ach in character.requiredAchievements)
                {
                    requirements += $"ï¿½ {ach}\n";
                }
            }

            unlockRequirementsText.text = requirements;
            SetPanelState(unlockPanel, true);
        }

        /// <summary>
        /// Hides the Unlock Panel specifically.
        /// </summary>
        public void HideUnlockPanel()
        {
            SetPanelState(unlockPanel, false);
        }

        /// <summary>
        /// Hides all panels gracefully with a fade out (async).
        /// </summary>
        public async void HideAllPanels()
        {
            SetPanelState(hoverPanel, false);
            SetPanelState(unlockPanel, false);
            await AnimatePanelExit(panelTransitionDuration);  // fade out details
        }

        /// <summary>
        /// Immediately hides all panels (no fade).
        /// </summary>
        public void HideAllPanelsImmediate()
        {
            if (hoverPanel) hoverPanel.alpha = 0f;
            if (unlockPanel) unlockPanel.alpha = 0f;
            if (detailsPanel) detailsPanel.alpha = 0f;

            if (hoverPanel) hoverPanel.gameObject.SetActive(false);
            if (unlockPanel) unlockPanel.gameObject.SetActive(false);
            if (detailsPanel) detailsPanel.gameObject.SetActive(false);
        }

        /// <summary>
        /// Updates progression data for the given character.
        /// </summary>
        public void UpdateCharacterProgress(string characterId, CharacterProgressionData progression)
        {
            if (string.IsNullOrEmpty(characterId) || progression == null) return;
            progressionCache[characterId] = progression;

            // If currently showing that character, update stats
            if (characterId == currentCharacterId)
            {
                // We need the base data, typically from outside
                // e.g. CharacterSelectionManager or somewhere else
                // For now, we do a debug check
                Debug.Log($"[CharacterUIManager] UpdateCharacterProgress called for {characterId}, but base data not re-fetched here.");
            }
        }

        public async Task AnimatePanelToFocusedPosition(Transform characterTransform, float duration)
        {
            if (!detailsPanel || !characterTransform) return;

            // Ensure it's visible
            detailsPanel.gameObject.SetActive(true);
            SetPanelState(detailsPanel, true);

            Vector3 targetPos = characterTransform.position + detailsPanelOffsetFocused;

            // Tween in world space
            detailsPanel.transform.DOMove(targetPos, duration)
                .SetEase(Ease.InOutQuad)
                .SetUpdate(true);

            // Scale to half
            detailsPanel.transform.DOScale(Vector3.one * 0.5f, duration)
                .SetEase(Ease.InOutQuad);

            await detailsPanel.transform
                .DOMove(targetPos, duration)
                .AsyncWaitForCompletion();
        }

        public async Task AnimatePanelReturnToOverhead(Transform characterTransform, float duration)
        {
            // Exactly the same logic as AnimatePanelOverheadPosition, 
            // but some devs prefer a separate name for clarity.
            await AnimatePanelOverheadPosition(characterTransform, duration);
        }

        /// <summary>
        /// Animates the details panel off-screen, then hides it.
        /// </summary>
        public async Task AnimatePanelExit(float duration)
        {
            if (!detailsPanel) return;

            Sequence seq = DOTween.Sequence();
            seq.Append(detailsPanel.DOFade(0f, duration).SetEase(Ease.InOutQuad));
            seq.Join(detailsPanel.transform.DOLocalMoveY(detailsPanel.transform.position.y - 200f, duration)
                .SetEase(Ease.InOutQuad));
            await seq.AsyncWaitForCompletion();

            detailsPanel.gameObject.SetActive(false);
        }

        /// <summary>
        /// Clears all UI and data references.
        /// </summary>
        public void Cleanup()
        {
            ClearUI();
            if (confirmationPanel)
            {
                var buttons = confirmationPanel.GetComponentsInChildren<Button>();
                foreach (var b in buttons) b.onClick.RemoveAllListeners();
                Destroy(confirmationPanel.gameObject);
                confirmationPanel = null;
            }
            progressionCache.Clear();
        }

        #endregion

        #region Private Helpers

        private CharacterProgressionData GetCharacterProgression(string characterId)
        {
            if (string.IsNullOrEmpty(characterId) || profileManager == null) return null;
            var profile = profileManager.ActiveProfile;
            if (profile?.CharacterProgress == null) return null;

            profile.CharacterProgress.TryGetValue(characterId, out var prog);
            return prog;
        }

        /// <summary>
        /// Animates the details panel above the character's head (general/preview),
        /// at full scale (Vector3.one).
        /// </summary>
        public async Task AnimatePanelOverheadPosition(Transform characterTransform, float duration)
        {
            if (!detailsPanel || !characterTransform) return;

            // Make sure it's active and visible
            detailsPanel.gameObject.SetActive(true);
            SetPanelState(detailsPanel, true);

            // Overhead position in *world* coordinates
            Vector3 targetPos = characterTransform.position + detailsPanelOffsetGeneral;

            // Move in world space:
            detailsPanel.transform.DOMove(targetPos, duration)
                .SetEase(Ease.InOutQuad)
                .SetUpdate(true);

            // Scale to normal size:
            detailsPanel.transform.DOScale(Vector3.one, duration)
                .SetEase(Ease.InOutQuad);

            // Wait for the movement to complete
            await detailsPanel.transform
                .DOMove(targetPos, duration)
                .AsyncWaitForCompletion();
        }

        


        private void SetPanelState(CanvasGroup panel, bool visible)
        {
            if (!panel) return;
            panel.gameObject.SetActive(true);

            panel.DOFade(visible ? 1f : 0f, panelFadeDuration)
                .OnComplete(() =>
                {
                    // After fade out, disable object if needed
                    if (!visible) panel.gameObject.SetActive(false);
                });
            panel.interactable = visible;
            panel.blocksRaycasts = visible;
        }

        private void UpdateCharacterStats(CharacterData baseData, CharacterProgressionData progression)
        {
            ClearStatsContainer();

            // Example stats we show:
            CreateStatRow("Health", baseData.maxHealth, progression);
            CreateStatRow("Defense", baseData.defense, progression);
            CreateStatRow("Power", baseData.power, progression);
            CreateStatRow("Speed", baseData.speed, progression);
            CreateStatRow("Dexterity", baseData.dexterity, progression);
            CreateStatRow("Luck", baseData.luck, progression);
        }

        private void CreateStatRow(string statName, float baseValue, CharacterProgressionData progression)
        {
            if (!statRowPrefab || !statsContainer) return;

            var row = Instantiate(statRowPrefab, statsContainer);
            var texts = row.GetComponentsInChildren<TextMeshProUGUI>();
            if (texts.Length < 2) return;

            texts[0].text = statName;
            texts[1].text = baseValue.ToString("F1");

            string statKey = $"{currentCharacterId}_{statName}";
            statTextCache[statKey] = texts[1];

            if (progression?.Stats != null && progression.Stats.TryGetValue(statName, out float progressedValue))
            {
                // Animate from baseValue to progressedValue
                DOTween.To(
                    () => baseValue,
                    v => texts[1].text = v.ToString("F1"),
                    progressedValue,
                    statUpdateDuration
                );
            }
        }

        private void ClearStatsContainer()
        {
            if (!statsContainer) return;
            foreach (Transform child in statsContainer)
            {
                Destroy(child.gameObject);
            }
            statTextCache.Clear();
        }

        private void ClearUI()
        {
            HideAllPanelsImmediate();
            ClearStatsContainer();
            currentCharacterId = null;
        }

        #endregion
    }
}

// --- END FILE ---

// File: Core/Analytics/AnalyticsManager.cs
// Size: 335 characters
// ---
using CyberPickle.Core.Management;
using CyberPickle.Core.Interfaces;

namespace CyberPickle.Core.Analytics
{
    public class AnalyticsManager : Manager<AnalyticsManager>, IInitializable
    {
        public void Initialize()
        {
            UnityEngine.Debug.Log("AnalyticsManager initialized");
        }
    }
}

// --- END FILE ---

// File: Core/Audio/AudioManager.cs
// Size: 356 characters
// ---
using CyberPickle.Core.Management;
using CyberPickle.Core.Interfaces;

namespace CyberPickle.Core.Audio
{
    public class AudioManager : Manager<AudioManager>, IInitializable
    {
        public void Initialize()
        {
            // Basic initialization
            UnityEngine.Debug.Log("AudioManager initialized");
        }
    }
}

// --- END FILE ---

// File: Core/Boot/BootManager.cs
// Size: 10456 characters
// ---
// File: Assets/Code/Core/Boot/BootManager.cs
//
// Purpose: Manages the game's boot sequence, initializing all core systems, services,
// and gameplay managers in the correct order while providing visual feedback.
//
// Created: 2024-02-11
// Updated: 2024-02-11

using UnityEngine;
using System.Collections;
using CyberPickle.Core.Management;
using CyberPickle.Core.Interfaces;
using CyberPickle.Core.Config;
using CyberPickle.Core.Boot.UI;
using CyberPickle.Core.Audio;
using CyberPickle.Core.SaveSystem;
using CyberPickle.Core.Input;
using CyberPickle.Core.Pool;
using CyberPickle.Core.Services.Authentication;
using CyberPickle.Core.Services.Leaderboard;
using CyberPickle.Core.Services.Steam;
using CyberPickle.Core.Analytics;
using CyberPickle.Characters;
using CyberPickle.Progression;
using CyberPickle.Achievements;
using UnityEngine.SceneManagement;
using CyberPickle.Core.Services.Authentication.Flow;



namespace CyberPickle.Core.Boot
{
    public class BootManager : Manager<BootManager>, IInitializable
    {
        [Header("UI")]
        [SerializeField] private BootUIController uiController;

        [Header("Timing")]
        [SerializeField] private float minimumLoadTime = 2f;
        [SerializeField] private float delayBeforeScene = 0.5f;

        private float startTime;
        private ConfigRegistry configRegistry;

        protected override void OnManagerAwake()
        {
            Debug.Log("<color=yellow>[BootManager] Awake called</color>");
            ValidateRequirements();
            startTime = Time.time;
            Initialize();
        }

        private void ValidateRequirements()
        {
            if (uiController == null)
            {
                throw new System.Exception("<color=red>[BootManager] UI Controller is not assigned!</color>");
            }
        }

        public void Initialize()
        {
            Debug.Log("<color=yellow>[BootManager] Starting initialize sequence...</color>");
            uiController.UpdateLoadingText("Starting initialization...");
            uiController.UpdateProgress(0f);
            StartCoroutine(InitializeGameSystems());
        }

        private IEnumerator InitializeGameSystems()
        {
            Debug.Log("<color=yellow>[BootManager] Starting initialization sequence...</color>");

            // Initialize ConfigRegistry first
            bool configSuccess = false;
            yield return StartCoroutine(InitializeConfigRegistry(success => configSuccess = success));

            if (!configSuccess)
            {
                Debug.LogError("<color=red>[BootManager] Failed to initialize configs. Aborting boot sequence.</color>");
                yield break;
            }

            // Initialize core systems
            yield return StartCoroutine(InitializeCore());

            // Initialize services
            yield return StartCoroutine(InitializeServices());

            // Initialize gameplay
            yield return StartCoroutine(InitializeGameplay());

            yield return StartCoroutine(CompleteInitialization());
        }

        // Custom class to handle initialization result
        private class ConfigInitializationResult : CustomYieldInstruction
        {
            public bool Success { get; private set; }

            public ConfigInitializationResult(bool success)
            {
                Success = success;
            }

            public override bool keepWaiting => false;
        }

        private IEnumerator InitializeConfigRegistry(System.Action<bool> onComplete)
        {
            uiController.UpdateLoadingText("Loading Configurations...");
            float progress = 0f;
            uiController.UpdateProgress(progress);

            configRegistry = ConfigRegistry.Instance;
            if (configRegistry == null)
            {
                Debug.LogError("<color=red>[BootManager] Failed to create ConfigRegistry!</color>");
                onComplete?.Invoke(false);
                yield break;
            }

            bool initComplete = false;
            bool initSuccess = false;

            // Start async initialization
            configRegistry.InitializeAsync().ContinueWith(task =>
            {
                initComplete = true;
                initSuccess = !task.IsFaulted;

                if (task.IsFaulted)
                {
                    Debug.LogError($"<color=red>[BootManager] Config initialization failed: {task.Exception.GetBaseException().Message}</color>");
                }
            }, System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext());

            // Show progress while waiting
            while (!initComplete)
            {
                progress = Mathf.PingPong(Time.time * 0.5f, 0.1f);
                uiController.UpdateProgress(progress);
                yield return null;
            }

            if (initSuccess)
            {
                Debug.Log("<color=green>[BootManager] Configurations loaded successfully!</color>");
                uiController.UpdateProgress(0.1f); // Move to 10% progress
            }

            onComplete?.Invoke(initSuccess);
        }

        private IEnumerator InitializeCore()
        {
            uiController.UpdateLoadingText("Initializing Core Systems...");
            float progressStart = 0.1f;
            float progressEnd = 0.4f;
            float step = (progressEnd - progressStart) / 4f;

            // Initialize Input Manager first
            yield return InitializeManager<InputManager>("Input System", progressStart, progressStart + step);

            // Then other systems
            yield return InitializeManager<AudioManager>("Audio System", progressStart + step, progressStart + (step * 2));
            yield return InitializeManager<SaveManager>("Save System", progressStart + (step * 2), progressStart + (step * 3));
            yield return InitializeManager<PoolManager>("Pool System", progressStart + (step * 3), progressEnd);
        }

        private IEnumerator InitializeServices()
        {
            uiController.UpdateLoadingText("Initializing Services...");
            float progressStart = 0.4f;
            float progressEnd = 0.7f;
            float step = (progressEnd - progressStart) / 5f;

            // Initialize AuthFlowManager first
            yield return InitializeManager<AuthenticationFlowManager>("Auth Flow", progressStart, progressStart + step);

            // Then the rest of the services
            yield return InitializeManager<AuthenticationManager>("Authentication", progressStart + step, progressStart + (step * 2));
            yield return InitializeManager<ProfileManager>("Profile Manager", progressStart + (step * 2), progressStart + (step * 3));
            yield return InitializeManager<LeaderboardManager>("Leaderboard", progressStart + (step * 3), progressStart + (step * 4));
            yield return InitializeManager<SteamManager>("Steam", progressStart + (step * 4), progressEnd);
            yield return InitializeManager<AnalyticsManager>("Analytics", progressStart + (step * 4), progressEnd);
        }

        private IEnumerator InitializeGameplay()
        {
            uiController.UpdateLoadingText("Initializing Gameplay Systems...");
            float progressStart = 0.7f;
            float progressEnd = 0.9f;
            float step = (progressEnd - progressStart) / 4f;

            yield return InitializeManager<GameManager>("Game System", progressStart, progressStart + step);
            yield return InitializeManager<CharacterManager>("Character System", progressStart + step, progressStart + (step * 2));
            yield return InitializeManager<ProgressionManager>("Progression System", progressStart + (step * 2), progressStart + (step * 3));
            yield return InitializeManager<AchievementManager>("Achievement System", progressStart + (step * 3), progressEnd);
        }

        private IEnumerator InitializeManager<M>(string systemName, float startProgress, float endProgress)
            where M : Manager<M>, IInitializable
        {
            Debug.Log($"<color=yellow>[BootManager] Initializing {systemName}...</color>");

            M manager = null;
            bool success = false;

            try
            {
                manager = Manager<M>.Instance;
                manager.Initialize();
                success = true;
                Debug.Log($"<color=green>[BootManager] {systemName} initialized successfully!</color>");
            }
            catch (System.Exception e)
            {
                Debug.LogError($"<color=red>[BootManager] Failed to initialize {systemName}: {e.Message}</color>");
                yield break;
            }

            if (success)
            {
                float elapsed = 0f;
                float duration = 0.5f;

                while (elapsed < duration)
                {
                    elapsed += Time.deltaTime;
                    float normalizedTime = elapsed / duration;
                    float currentProgress = Mathf.Lerp(startProgress, endProgress, normalizedTime);
                    uiController.UpdateProgress(currentProgress);
                    yield return null;
                }
            }
        }

        private IEnumerator CompleteInitialization()
        {
            uiController.UpdateLoadingText("Loading Complete");
            uiController.UpdateProgress(1f);

            // Ensure minimum display time
            float elapsedTime = Time.time - startTime;
            if (elapsedTime < minimumLoadTime)
            {
                yield return new WaitForSeconds(minimumLoadTime - elapsedTime);
            }

            yield return new WaitForSeconds(delayBeforeScene);

            // Get mainMenuSceneName from config
            var bootConfig = configRegistry.GetConfig<BootConfig>();
            LoadMainMenuScene(bootConfig.mainMenuSceneName);
        }

        private void LoadMainMenuScene(string sceneName)
        {
            Debug.Log($"<color=green>[BootManager] Loading main menu scene: {sceneName}</color>");
            SceneManager.LoadScene(sceneName);
        }
    }
}




// --- END FILE ---

// File: Core/Boot/BootSceneManager.cs
// Size: 6462 characters
// ---
using UnityEngine;
using UnityEngine.UI;
using TMPro;
using System.Collections;
using UnityEngine.SceneManagement;
using CyberPickle.Core.Management;

namespace CyberPickle.Core.Boot
{
    public class BootSceneManager : Manager<BootSceneManager>
    {
        [Header("UI References")]
        [SerializeField] private CanvasGroup logoCanvasGroup;
        [SerializeField] private TextMeshProUGUI companyNameText;
        [SerializeField] private Image loadingBarFill;
        [SerializeField] private TextMeshProUGUI loadingText;

        [Header("Animation Settings")]
        [SerializeField] private float fadeInDuration = 1.5f;
        [SerializeField] private float displayDuration = 2.0f;
        [SerializeField] private float fadeOutDuration = 1.5f;

        [Header("Scene Settings")]
        [SerializeField] private string mainMenuSceneName = "MainMenu";
        [SerializeField] private float minimumLoadingTime = 3.0f;
        [SerializeField] private bool waitForInput = true; // Add this to make input wait optional

        private float startTime;

        protected override void OnManagerAwake()
        {
            // Ensure canvas group starts invisible
            if (logoCanvasGroup != null)
                logoCanvasGroup.alpha = 0f;

            if (loadingBarFill != null)
                loadingBarFill.fillAmount = 0f;

            startTime = Time.time;
            StartCoroutine(BootSequence());
        }

        private IEnumerator BootSequence()
        {
            // Initial setup
            UpdateLoadingText("Initializing...");
            yield return StartCoroutine(FadeInLogo());

            // Core systems initialization
            yield return StartCoroutine(InitializeSystems());

            // Ensure minimum loading time
            float elapsedTime = Time.time - startTime;
            if (elapsedTime < minimumLoadingTime)
            {
                yield return new WaitForSeconds(minimumLoadingTime - elapsedTime);
            }

            // Display completion
            UpdateLoadingText("Press Any Key to Continue");

            // Wait for display duration
            yield return new WaitForSeconds(displayDuration);

            // Wait for input if enabled
            if (waitForInput)
            {
                yield return StartCoroutine(WaitForAnyKey());
            }

            // Transition out
            yield return StartCoroutine(FadeOutLogo());

            // Load main menu
            LoadMainMenu();
        }

        private IEnumerator WaitForAnyKey()
        {
            bool keyPressed = false;
            while (!keyPressed)
            {
                // Check for any key press or mouse click
                if (UnityEngine.Input.anyKeyDown || UnityEngine.Input.GetMouseButtonDown(0) || UnityEngine.Input.GetMouseButtonDown(1))
                {
                    keyPressed = true;
                }
                yield return null;
            }
        }

        private IEnumerator InitializeSystems()
        {
            float currentProgress = 0f;
            float targetProgress = 0.2f;

            // Audio System
            UpdateLoadingText("Initializing Audio System...");
            yield return StartCoroutine(UpdateProgressBar(currentProgress, targetProgress));
            currentProgress = targetProgress;
            targetProgress = 0.4f;

            // Save System
            UpdateLoadingText("Initializing Save System...");
            yield return StartCoroutine(UpdateProgressBar(currentProgress, targetProgress));
            currentProgress = targetProgress;
            targetProgress = 0.6f;

            // Input System
            UpdateLoadingText("Initializing Input System...");
            yield return StartCoroutine(UpdateProgressBar(currentProgress, targetProgress));
            currentProgress = targetProgress;
            targetProgress = 0.8f;

            // Game Systems
            UpdateLoadingText("Initializing Game Systems...");
            yield return StartCoroutine(UpdateProgressBar(currentProgress, targetProgress));
            currentProgress = targetProgress;
            targetProgress = 1f;

            // Final Setup
            UpdateLoadingText("Completing Setup...");
            yield return StartCoroutine(UpdateProgressBar(currentProgress, targetProgress));
        }

        private IEnumerator FadeInLogo()
        {
            float elapsed = 0f;

            while (elapsed < fadeInDuration)
            {
                elapsed += Time.deltaTime;
                float normalizedTime = elapsed / fadeInDuration;

                if (logoCanvasGroup != null)
                    logoCanvasGroup.alpha = Mathf.Lerp(0f, 1f, normalizedTime);

                yield return null;
            }

            if (logoCanvasGroup != null)
                logoCanvasGroup.alpha = 1f;
        }

        private IEnumerator FadeOutLogo()
        {
            float elapsed = 0f;

            while (elapsed < fadeOutDuration)
            {
                elapsed += Time.deltaTime;
                float normalizedTime = elapsed / fadeOutDuration;

                if (logoCanvasGroup != null)
                    logoCanvasGroup.alpha = Mathf.Lerp(1f, 0f, normalizedTime);

                yield return null;
            }

            if (logoCanvasGroup != null)
                logoCanvasGroup.alpha = 0f;
        }

        private IEnumerator UpdateProgressBar(float from, float to)
        {
            float elapsed = 0f;
            float duration = 0.5f;

            while (elapsed < duration)
            {
                elapsed += Time.deltaTime;
                float normalizedTime = elapsed / duration;

                if (loadingBarFill != null)
                    loadingBarFill.fillAmount = Mathf.Lerp(from, to, normalizedTime);

                yield return null;
            }

            if (loadingBarFill != null)
                loadingBarFill.fillAmount = to;
        }

        private void UpdateLoadingText(string text)
        {
            if (loadingText != null)
                loadingText.text = text;
        }

        private void LoadMainMenu()
        {
            SceneManager.LoadScene(mainMenuSceneName);
        }
    }
}
// --- END FILE ---

// File: Core/Camera/CameraManager.cs
// Size: 15249 characters
// ---
using UnityEngine;
using System.Collections;
using CyberPickle.Core.Management;
using CyberPickle.Core.Events;
using CyberPickle.Core.States;
using UnityEngine.Rendering;
using DG.Tweening;
using System;
using System.Threading.Tasks;

namespace CyberPickle.Core.Camera
{
    public class CameraManager : Manager<CameraManager>
    {
        [Header("Camera References")]
        [SerializeField] private UnityEngine.Camera mainCamera;
        [SerializeField] private Transform menuCameraPosition;
        [SerializeField] private Transform characterSelectCameraPosition;

        [Header("Transition Settings")]
        [SerializeField] private float transitionDuration = 1.5f;
        [SerializeField] private AnimationCurve transitionCurve = AnimationCurve.EaseInOut(0, 0, 1, 1);

        [Header("Camera Animation Settings")]
        [SerializeField] private float menuIdleAmplitude = 0.1f;
        [SerializeField] private float menuIdleFrequency = 1f;
        [SerializeField] private float characterSelectIdleAmplitude = 0.2f;
        [SerializeField] private float characterSelectIdleFrequency = 0.5f;

        [Header("Post Processing")]
        [SerializeField] private Volume menuVolume;
        [SerializeField] private Volume characterSelectVolume;

        [Header("Animation Settings")]
        [SerializeField] private bool enableMenuIdleAnimation = false; // Set to false by default
        [SerializeField] private bool enableCharacterSelectIdleAnimation = true;


        [Header("Camera Settings")]
        [SerializeField] private float defaultFieldOfView = 60f;
        public Transform CharacterSelectCameraPosition => characterSelectCameraPosition;

        private Coroutine currentTransition;
        private Coroutine idleAnimationCoroutine;
        private Vector3 cameraVelocity;
        private Vector3 rotationVelocity;

        protected override void OnManagerAwake()
        {
            base.OnManagerAwake();

            if (mainCamera == null)
            {
                mainCamera = UnityEngine.Camera.main;
                Debug.Log("[CameraManager] Main camera assigned automatically");
            }

            ValidateReferences();
            InitializeCamera();
        }

        protected override void OnManagerEnabled()
        {
            base.OnManagerEnabled();
            SubscribeToEvents();
        }

        protected override void OnManagerDisabled()
        {
            base.OnManagerDisabled();
            UnsubscribeFromEvents();
            StopAllCoroutines();
        }

        protected override void OnManagerDestroyed()
        {
            base.OnManagerDestroyed();
            UnsubscribeFromEvents();
            StopAllCoroutines();
        }

        private void ValidateReferences()
        {
            if (menuCameraPosition == null)
                Debug.LogError("[CameraManager] Menu camera position is not assigned!");
            if (characterSelectCameraPosition == null)
                Debug.LogError("[CameraManager] Character select camera position is not assigned!");
        }


        private void InitializeCamera()
        {
            if (mainCamera != null && menuCameraPosition != null)
            {
                mainCamera.transform.position = menuCameraPosition.position;
                mainCamera.transform.rotation = menuCameraPosition.rotation;

                if (enableMenuIdleAnimation)
                {
                    StartMenuIdleAnimation();
                }
            }
        }

        private void SubscribeToEvents()
        {
            GameEvents.OnGameStateChanged.AddListener(HandleGameStateChanged);
        }

        private void UnsubscribeFromEvents()
        {
            GameEvents.OnGameStateChanged.RemoveListener(HandleGameStateChanged);
        }

        private void HandleGameStateChanged(GameState newState)
        {
            switch (newState)
            {
                case GameState.CharacterSelect:
                    TransitionToCharacterSelect();
                    break;
                case GameState.MainMenu:
                    TransitionToMainMenu();
                    break;
            }
        }

        private void TransitionToCharacterSelect()
        {
            Debug.Log("[CameraManager] Starting transition to character select");
            StopIdleAnimation();

            if (currentTransition != null)
                StopCoroutine(currentTransition);

            currentTransition = StartCoroutine(TransitionCameraRoutine(
                characterSelectCameraPosition.position,
                characterSelectCameraPosition.rotation,
                () => {
                    Debug.Log("[CameraManager] Character select transition complete");
                    StartCharacterSelectIdleAnimation();
                    GameEvents.OnCameraTransitionComplete.Invoke();
                }
            ));
        }

        private void TransitionToMainMenu()
        {
            Debug.Log("[CameraManager] Starting transition to main menu");
            StopIdleAnimation();

            if (currentTransition != null)
                StopCoroutine(currentTransition);

            currentTransition = StartCoroutine(TransitionCameraRoutine(
                menuCameraPosition.position,
                menuCameraPosition.rotation,
                () => {
                    Debug.Log("[CameraManager] Main menu transition complete");
                    StartMenuIdleAnimation();
                    GameEvents.OnCameraTransitionComplete.Invoke();
                }
            ));
        }

        private IEnumerator TransitionCameraRoutine(Vector3 targetPosition, Quaternion targetRotation, System.Action onComplete = null)
        {
            float elapsedTime = 0f;
            Vector3 startPosition = mainCamera.transform.position;
            Quaternion startRotation = mainCamera.transform.rotation;

            while (elapsedTime < transitionDuration)
            {
                elapsedTime += Time.deltaTime;
                float normalizedTime = elapsedTime / transitionDuration;
                float curveValue = transitionCurve.Evaluate(normalizedTime);

                mainCamera.transform.position = Vector3.Lerp(startPosition, targetPosition, curveValue);
                mainCamera.transform.rotation = Quaternion.Slerp(startRotation, targetRotation, curveValue);

                yield return null;
            }

            // Ensure we reach the exact target
            mainCamera.transform.position = targetPosition;
            mainCamera.transform.rotation = targetRotation;

            onComplete?.Invoke();
        }

        private void StartMenuIdleAnimation()
        {
            if (!enableMenuIdleAnimation)
            {
                Debug.Log("[CameraManager] Menu idle animation disabled");
                return;
            }

            StopIdleAnimation();
            idleAnimationCoroutine = StartCoroutine(MenuIdleAnimationRoutine());
        }

        private void StartCharacterSelectIdleAnimation()
        {
            StopIdleAnimation();
            idleAnimationCoroutine = StartCoroutine(CharacterSelectIdleAnimationRoutine());
        }

        private void StopIdleAnimation()
        {
            if (idleAnimationCoroutine != null)
            {
                StopCoroutine(idleAnimationCoroutine);
                idleAnimationCoroutine = null;
            }
        }

        private IEnumerator MenuIdleAnimationRoutine()
        {
            Vector3 startPosition = mainCamera.transform.position;

            while (true)
            {
                float time = Time.time;
                Vector3 newPosition = startPosition;
                newPosition.y += Mathf.Sin(time * menuIdleFrequency) * menuIdleAmplitude;

                mainCamera.transform.position = newPosition;
                yield return null;
            }
        }

        private IEnumerator CharacterSelectIdleAnimationRoutine()
        {
            Vector3 startPosition = mainCamera.transform.position;

            while (true)
            {
                float time = Time.time;
                Vector3 newPosition = startPosition;
                newPosition.y += Mathf.Sin(time * characterSelectIdleFrequency) * characterSelectIdleAmplitude;

                mainCamera.transform.position = newPosition;
                yield return null;
            }
        }

        public void SetPostProcessingBlend(float blend)
        {
            if (menuVolume != null)
                menuVolume.weight = 1 - blend;

            if (characterSelectVolume != null)
                characterSelectVolume.weight = blend;
        }

        public async Task FocusCameraOnCharacter(
     Transform characterTransform,
     float cameraHeightOffset,
     float focusDistance,
     float transitionDuration,
     float targetFOV,
     float lookOffset 
 )
        {
            if (characterTransform == null) return;

            StopIdleAnimation();

            // Position the camera behind & above the character
            Vector3 targetPosition = new Vector3(
                characterTransform.position.x,
                characterTransform.position.y + cameraHeightOffset,
                characterTransform.position.z + focusDistance
            );

            // Shift the look-at point higher than the character's pivot
            Vector3 lookAtPoint = characterTransform.position + Vector3.up * lookOffset;

            // Now calculate rotation toward that higher lookAtPoint
            Vector3 directionToCharacter = lookAtPoint - targetPosition;
            Quaternion targetRotation = Quaternion.LookRotation(directionToCharacter);

            // Move, rotate & set FOV
            await TransitionToPosition(
                targetPosition,
                targetRotation,
                transitionDuration,
                targetFOV
            );
        }

        public async Task TransitionToPosition(Vector3 targetPosition, Quaternion targetRotation, float duration, float targetFOV)
        {
            if (mainCamera == null)
            {
                Debug.LogError("[CameraManager] Main camera is null!");
                return;
            }

            Debug.Log($"[CameraManager] Starting camera transition to position: {targetPosition}");

            try
            {
                // Store original values for potential reset
                Vector3 originalPosition = mainCamera.transform.position;
                Quaternion originalRotation = mainCamera.transform.rotation;
                float originalFOV = mainCamera.fieldOfView;

                // Create a sequence for synchronized animations
                Sequence cameraSequence = DOTween.Sequence();

                // Add position transition
                cameraSequence.Join(mainCamera.transform.DOMove(targetPosition, duration)
                    .SetEase(transitionCurve));

                // Add rotation transition
                cameraSequence.Join(mainCamera.transform.DORotateQuaternion(targetRotation, duration)
                    .SetEase(transitionCurve));

                // Add FOV transition
                cameraSequence.Join(DOTween.To(() => mainCamera.fieldOfView,
                    x => mainCamera.fieldOfView = x,
                    targetFOV,
                    duration)
                    .SetEase(transitionCurve));

                // Wait for sequence completion
                await cameraSequence.AsyncWaitForCompletion();

                Debug.Log("[CameraManager] Camera transition completed successfully");
                GameEvents.OnCameraTransitionComplete.Invoke();
            }
            catch (Exception ex)
            {
                Debug.LogError($"[CameraManager] Error during camera transition: {ex.Message}");
                throw;
            }
        }

        public async Task ResetToDefaultPosition(float duration, float newFOV)
        {
            if (mainCamera == null || menuCameraPosition == null)
            {
                Debug.LogError("[CameraManager] Required references are null!");
                return;
            }

            Debug.Log($"[CameraManager] Resetting camera to default with custom FOV {newFOV}");

            try
            {
                Vector3 defaultPosition = menuCameraPosition.position;
                Quaternion defaultRotation = menuCameraPosition.rotation;

                // Create the sequence
                Sequence resetSequence = DOTween.Sequence();

                // Move & rotate camera
                resetSequence.Join(
                    mainCamera.transform.DOMove(defaultPosition, duration)
                        .SetEase(transitionCurve)
                );
                resetSequence.Join(
                    mainCamera.transform.DORotateQuaternion(defaultRotation, duration)
                        .SetEase(transitionCurve)
                );

                // If you want to animate the FOV along with position:
                resetSequence.Join(
                    DOTween.To(
                        () => mainCamera.fieldOfView,
                        x => mainCamera.fieldOfView = x,
                        newFOV,
                        duration
                    ).SetEase(transitionCurve)
                );

                // Wait for it to finish
                await resetSequence.AsyncWaitForCompletion();

                Debug.Log("[CameraManager] Camera reset completed successfully");
                GameEvents.OnCameraTransitionComplete.Invoke();
            }
            catch (Exception ex)
            {
                Debug.LogError($"[CameraManager] Error during camera reset: {ex.Message}");
                throw;
            }


        }
        public async Task ResetToCharacterSelectionView(float duration, float newFOV)
        {
            if (mainCamera == null || characterSelectCameraPosition == null)
            {
                Debug.LogError("[CameraManager] Required references are null!");
                return;
            }

            // Move & rotate camera to the selection vantage
            Sequence seq = DOTween.Sequence();
            seq.Join(mainCamera.transform.DOMove(characterSelectCameraPosition.position, duration));
            seq.Join(mainCamera.transform.DORotateQuaternion(characterSelectCameraPosition.rotation, duration));

            // Adjust FOV (optional)
            seq.Join(DOTween.To(() => mainCamera.fieldOfView,
                                x => mainCamera.fieldOfView = x,
                                newFOV,
                                duration));

            await seq.AsyncWaitForCompletion();
            GameEvents.OnCameraTransitionComplete.Invoke();
        }
    }
}
// --- END FILE ---

// File: Core/Config/ConfigRegistry.cs
// Size: 5509 characters
// ---
// File: Assets/Code/Core/Config/ConfigRegistry.cs
//
// Purpose: Central registry for all game configuration ScriptableObjects.
// Loads and manages access to all configuration assets using the Addressables system.
// Ensures configs are loaded before any manager initialization.
//
// Created: 2024-02-11
// Updated: 2024-02-11

// File: Assets/Code/Core/Config/ConfigRegistry.cs

using UnityEngine;
using UnityEngine.AddressableAssets;
using UnityEngine.ResourceManagement.AsyncOperations;
using System.Collections.Generic;
using System.Threading.Tasks;
using System;
using CyberPickle.Core.Management;

namespace CyberPickle.Core.Config
{
    public class ConfigRegistry : Manager<ConfigRegistry>
    {
        private readonly Dictionary<Type, ScriptableObject> configs = new Dictionary<Type, ScriptableObject>();
        private readonly Dictionary<Type, AsyncOperationHandle> operationHandles = new Dictionary<Type, AsyncOperationHandle>();
        private bool isInitialized = false;

        private const string BOOT_CONFIG_KEY = "config/boot";
        private const string GAME_CONFIG_KEY = "config/game";

        protected override void OnManagerAwake()
        {
            Debug.Log("<color=yellow>[ConfigRegistry] Initializing...</color>");
        }

        public async Task InitializeAsync()
        {
            if (isInitialized)
            {
                Debug.LogWarning("[ConfigRegistry] Already initialized!");
                return;
            }

            try
            {
                await LoadCoreConfigs();
                await LoadUIConfigs();

                isInitialized = true;
                Debug.Log("<color=green>[ConfigRegistry] All configs loaded successfully!</color>");
            }
            catch (Exception e)
            {
                Debug.LogError($"<color=red>[ConfigRegistry] Failed to initialize: {e.Message}</color>");
                throw;
            }
        }

        private async Task LoadCoreConfigs()
        {
            Debug.Log("[ConfigRegistry] Loading core configs...");

            try
            {
                await LoadConfigAsync<BootConfig>(BOOT_CONFIG_KEY);
                await LoadConfigAsync<GameConfig>(GAME_CONFIG_KEY);
            }
            catch (Exception e)
            {
                throw new Exception($"Failed to load core configs: {e.Message}", e);
            }
        }

        private async Task LoadUIConfigs()
        {
            Debug.Log("[ConfigRegistry] Loading UI configs...");

            try
            {
                var loadOperation = Addressables.LoadAssetsAsync<ScriptableObject>(
                    "config-ui",
                    (config) =>
                    {
                        // This is called for each loaded asset
                        RegisterConfig(config);
                    }
                );

                operationHandles[typeof(ScriptableObject)] = loadOperation;
                await loadOperation.Task;

                if (loadOperation.Status != AsyncOperationStatus.Succeeded)
                {
                    throw new Exception($"UI configs load operation failed");
                }
            }
            catch (Exception e)
            {
                Debug.LogWarning($"[ConfigRegistry] UI configs failed to load: {e.Message}");
                // Don't throw here - UI configs aren't critical
            }
        }

        private async Task<T> LoadConfigAsync<T>(string key) where T : ScriptableObject
        {
            try
            {
                var loadOperation = Addressables.LoadAssetAsync<T>(key);
                operationHandles[typeof(T)] = loadOperation;

                await loadOperation.Task;

                if (loadOperation.Status != AsyncOperationStatus.Succeeded)
                {
                    throw new Exception($"Failed to load config at key: {key}");
                }

                var config = loadOperation.Result;
                RegisterConfig(config);
                return config;
            }
            catch (Exception e)
            {
                throw new Exception($"Error loading config {typeof(T).Name}: {e.Message}", e);
            }
        }

        private void RegisterConfig<T>(T config) where T : ScriptableObject
        {
            var type = config.GetType();
            configs[type] = config;
            Debug.Log($"[ConfigRegistry] Registered config: {type.Name}");
        }

        public T GetConfig<T>() where T : ScriptableObject
        {
            if (!isInitialized)
            {
                throw new InvalidOperationException("[ConfigRegistry] Attempted to get config before initialization!");
            }

            if (configs.TryGetValue(typeof(T), out ScriptableObject config))
            {
                return config as T;
            }

            throw new Exception($"[ConfigRegistry] Config not found for type: {typeof(T).Name}");
        }

        protected override void OnManagerDestroyed()
        {
            foreach (var handle in operationHandles.Values)
            {
                if (handle.IsValid())
                {
                    Addressables.Release(handle);
                }
            }

            operationHandles.Clear();
            configs.Clear();
        }
    }
}

// --- END FILE ---

// File: Core/GameManager/GameManager.cs
// Size: 8137 characters
// ---
using UnityEngine;
using UnityEngine.SceneManagement;
using System.Collections;
using CyberPickle.Core.Management;
using CyberPickle.Core.Events;
using CyberPickle.Core.States;
using CyberPickle.Core.Config;
using CyberPickle.Core.Interfaces;

namespace CyberPickle.Core
{
    public class GameManager : Manager<GameManager>, IInitializable
    {

        private GameConfig gameConfig;
        private GameState currentState = GameState.None;
        private GameState previousState = GameState.None;
        private bool isInitialized;
        private bool isPaused;

        public GameState CurrentState => currentState;
        public bool IsPaused => isPaused;

        #region Initialization

        public void Initialize()
        {
            if (isInitialized) return;

            LoadGameConfig();
            if (gameConfig == null)
            {
                Debug.LogError("<color=red>[GameManager] Failed to load GameConfig. Cannot initialize!</color>");
                return;
            }

            RegisterEventListeners();
            isInitialized = true;

            GameEvents.OnGameInitialized.Invoke();
        }

        private void RegisterEventListeners()
        {
            // Register for events that might affect game state
            GameEvents.OnPlayerDied.AddListener(HandlePlayerDeath);
            GameEvents.OnLevelCompleted.AddListener(HandleLevelCompleted);
        }

        private void LoadGameConfig()
        {
            try
            {
                var configRegistry = ConfigRegistry.Instance;
                if (configRegistry == null)
                {
                    throw new System.Exception("ConfigRegistry not initialized!");
                }

                gameConfig = configRegistry.GetConfig<GameConfig>();
                if (gameConfig == null)
                {
                    throw new System.Exception("GameConfig not found in registry!");
                }

                Debug.Log("<color=green>[GameManager] GameConfig loaded successfully!</color>");
            }
            catch (System.Exception e)
            {
                Debug.LogError($"<color=red>[GameManager] Failed to load GameConfig: {e.Message}</color>");
            }
        }

        #endregion

        #region Game Flow Control

        public void StartNewGame()
        {
            StartCoroutine(StartNewGameSequence());
        }

        private IEnumerator StartNewGameSequence()
        {
            ChangeState(GameState.Loading);

            // Load character select scene
            yield return LoadSceneAsync(gameConfig.characterSelectSceneName);
            ChangeState(GameState.CharacterSelect);
        }

        public void StartLevel(string levelId)
        {
            StartCoroutine(StartLevelSequence(levelId));
        }

        private IEnumerator StartLevelSequence(string levelId)
        {
            ChangeState(GameState.Loading);

            // Load game scene
            yield return LoadSceneAsync(gameConfig.gameSceneName);

            // Initialize level
            yield return new WaitForSeconds(gameConfig.gameStartDelay);

            ChangeState(GameState.Playing);
            GameEvents.OnGameStarted.Invoke();
        }

        public void PauseGame()
        {
            if (currentState != GameState.Playing) return;

            isPaused = true;
            Time.timeScale = 0f;
            ChangeState(GameState.Paused);
            GameEvents.OnGamePaused.Invoke();
        }

        public void ResumeGame()
        {
            if (currentState != GameState.Paused) return;

            isPaused = false;
            Time.timeScale = 1f;
            ChangeState(GameState.Playing);
            GameEvents.OnGameResumed.Invoke();
        }

        public void GameOver()
        {
            StartCoroutine(GameOverSequence());
        }

        private IEnumerator GameOverSequence()
        {
            yield return new WaitForSeconds(gameConfig.gameOverDelay);

            ChangeState(GameState.GameOver);
            GameEvents.OnGameOver.Invoke();

            // Load post-game scene
            yield return LoadSceneAsync(gameConfig.postGameSceneName);
            ChangeState(GameState.PostGame);
        }

        #endregion

        #region State Management

        private void ChangeState(GameState newState)
        {
            if (currentState == newState) return;

            previousState = currentState;
            currentState = newState;

            Debug.Log($"Game State Changed: {previousState} -> {currentState}");

            HandleStateChange();
        }

        private void HandleStateChange()
        {
            switch (currentState)
            {
                case GameState.MainMenu:
                    Time.timeScale = 1f;
                    break;

                case GameState.Playing:
                    Time.timeScale = 1f;
                    break;

                case GameState.Paused:
                    Time.timeScale = 0f;
                    break;

                case GameState.GameOver:
                    Time.timeScale = 0f;
                    break;
            }
        }

        #endregion

        #region Event Handlers

        private void HandlePlayerDeath()
        {
            if (currentState == GameState.Playing)
            {
                GameOver();
            }
        }

        private void HandleLevelCompleted(string levelId)
        {
            if (currentState == GameState.Playing)
            {
                StartCoroutine(LevelCompleteSequence(levelId));
            }
        }

        private IEnumerator LevelCompleteSequence(string levelId)
        {
            // Save progress
            SaveProgress();

            // Show level complete UI
            yield return new WaitForSeconds(2f);

            // Load post-game scene
            yield return LoadSceneAsync(gameConfig.postGameSceneName);
            ChangeState(GameState.PostGame);
        }

        #endregion

        #region Utility Methods

        private void SaveProgress()
        {
            // This will be implemented when we create the SaveSystem
            Debug.Log("Saving game progress...");
        }

        private IEnumerator LoadSceneAsync(string sceneName)
        {
            AsyncOperation asyncLoad = SceneManager.LoadSceneAsync(sceneName);

            while (!asyncLoad.isDone)
            {
                float progress = Mathf.Clamp01(asyncLoad.progress / 0.9f);
                // Could dispatch loading progress event here
                yield return null;
            }
        }

        #endregion

        #region Debug Methods

        public void ToggleDebugMode()
        {
            if (!gameConfig.enableDebugMode) return;

            // Add debug functionality
            Debug.Log("Debug mode toggled");
        }

        #endregion

        protected override void OnManagerAwake()
        {
            Debug.Log("<color=yellow>[GameManager] Initializing...</color>");
            Initialize();
        }

        private void OnApplicationPause(bool pauseStatus)
        {
            if (pauseStatus && currentState == GameState.Playing)
            {
                PauseGame();
            }
        }
        protected override void OnManagerDestroyed()
        {
            if (!IsActiveInstance) return;

            try
            {
                SaveProgress();
            }
            catch (System.Exception e)
            {
                Debug.LogError($"Error saving progress during shutdown: {e.Message}");
            }

            // Cleanup event listeners
            GameEvents.OnPlayerDied.RemoveListener(HandlePlayerDeath);
            GameEvents.OnLevelCompleted.RemoveListener(HandleLevelCompleted);
        }
    }
}

// --- END FILE ---

// File: Core/Input/InputManager.cs
// Size: 10672 characters
// ---
using UnityEngine;
using CyberPickle.Core.Management;
using CyberPickle.Core.Events;
using CyberPickle.Core.Interfaces;
using CyberPickle.Core.States;

#if ENABLE_INPUT_SYSTEM
using UnityEngine.InputSystem;
using UnityEngine.InputSystem.Controls;
#endif

namespace CyberPickle.Core.Input
{
    public class InputManager : Manager<InputManager>, IInitializable
    {
        [Header("Input Settings")]
        [SerializeField, Tooltip("Mouse sensitivity multiplier for horizontal movement")]
        private float mouseSensitivity = 1.5f;

        [SerializeField, Tooltip("Touch sensitivity multiplier for horizontal movement")]
        private float touchSensitivity = 1.5f;

        [SerializeField, Tooltip("Keyboard sensitivity multiplier for horizontal movement")]
        private float keyboardSensitivity = 0.1f;

        [Header("Dead Zones")]
        [SerializeField, Tooltip("Minimum mouse movement required to trigger input")]
        private float mouseDeadZone = 0.01f;

        [SerializeField, Tooltip("Minimum touch movement required to trigger input")]
        private float touchDeadZone = 0.001f;

        private GameState currentGameState;
        private bool isInputEnabled = true;
        private bool isInitialized;

#if ENABLE_INPUT_SYSTEM
        private InputAction moveAction;
        private InputAction anyKeyAction;
        private InputAction touchPositionAction;
        private InputAction touchPressAction;
        private InputAction mousePositionAction;
        private InputAction mouseButtonAction;
        private InputAction profileNavigationAction;
        private Vector2 previousTouchPosition;
        private Vector2 previousMousePosition;
        private bool isMousePressed;
#endif

        public void Initialize()
        {
            if (isInitialized) return;

            SetupInputActions();
            RegisterEvents();
            EnableInput();

            isInitialized = true;
            Debug.Log("InputManager initialized");
        }

        private void SetupInputActions()
        {
#if ENABLE_INPUT_SYSTEM
            // Movement input
            moveAction = new InputAction("Move");
            moveAction.AddCompositeBinding("2DVector")
                .With("Up", "<Keyboard>/w")
                .With("Down", "<Keyboard>/s")
                .With("Left", "<Keyboard>/a")
                .With("Right", "<Keyboard>/d")
                .With("Up", "<Keyboard>/upArrow")
                .With("Down", "<Keyboard>/downArrow")
                .With("Left", "<Keyboard>/leftArrow")
                .With("Right", "<Keyboard>/rightArrow");
            moveAction.performed += ctx => HandleMovement(ctx.ReadValue<Vector2>());
            moveAction.canceled += ctx => HandleMovement(Vector2.zero);

            // Any key input
            anyKeyAction = new InputAction("AnyKey", InputActionType.Button);
            anyKeyAction.AddBinding("<Keyboard>/anyKey");
            anyKeyAction.AddBinding("<Mouse>/leftButton");
            anyKeyAction.performed += ctx => HandleAnyKeyPress();

            // Mouse input
            mousePositionAction = new InputAction("MousePosition", InputActionType.Value, "<Mouse>/position");
            mouseButtonAction = new InputAction("MouseButton", InputActionType.Button, "<Mouse>/leftButton");

            mouseButtonAction.started += _ => { isMousePressed = true; previousMousePosition = mousePositionAction.ReadValue<Vector2>(); };
            mouseButtonAction.canceled += _ => isMousePressed = false;

            // Touch input
            touchPositionAction = new InputAction("TouchPosition");
            touchPositionAction.AddBinding("<Touchscreen>/position");

            touchPressAction = new InputAction("TouchPress");
            touchPressAction.AddBinding("<Touchscreen>/primaryTouch/press");
            touchPressAction.performed += ctx => HandleTouchPress(ctx.ReadValue<float>());

            // Add this new action for profile navigation
            profileNavigationAction = new InputAction("ProfileNavigation");
            profileNavigationAction.AddCompositeBinding("1DAxis")
                .With("Positive", "<Keyboard>/downArrow")
                .With("Negative", "<Keyboard>/upArrow");
            profileNavigationAction.performed += ctx => HandleProfileNavigation(ctx.ReadValue<float>());
#endif
        }
        private void HandleProfileNavigation(float direction)
        {
            if (!isInputEnabled) return;

            if (currentGameState == GameState.ProfileSelection)
            {
                GameEvents.OnProfileNavigationInput.Invoke(direction);
            }
        }
        protected override void OnManagerEnabled()
        {
#if ENABLE_INPUT_SYSTEM
            moveAction?.Enable();
            anyKeyAction?.Enable();
            touchPositionAction?.Enable();
            touchPressAction?.Enable();
            mousePositionAction?.Enable();
            mouseButtonAction?.Enable();
            profileNavigationAction?.Enable();
#endif
        }

        protected override void OnManagerDisabled()
        {
#if ENABLE_INPUT_SYSTEM
            moveAction?.Disable();
            anyKeyAction?.Disable();
            touchPositionAction?.Disable();
            touchPressAction?.Disable();
            mousePositionAction?.Disable();
            mouseButtonAction?.Disable();
            profileNavigationAction?.Enable();
#endif
        }

        private void HandleMovement(Vector2 movement)
        {
            if (!isInputEnabled || currentGameState != GameState.Playing) return;

            float horizontalInput = movement.x * keyboardSensitivity;
            if (Mathf.Abs(horizontalInput) > mouseDeadZone)
            {
                GameEvents.OnHorizontalInput.Invoke(horizontalInput);
            }
        }

        private void HandleAnyKeyPress()
        {
            if (!isInputEnabled) return;

            switch (currentGameState)
            {
                case GameState.MainMenu:
                    GameEvents.OnMainMenuInput.Invoke();
                    break;
            }
        }

#if ENABLE_INPUT_SYSTEM
        private void HandleTouchPress(float pressed)
        {
            if (!isInputEnabled) return;

            if (pressed > 0)
            {
                previousTouchPosition = touchPositionAction.ReadValue<Vector2>();
            }
            else if (currentGameState == GameState.MainMenu)
            {
                GameEvents.OnMainMenuInput.Invoke();
            }
        }

        private void HandleMouseInput()
        {
            if (!isMousePressed || !isInputEnabled) return;

            Vector2 currentMousePosition = mousePositionAction.ReadValue<Vector2>();
            Vector2 mouseDelta = currentMousePosition - previousMousePosition;
            float normalizedDelta = mouseDelta.x / Screen.width * mouseSensitivity;

            if (Mathf.Abs(normalizedDelta) > mouseDeadZone && currentGameState == GameState.Playing)
            {
                GameEvents.OnHorizontalInput.Invoke(normalizedDelta);
            }

            previousMousePosition = currentMousePosition;
        }

        private void Update()
        {
            if (!isInputEnabled) return;

            // Handle mouse movement
            HandleMouseInput();

            // Handle touch movement
            if (Touchscreen.current != null && Touchscreen.current.primaryTouch.press.isPressed)
            {
                Vector2 currentPosition = touchPositionAction.ReadValue<Vector2>();
                Vector2 delta = currentPosition - previousTouchPosition;
                float normalizedDelta = delta.x / Screen.width * touchSensitivity;

                if (Mathf.Abs(normalizedDelta) > touchDeadZone && currentGameState == GameState.Playing)
                {
                    GameEvents.OnHorizontalInput.Invoke(normalizedDelta);
                }

                previousTouchPosition = currentPosition;
            }

            // Check for pause input
            if (Keyboard.current != null && Keyboard.current.escapeKey.wasPressedThisFrame)
            {
                switch (currentGameState)
                {
                    case GameState.Playing:
                        GameEvents.OnPauseRequested.Invoke();
                        break;
                    case GameState.Paused:
                        GameEvents.OnResumeRequested.Invoke();
                        break;
                }
            }
        }
#endif

        private void RegisterEvents()
        {
            GameEvents.OnGameStateChanged.AddListener(HandleGameStateChanged);
            GameEvents.OnGamePaused.AddListener(DisableInput);
            GameEvents.OnGameResumed.AddListener(EnableInput);
        }

        private void HandleGameStateChanged(GameState newState)
        {
            currentGameState = newState;
            Debug.Log($"Input Manager state changed to: {newState}");
        }

        public void EnableInput()
        {
            isInputEnabled = true;
#if ENABLE_INPUT_SYSTEM
            moveAction?.Enable();
            anyKeyAction?.Enable();
            touchPositionAction?.Enable();
            touchPressAction?.Enable();
            mousePositionAction?.Enable();
            mouseButtonAction?.Enable();
#endif
        }

        public void DisableInput()
        {
            isInputEnabled = false;
#if ENABLE_INPUT_SYSTEM
            moveAction?.Disable();
            anyKeyAction?.Disable();
            touchPositionAction?.Disable();
            touchPressAction?.Disable();
            mousePositionAction?.Disable();
            mouseButtonAction?.Disable();
#endif
        }

        protected override void OnManagerDestroyed()
        {
            // Clean up events
            GameEvents.OnGameStateChanged.RemoveListener(HandleGameStateChanged);
            GameEvents.OnGamePaused.RemoveListener(DisableInput);
            GameEvents.OnGameResumed.RemoveListener(EnableInput);

            // Clean up input actions
#if ENABLE_INPUT_SYSTEM
            moveAction?.Dispose();
            anyKeyAction?.Dispose();
            touchPositionAction?.Dispose();
            touchPressAction?.Dispose();
            mousePositionAction?.Dispose();
            mouseButtonAction?.Dispose();
            profileNavigationAction?.Dispose();
#endif
        }
    }
}

// --- END FILE ---

// File: Core/Pool/PoolManager.cs
// Size: 315 characters
// ---
using CyberPickle.Core.Management;
using CyberPickle.Core.Interfaces;

namespace CyberPickle.Core.Pool
{
    public class PoolManager : Manager<PoolManager>, IInitializable
    {
        public void Initialize()
        {
            UnityEngine.Debug.Log("PoolManager initialized");
        }
    }
}

// --- END FILE ---

// File: Core/SaveSystem/SaveManager.cs
// Size: 321 characters
// ---
using CyberPickle.Core.Management;
using CyberPickle.Core.Interfaces;

namespace CyberPickle.Core.SaveSystem
{
    public class SaveManager : Manager<SaveManager>, IInitializable
    {
        public void Initialize()
        {
            UnityEngine.Debug.Log("SaveManager initialized");
        }
    }
}

// --- END FILE ---

// File: Core/Transitions/TransitionManager.cs
// Size: 6850 characters
// ---
using UnityEngine;
using System.Collections;
using CyberPickle.Core.Management;
using CyberPickle.Core.Events;
using CyberPickle.Core.States;

namespace CyberPickle.Core.Transitions
{
    public class TransitionManager : Manager<TransitionManager>
    {
        [Header("Scene References")]
        [SerializeField] private GameObject menuArea;
        [SerializeField] private GameObject characterSelectArea;
        [SerializeField] private Light bonfireLight;
        [SerializeField] private float maxBonfireIntensity = 2f;

        [Header("Transition Settings")]
        [SerializeField] private float transitionDuration = 1f;
        [SerializeField] private AnimationCurve transitionCurve = AnimationCurve.EaseInOut(0, 0, 1, 1);

        private Coroutine currentTransition;
        private GameState currentState;

        protected override void OnManagerAwake()
        {
            base.OnManagerAwake();
            ValidateReferences();
            InitializeScene();
        }

        private void ValidateReferences()
        {
            if (characterSelectArea == null)
                Debug.LogError("[TransitionManager] Character select area is missing!");

            if (bonfireLight == null)
                Debug.LogError("[TransitionManager] Bonfire light is missing!");
        }

        private void InitializeScene()
        {
            Debug.Log("[TransitionManager] Initializing scene");

            if (characterSelectArea != null)
            {
                characterSelectArea.SetActive(false);
                Debug.Log("[TransitionManager] Character select area hidden");
            }

            if (bonfireLight != null)
            {
                bonfireLight.intensity = 0f;
                Debug.Log("[TransitionManager] Bonfire light initialized");
            }
        }

        protected override void OnManagerEnabled()
        {
            base.OnManagerEnabled();
            SubscribeToEvents();
        }

        protected override void OnManagerDisabled()
        {
            base.OnManagerDisabled();
            UnsubscribeFromEvents();
            StopAllCoroutines();
        }

        private void SubscribeToEvents()
        {
            GameEvents.OnGameStateChanged.AddListener(HandleGameStateChanged);
            GameEvents.OnCameraTransitionComplete.AddListener(HandleCameraTransitionComplete);
        }

        private void UnsubscribeFromEvents()
        {
            GameEvents.OnGameStateChanged.RemoveListener(HandleGameStateChanged);
            GameEvents.OnCameraTransitionComplete.RemoveListener(HandleCameraTransitionComplete);
        }

        private void HandleGameStateChanged(GameState newState)
        {
            currentState = newState;

            switch (newState)
            {
                case GameState.CharacterSelect:
                    StartCharacterSelectTransition();
                    break;
                case GameState.MainMenu:
                    StartMainMenuTransition();
                    break;
            }
        }

        private void HandleCameraTransitionComplete()
        {
            Debug.Log("[TransitionManager] Camera transition complete");

            // Additional effects or state changes after camera movement based on current state
            switch (currentState)
            {
                case GameState.CharacterSelect:
                    // Maybe trigger some additional VFX or lighting changes
                    if (bonfireLight != null)
                    {
                        StartCoroutine(AnimateBonfireLight(maxBonfireIntensity, 0.5f));
                    }
                    break;

                case GameState.MainMenu:
                    // Return to default state or trigger menu-specific effects
                    if (bonfireLight != null)
                    {
                        StartCoroutine(AnimateBonfireLight(0f, 0.5f));
                    }
                    break;
            }
        }

        private void StartCharacterSelectTransition()
        {
            Debug.Log("[TransitionManager] Starting character select transition");

            if (currentTransition != null)
                StopCoroutine(currentTransition);

            currentTransition = StartCoroutine(CharacterSelectTransitionRoutine());
        }

        private void StartMainMenuTransition()
        {
            Debug.Log("[TransitionManager] Starting main menu transition");

            if (currentTransition != null)
                StopCoroutine(currentTransition);

            currentTransition = StartCoroutine(MainMenuTransitionRoutine());
        }

        private IEnumerator CharacterSelectTransitionRoutine()
        {
            if (characterSelectArea != null)
            {
                characterSelectArea.SetActive(true);
                Debug.Log("[TransitionManager] Character select area activated");
            }

            // Fade in the bonfire light
            if (bonfireLight != null)
            {
                yield return StartCoroutine(AnimateBonfireLight(maxBonfireIntensity, transitionDuration));
            }

            GameEvents.OnCameraTransitionComplete.Invoke();
        }

        private IEnumerator MainMenuTransitionRoutine()
        {
            if (menuArea != null)
                menuArea.SetActive(true);

            // Fade out bonfire light
            if (bonfireLight != null)
            {
                yield return StartCoroutine(AnimateBonfireLight(0f, transitionDuration));
            }

            if (characterSelectArea != null)
                characterSelectArea.SetActive(false);

            Debug.Log("[TransitionManager] Main menu transition complete");
        }

        private IEnumerator AnimateBonfireLight(float targetIntensity, float duration)
        {
            if (bonfireLight == null) yield break;

            float startIntensity = bonfireLight.intensity;
            float elapsedTime = 0f;

            while (elapsedTime < duration)
            {
                elapsedTime += Time.deltaTime;
                float normalizedTime = elapsedTime / duration;
                float curveValue = transitionCurve.Evaluate(normalizedTime);

                bonfireLight.intensity = Mathf.Lerp(startIntensity, targetIntensity, curveValue);
                yield return null;
            }

            bonfireLight.intensity = targetIntensity;
        }


        protected override void OnManagerDestroyed()
        {
            base.OnManagerDestroyed();
            UnsubscribeFromEvents();
            StopAllCoroutines();
        }
    }
}
// --- END FILE ---

// File: Core/VFX/SmokeVFXController.cs
// Size: 3081 characters
// ---
using UnityEngine;
using UnityEngine.VFX;

namespace CyberPickle.Core.VFX
{
    [RequireComponent(typeof(VisualEffect))]
    public class SmokeVFXController : MonoBehaviour
    {
        private VisualEffect vfx;

        // These names must match exactly with the parameters in your Visual Effect Graph
        private const string SPAWN_RATE_PARAM = "SpawnRate";
        private const string SMOKE_DENSITY_PARAM = "SmokeDensity";
        private const string SMOKE_SIZE_PARAM = "SmokeSize";

        [Header("Debug")]
        [SerializeField] private bool showDebugLog = true;

        private void Awake()
        {
            vfx = GetComponent<VisualEffect>();
            ValidateParameters();
        }

        private void ValidateParameters()
        {
            if (vfx == null)
            {
                Debug.LogError("[SmokeVFXController] No VisualEffect component found!");
                return;
            }

            // Check if parameters exist
            bool hasSpawnRate = HasParameter(SPAWN_RATE_PARAM);
            bool hasSmokeDensity = HasParameter(SMOKE_DENSITY_PARAM);
            bool hasSmokeSize = HasParameter(SMOKE_SIZE_PARAM);

            if (showDebugLog)
            {
                Debug.Log($"[SmokeVFXController] Parameter check:\n" +
                    $"SpawnRate: {(hasSpawnRate ? "Found" : "Missing")}\n" +
                    $"SmokeDensity: {(hasSmokeDensity ? "Found" : "Missing")}\n" +
                    $"SmokeSize: {(hasSmokeSize ? "Found" : "Missing")}");
            }

            // Log warning for any missing parameters
            if (!hasSpawnRate) Debug.LogWarning($"[SmokeVFXController] Missing parameter: {SPAWN_RATE_PARAM}");
            if (!hasSmokeDensity) Debug.LogWarning($"[SmokeVFXController] Missing parameter: {SMOKE_DENSITY_PARAM}");
            if (!hasSmokeSize) Debug.LogWarning($"[SmokeVFXController] Missing parameter: {SMOKE_SIZE_PARAM}");
        }

        private bool HasParameter(string name)
        {
            return vfx.HasFloat(name);
        }

        public void SetSmokeDensity(float density)
        {
            if (vfx != null && HasParameter(SMOKE_DENSITY_PARAM))
            {
                vfx.SetFloat(SMOKE_DENSITY_PARAM, density);
                if (showDebugLog) Debug.Log($"[SmokeVFXController] Set SmokeDensity to {density}");
            }
        }

        public void SetSpawnRate(float rate)
        {
            if (vfx != null && HasParameter(SPAWN_RATE_PARAM))
            {
                vfx.SetFloat(SPAWN_RATE_PARAM, rate);
                if (showDebugLog) Debug.Log($"[SmokeVFXController] Set SpawnRate to {rate}");
            }
        }

        public void SetSmokeSize(float size)
        {
            if (vfx != null && HasParameter(SMOKE_SIZE_PARAM))
            {
                vfx.SetFloat(SMOKE_SIZE_PARAM, size);
                if (showDebugLog) Debug.Log($"[SmokeVFXController] Set SmokeSize to {size}");
            }
        }
    }
}

// --- END FILE ---

// File: Shop/Currency/CurrencyData.cs
// Size: 5161 characters
// ---
// File: Shop/Currency/CurrencyData.cs
//
// Purpose: Defines the currency data structure for the game's economy system.
// Manages Neural Credits and CyberCoins, the two main currencies in Cyber Pickle.
//
// Created: 2024-02-24
// Updated: 2024-02-24

using Newtonsoft.Json;
using System;
using UnityEngine;

namespace CyberPickle.Shop.Currency
{
    /// <summary>
    /// Manages the player's currency data for both Neural Credits and CyberCoins
    /// </summary>
    [Serializable]
    public class CurrencyData
    {
        [JsonProperty("neuralCredits")]
        private float neuralCredits;

        [JsonProperty("cyberCoins")]
        private float cyberCoins;

        [JsonIgnore] public float NeuralCredits => neuralCredits;
        [JsonIgnore] public float CyberCoins => cyberCoins;

        /// <summary>
        /// Creates a new CurrencyData instance with zero balance
        /// </summary>
        public CurrencyData()
        {
            neuralCredits = 0f;
            cyberCoins = 0f;
        }

        /// <summary>
        /// Creates a new CurrencyData instance with specified initial values
        /// </summary>
        /// <param name="initialNeuralCredits">Initial Neural Credits amount</param>
        /// <param name="initialCyberCoins">Initial CyberCoins amount</param>
        public CurrencyData(float initialNeuralCredits, float initialCyberCoins)
        {
            neuralCredits = Mathf.Max(0, initialNeuralCredits);
            cyberCoins = Mathf.Max(0, initialCyberCoins);
        }

        /// <summary>
        /// Adds Neural Credits to the player's balance
        /// </summary>
        /// <param name="amount">Amount to add (must be positive)</param>
        public void AddNeuralCredits(float amount)
        {
            if (amount > 0)
            {
                neuralCredits += amount;
                Debug.Log($"[CurrencyData] Added {amount} Neural Credits. New balance: {neuralCredits}");
            }
        }

        /// <summary>
        /// Adds CyberCoins to the player's balance
        /// </summary>
        /// <param name="amount">Amount to add (must be positive)</param>
        public void AddCyberCoins(float amount)
        {
            if (amount > 0)
            {
                cyberCoins += amount;
                Debug.Log($"[CurrencyData] Added {amount} CyberCoins. New balance: {cyberCoins}");
            }
        }

        /// <summary>
        /// Attempts to spend Neural Credits from the player's balance
        /// </summary>
        /// <param name="amount">Amount to spend</param>
        /// <returns>True if sufficient funds were available and spent, false otherwise</returns>
        public bool SpendNeuralCredits(float amount)
        {
            if (amount <= 0)
            {
                Debug.LogWarning("[CurrencyData] Attempted to spend non-positive amount of Neural Credits");
                return false;
            }

            if (neuralCredits >= amount)
            {
                neuralCredits -= amount;
                Debug.Log($"[CurrencyData] Spent {amount} Neural Credits. Remaining balance: {neuralCredits}");
                return true;
            }

            Debug.Log($"[CurrencyData] Insufficient Neural Credits. Required: {amount}, Available: {neuralCredits}");
            return false;
        }

        /// <summary>
        /// Attempts to spend CyberCoins from the player's balance
        /// </summary>
        /// <param name="amount">Amount to spend</param>
        /// <returns>True if sufficient funds were available and spent, false otherwise</returns>
        public bool SpendCyberCoins(float amount)
        {
            if (amount <= 0)
            {
                Debug.LogWarning("[CurrencyData] Attempted to spend non-positive amount of CyberCoins");
                return false;
            }

            if (cyberCoins >= amount)
            {
                cyberCoins -= amount;
                Debug.Log($"[CurrencyData] Spent {amount} CyberCoins. Remaining balance: {cyberCoins}");
                return true;
            }

            Debug.Log($"[CurrencyData] Insufficient CyberCoins. Required: {amount}, Available: {cyberCoins}");
            return false;
        }

        /// <summary>
        /// Sets exact Neural Credits amount (for debugging or admin purposes)
        /// </summary>
        /// <param name="amount">Amount to set</param>
        internal void SetNeuralCredits(float amount)
        {
            neuralCredits = Mathf.Max(0, amount);
            Debug.Log($"[CurrencyData] Neural Credits set to {neuralCredits}");
        }

        /// <summary>
        /// Sets exact CyberCoins amount (for debugging or admin purposes)
        /// </summary>
        /// <param name="amount">Amount to set</param>
        internal void SetCyberCoins(float amount)
        {
            cyberCoins = Mathf.Max(0, amount);
            Debug.Log($"[CurrencyData] CyberCoins set to {cyberCoins}");
        }
    }
}

// --- END FILE ---

// File: Shop/Currency/CurrencyManager.cs
// Size: 11256 characters
// ---
// File: Assets/Code/Shop/Currency/CurrencyManager.cs
//
// Purpose: Manages the game's currency system including Neural Credits and CyberCoins.
// Handles currency transactions, persistence, and provides events for UI updates.
// Works with the profile system to persist currency data.
//
// Created: 2025-02-25
// Updated: 2025-02-25

using UnityEngine;
using System;
using System.Threading.Tasks;
using CyberPickle.Core.Management;
using CyberPickle.Core.Interfaces;
using CyberPickle.Core.Services.Authentication;
using CyberPickle.Core.Services.Authentication.Data;
using CyberPickle.Core.Events;

namespace CyberPickle.Shop.Currency
{
    /// <summary>
    /// Manages the game's currency system including earning, spending, and displaying currencies
    /// </summary>
    public class CurrencyManager : Manager<CurrencyManager>, IInitializable
    {
        [Header("Currency Settings")]
        [SerializeField] private float neuralCreditStartAmount = 500f;
        [SerializeField] private float cyberCoinStartAmount = 50f;

        // Events
        public event Action<CurrencyType, float, float> OnCurrencyChanged;  // Type, OldAmount, NewAmount
        public event Action<CurrencyType, float> OnCurrencyAdded;           // Type, Amount
        public event Action<CurrencyType, float> OnCurrencySpent;           // Type, Amount
        public event Action<CurrencyType> OnInsufficientFunds;              // Type

        // Dependencies
        private ProfileManager profileManager;

        // Runtime cache
        private float cachedNeuralCredits;
        private float cachedCyberCoins;
        private bool isInitialized = false;

        /// <summary>
        /// Get the current amount of Neural Credits
        /// </summary>
        public float NeuralCredits => cachedNeuralCredits;

        /// <summary>
        /// Get the current amount of CyberCoins
        /// </summary>
        public float CyberCoins => cachedCyberCoins;

        /// <summary>
        /// Initialize the Currency Manager
        /// </summary>
        public void Initialize()
        {
            if (isInitialized) return;

            Debug.Log("[CurrencyManager] Initializing...");

            // Get profile manager reference
            profileManager = ProfileManager.Instance;
            if (profileManager == null)
            {
                Debug.LogError("[CurrencyManager] ProfileManager not found!");
                return;
            }

            // Subscribe to profile events
            profileManager.SubscribeToProfileSwitched(OnProfileSwitched);
            profileManager.SubscribeToNewProfileCreated(OnNewProfileCreated);

            // Initialize cache from current profile
            RefreshCurrencyCache();

            isInitialized = true;
            Debug.Log("[CurrencyManager] Initialized successfully");
        }

        /// <summary>
        /// Refresh the currency cache from the current profile
        /// </summary>
        private void RefreshCurrencyCache()
        {
            var profile = profileManager.ActiveProfile;
            if (profile != null)
            {
                cachedNeuralCredits = profile.NeuralCredits;
                cachedCyberCoins = profile.CyberCoins;
                Debug.Log($"[CurrencyManager] Refreshed currency cache: NC: {cachedNeuralCredits}, CC: {cachedCyberCoins}");
            }
            else
            {
                cachedNeuralCredits = 0;
                cachedCyberCoins = 0;
                Debug.LogWarning("[CurrencyManager] No active profile found during cache refresh");
            }
        }

        /// <summary>
        /// Event handler for when a profile is switched
        /// </summary>
        private void OnProfileSwitched(string profileId)
        {
            Debug.Log($"[CurrencyManager] Profile switched to {profileId}, refreshing currency");
            RefreshCurrencyCache();
        }

        /// <summary>
        /// Event handler for when a new profile is created
        /// </summary>
        private void OnNewProfileCreated(string profileId)
        {
            Debug.Log($"[CurrencyManager] New profile created: {profileId}, initializing starting currency");
            SetupInitialCurrency(profileId);
        }

        /// <summary>
        /// Sets up the initial currency for a new profile
        /// </summary>
        private async void SetupInitialCurrency(string profileId)
        {
            var profile = profileManager.GetProfile(profileId);
            if (profile == null) return;

            // Add starting currency
            profile.AddCurrency(neuralCreditStartAmount, CurrencyType.NeuralCredits);
            profile.AddCurrency(cyberCoinStartAmount, CurrencyType.CyberCoins);

            // Update profile
            await profileManager.UpdateProfileAsync(profile);

            // Refresh cache if this is the active profile
            if (profileManager.ActiveProfile?.ProfileId == profileId)
            {
                RefreshCurrencyCache();
            }

            Debug.Log($"[CurrencyManager] Initial currency setup for profile {profileId}: NC: {neuralCreditStartAmount}, CC: {cyberCoinStartAmount}");
        }

        #region Currency Operations

        /// <summary>
        /// Add currency to the player's balance
        /// </summary>
        /// <param name="amount">Amount to add (must be positive)</param>
        /// <param name="type">Type of currency to add</param>
        /// <returns>True if currency was added successfully, false otherwise</returns>
        public async Task<bool> AddCurrency(float amount, CurrencyType type)
        {
            if (!isInitialized || amount <= 0)
                return false;

            var profile = profileManager.ActiveProfile;
            if (profile == null)
            {
                Debug.LogError("[CurrencyManager] No active profile!");
                return false;
            }

            // Cache old values for event
            float oldAmount = type == CurrencyType.NeuralCredits ? cachedNeuralCredits : cachedCyberCoins;

            // Add currency to profile
            bool success = profile.AddCurrency(amount, type);
            if (!success)
            {
                Debug.LogError($"[CurrencyManager] Failed to add {amount} {type} currency");
                return false;
            }

            // Update profile
            var result = await profileManager.UpdateProfileAsync(profile);
            if (!result.Success)
            {
                Debug.LogError($"[CurrencyManager] Failed to update profile: {result.Message}");
                return false;
            }

            // Update cache
            if (type == CurrencyType.NeuralCredits)
                cachedNeuralCredits += amount;
            else
                cachedCyberCoins += amount;

            // Fire events
            float newAmount = type == CurrencyType.NeuralCredits ? cachedNeuralCredits : cachedCyberCoins;
            OnCurrencyAdded?.Invoke(type, amount);
            OnCurrencyChanged?.Invoke(type, oldAmount, newAmount);

            GameEvents.OnCurrencyChanged?.Invoke((int)newAmount);

            Debug.Log($"[CurrencyManager] Added {amount} {type}. New balance: {newAmount}");
            return true;
        }

        /// <summary>
        /// Spend currency from the player's balance
        /// </summary>
        /// <param name="amount">Amount to spend (must be positive)</param>
        /// <param name="type">Type of currency to spend</param>
        /// <returns>True if sufficient funds were available and spent, false otherwise</returns>
        public async Task<bool> SpendCurrency(float amount, CurrencyType type)
        {
            if (!isInitialized || amount <= 0)
                return false;

            var profile = profileManager.ActiveProfile;
            if (profile == null)
            {
                Debug.LogError("[CurrencyManager] No active profile!");
                return false;
            }

            // Check if player has enough currency
            float currentAmount = type == CurrencyType.NeuralCredits ? cachedNeuralCredits : cachedCyberCoins;
            if (currentAmount < amount)
            {
                Debug.Log($"[CurrencyManager] Insufficient {type} funds. Required: {amount}, Available: {currentAmount}");
                OnInsufficientFunds?.Invoke(type);
                return false;
            }

            // Cache old value for event
            float oldAmount = currentAmount;

            // Spend currency
            bool success = profile.SpendCurrency(amount, type);
            if (!success)
            {
                Debug.LogError($"[CurrencyManager] Failed to spend {amount} {type} currency");
                OnInsufficientFunds?.Invoke(type);
                return false;
            }

            // Update profile
            var result = await profileManager.UpdateProfileAsync(profile);
            if (!result.Success)
            {
                Debug.LogError($"[CurrencyManager] Failed to update profile: {result.Message}");
                return false;
            }

            // Update cache
            if (type == CurrencyType.NeuralCredits)
                cachedNeuralCredits -= amount;
            else
                cachedCyberCoins -= amount;

            // Fire events
            float newAmount = type == CurrencyType.NeuralCredits ? cachedNeuralCredits : cachedCyberCoins;
            OnCurrencySpent?.Invoke(type, amount);
            OnCurrencyChanged?.Invoke(type, oldAmount, newAmount);

            GameEvents.OnCurrencyChanged?.Invoke((int)newAmount);

            Debug.Log($"[CurrencyManager] Spent {amount} {type}. New balance: {newAmount}");
            return true;
        }

        /// <summary>
        /// Check if the player has enough currency without spending it
        /// </summary>
        /// <param name="amount">Amount to check</param>
        /// <param name="type">Type of currency to check</param>
        /// <returns>True if player has sufficient funds, false otherwise</returns>
        public bool HasSufficientFunds(float amount, CurrencyType type)
        {
            if (!isInitialized || amount <= 0)
                return false;

            if (type == CurrencyType.NeuralCredits)
                return cachedNeuralCredits >= amount;
            else
                return cachedCyberCoins >= amount;
        }

        #endregion

        /// <summary>
        /// Cleanup when the manager is destroyed
        /// </summary>
        protected override void OnManagerDestroyed()
        {
            if (profileManager != null)
            {
                profileManager.UnsubscribeFromProfileSwitched(OnProfileSwitched);
                profileManager.UnsubscribeFromNewProfileCreated(OnNewProfileCreated);
            }

            base.OnManagerDestroyed();
        }
    }
}
// --- END FILE ---

// File: Shop/Equipment/EquipmentManager.cs
// Size: 18645 characters
// ---
// File: Assets/Code/Shop/Equipment/EquipmentManager.cs
//
// Purpose: Manages all equipment data and operations in Cyber Pickle.
// Handles equipping, unequipping, loading, and equipment state tracking.
// Works with the profile system to persist equipment data.
//
// Created: 2025-02-25
// Updated: 2025-02-25

using UnityEngine;
using System;
using System.Collections.Generic;
using System.Linq;
using CyberPickle.Core.Management;
using CyberPickle.Core.Interfaces;
using CyberPickle.Core.Services.Authentication;
using CyberPickle.Core.Services.Authentication.Data;
using CyberPickle.Shop.Equipment.Data;
using CyberPickle.Core.Events;

namespace CyberPickle.Shop.Equipment
{
    /// <summary>
    /// Manager class for all equipment operations in the game.
    /// Provides methods for loading, equipping, and managing equipment.
    /// </summary>
    public class EquipmentManager : Manager<EquipmentManager>, IInitializable
    {
        [Header("Equipment Data")]
        [SerializeField] private WeaponData[] availableWeapons;
        [SerializeField] private PowerUpData[] availablePowerUps;
        [SerializeField] private ArmorData[] availableArmors;
        [SerializeField] private AmuletData[] availableAmulets;

        [Header("Default Equipment")]
        [SerializeField] private WeaponData defaultHandWeapon;
        [SerializeField] private ArmorData defaultArmor;

        // Events
        public event Action<EquipmentData> OnEquipmentEquipped;
        public event Action<EquipmentData> OnEquipmentUnequipped;
        public event Action<EquipmentData> OnEquipmentUnlocked;
        public event Action<EquipmentData, int> OnEquipmentUpgraded;

        // Dependencies
        private ProfileManager profileManager;

        // Cached data lookups
        private Dictionary<string, EquipmentData> equipmentDataLookup = new Dictionary<string, EquipmentData>();
        private Dictionary<EquipmentSlotType, List<EquipmentData>> equipmentBySlotType = new Dictionary<EquipmentSlotType, List<EquipmentData>>();

        // Initialization flag
        private bool isInitialized = false;

        /// <summary>
        /// Initialize the Equipment Manager
        /// </summary>
        public void Initialize()
        {
            if (isInitialized) return;

            Debug.Log("[EquipmentManager] Initializing...");

            // Get profile manager reference
            profileManager = ProfileManager.Instance;
            if (profileManager == null)
            {
                Debug.LogError("[EquipmentManager] ProfileManager not found!");
                return;
            }

            // Setup data lookups
            BuildEquipmentLookups();

            // Subscribe to profile events
            profileManager.SubscribeToProfileSwitched(OnProfileSwitched);

            isInitialized = true;
            Debug.Log("[EquipmentManager] Initialized successfully");
        }

        /// <summary>
        /// Builds the equipment lookup dictionaries for quick access
        /// </summary>
        private void BuildEquipmentLookups()
        {
            equipmentDataLookup.Clear();
            equipmentBySlotType.Clear();

            // Initialize slot type lists
            foreach (EquipmentSlotType slotType in Enum.GetValues(typeof(EquipmentSlotType)))
            {
                equipmentBySlotType[slotType] = new List<EquipmentData>();
            }

            // Add all weapons
            foreach (var weapon in availableWeapons)
            {
                if (weapon == null) continue;
                AddToLookups(weapon);
            }

            // Add all power-ups
            foreach (var powerUp in availablePowerUps)
            {
                if (powerUp == null) continue;
                AddToLookups(powerUp);
            }

            // Add all armors
            foreach (var armor in availableArmors)
            {
                if (armor == null) continue;
                AddToLookups(armor);
            }

            // Add all amulets
            foreach (var amulet in availableAmulets)
            {
                if (amulet == null) continue;
                AddToLookups(amulet);
            }

            Debug.Log($"[EquipmentManager] Built equipment lookups with {equipmentDataLookup.Count} items");
        }

        /// <summary>
        /// Adds an equipment item to the lookup dictionaries
        /// </summary>
        private void AddToLookups(EquipmentData equipment)
        {
            if (equipment == null || string.IsNullOrEmpty(equipment.equipmentId)) return;

            // Add to ID lookup
            equipmentDataLookup[equipment.equipmentId] = equipment;

            // Add to slot type lookup
            if (equipmentBySlotType.TryGetValue(equipment.slotType, out var slotList))
            {
                slotList.Add(equipment);
            }
        }

        /// <summary>
        /// Event handler for when the profile is switched
        /// </summary>
        private void OnProfileSwitched(string profileId)
        {
            Debug.Log($"[EquipmentManager] Profile switched to {profileId}");
            // Nothing specific needed here, equipment state is stored in profile
        }

        #region Equipment Operations

        /// <summary>
        /// Equips an item for the active character
        /// </summary>
        /// <param name="equipmentId">ID of the equipment to equip</param>
        /// <returns>True if equipped successfully, false otherwise</returns>
        public bool EquipItem(string equipmentId)
        {
            if (!isInitialized || string.IsNullOrEmpty(equipmentId))
                return false;

            // Get the equipment data
            if (!equipmentDataLookup.TryGetValue(equipmentId, out var equipmentData))
            {
                Debug.LogError($"[EquipmentManager] Equipment with ID {equipmentId} not found!");
                return false;
            }

            // Get active profile
            var profile = profileManager.ActiveProfile;
            if (profile == null)
            {
                Debug.LogError("[EquipmentManager] No active profile!");
                return false;
            }

            // Check if equipment is unlocked
            if (!profile.IsEquipmentUnlocked(equipmentId) && !equipmentData.unlockedByDefault)
            {
                Debug.LogError($"[EquipmentManager] Equipment {equipmentId} is not unlocked!");
                return false;
            }

            // Get active character's progression data
            string characterId = GetActiveCharacterId();
            if (string.IsNullOrEmpty(characterId) || !profile.CharacterProgress.TryGetValue(characterId, out var characterData))
            {
                Debug.LogError("[EquipmentManager] No active character or character progress not found!");
                return false;
            }

            // Equip the item based on type
            bool success = characterData.EquipItem(equipmentId, equipmentData.slotType);
            if (success)
            {
                Debug.Log($"[EquipmentManager] Successfully equipped {equipmentData.displayName} ({equipmentId})");
                OnEquipmentEquipped?.Invoke(equipmentData);

                // Update profile data
                profileManager.UpdateProfileAsync(profile).ContinueWith(_ => {
                    Debug.Log("[EquipmentManager] Profile updated after equipment change");
                });
            }
            else
            {
                Debug.LogError($"[EquipmentManager] Failed to equip {equipmentData.displayName} ({equipmentId})");
            }

            return success;
        }

        /// <summary>
        /// Unequips an item from the active character
        /// </summary>
        /// <param name="equipmentId">ID of the equipment to unequip</param>
        /// <returns>True if unequipped successfully, false otherwise</returns>
        /// <summary>
        /// Unequips an item from the active character
        /// </summary>
        /// <param name="equipmentId">ID of the equipment to unequip</param>
        /// <returns>True if unequipped successfully, false otherwise</returns>
        public bool UnequipItem(string equipmentId)
        {
            if (!isInitialized || string.IsNullOrEmpty(equipmentId))
                return false;

            // Get equipment data for event broadcast later
            if (!equipmentDataLookup.TryGetValue(equipmentId, out var equipmentData))
            {
                Debug.LogError($"[EquipmentManager] Equipment with ID {equipmentId} not found!");
                return false;
            }

            // Get active profile and character
            var profile = profileManager.ActiveProfile;
            if (profile == null)
            {
                Debug.LogError("[EquipmentManager] No active profile!");
                return false;
            }

            // Get active character's progression data
            string characterId = GetActiveCharacterId();
            if (string.IsNullOrEmpty(characterId) || !profile.CharacterProgress.TryGetValue(characterId, out var characterData))
            {
                Debug.LogError("[EquipmentManager] No active character or character progress not found!");
                return false;
            }

            // Check if the item is equipped
            if (!characterData.IsEquipped(equipmentId))
            {
                Debug.LogWarning($"[EquipmentManager] Equipment {equipmentId} is not equipped");
                return false;
            }

            // Unequip the item using our extension method
            bool success = characterData.UnequipItem(equipmentId);

            if (success)
            {
                Debug.Log($"[EquipmentManager] Successfully unequipped {equipmentData.displayName} ({equipmentId})");
                OnEquipmentUnequipped?.Invoke(equipmentData);

                // Update profile data
                profileManager.UpdateProfileAsync(profile).ContinueWith(_ => {
                    Debug.Log("[EquipmentManager] Profile updated after equipment change");
                });
            }
            else
            {
                Debug.LogError($"[EquipmentManager] Failed to unequip {equipmentData.displayName} ({equipmentId})");
            }

            return success;
        }

        /// <summary>
        /// Unlocks a piece of equipment in the profile
        /// </summary>
        /// <param name="equipmentId">ID of the equipment to unlock</param>
        /// <returns>True if unlocked successfully, false otherwise</returns>
        public bool UnlockEquipment(string equipmentId)
        {
            if (!isInitialized || string.IsNullOrEmpty(equipmentId))
                return false;

            // Get the equipment data
            if (!equipmentDataLookup.TryGetValue(equipmentId, out var equipmentData))
            {
                Debug.LogError($"[EquipmentManager] Equipment with ID {equipmentId} not found!");
                return false;
            }

            // Get active profile
            var profile = profileManager.ActiveProfile;
            if (profile == null)
            {
                Debug.LogError("[EquipmentManager] No active profile!");
                return false;
            }

            // Check if already unlocked
            if (profile.IsEquipmentUnlocked(equipmentId))
            {
                Debug.Log($"[EquipmentManager] Equipment {equipmentId} is already unlocked");
                return true;
            }

            // Unlock the equipment
            bool success = profile.UnlockEquipment(equipmentId);
            if (success)
            {
                Debug.Log($"[EquipmentManager] Successfully unlocked {equipmentData.displayName} ({equipmentId})");
                OnEquipmentUnlocked?.Invoke(equipmentData);

                // Update profile data
                profileManager.UpdateProfileAsync(profile).ContinueWith(_ => {
                    Debug.Log("[EquipmentManager] Profile updated after equipment unlock");
                });
            }
            else
            {
                Debug.LogError($"[EquipmentManager] Failed to unlock {equipmentData.displayName} ({equipmentId})");
            }

            return success;
        }

        #endregion

        #region Equipment Queries

        /// <summary>
        /// Get the active character ID from the current profile
        /// </summary>
        private string GetActiveCharacterId()
        {
            var profile = profileManager.ActiveProfile;
            if (profile == null)
                return null;

            // The active character ID would typically come from the profile
            // This might need to be retrieved differently depending on your implementation
            return profile.ProfileId; // Using profile ID as the character ID for now
        }

        /// <summary>
        /// Gets equipment data by ID
        /// </summary>
        /// <param name="equipmentId">ID of the equipment</param>
        /// <returns>Equipment data or null if not found</returns>
        public EquipmentData GetEquipmentById(string equipmentId)
        {
            if (string.IsNullOrEmpty(equipmentId) || !equipmentDataLookup.TryGetValue(equipmentId, out var equipmentData))
                return null;

            return equipmentData;
        }

        /// <summary>
        /// Gets all equipment of a specific slot type
        /// </summary>
        /// <param name="slotType">Slot type to filter by</param>
        /// <returns>List of equipment data for that slot</returns>
        public List<EquipmentData> GetEquipmentBySlotType(EquipmentSlotType slotType)
        {
            if (equipmentBySlotType.TryGetValue(slotType, out var equipmentList))
                return new List<EquipmentData>(equipmentList);

            return new List<EquipmentData>();
        }

        /// <summary>
        /// Gets all equipment that is currently unlocked for the active profile
        /// </summary>
        /// <returns>List of unlocked equipment</returns>
        public List<EquipmentData> GetUnlockedEquipment()
        {
            var profile = profileManager.ActiveProfile;
            if (profile == null)
                return new List<EquipmentData>();

            var unlockedEquipment = new List<EquipmentData>();
            foreach (var equipment in equipmentDataLookup.Values)
            {
                if (profile.IsEquipmentUnlocked(equipment.equipmentId) || equipment.unlockedByDefault)
                {
                    unlockedEquipment.Add(equipment);
                }
            }

            return unlockedEquipment;
        }

        /// <summary>
        /// Gets all equipment of a specific type that is currently unlocked
        /// </summary>
        /// <param name="slotType">Slot type to filter by</param>
        /// <returns>List of unlocked equipment of the specified type</returns>
        public List<EquipmentData> GetUnlockedEquipmentByType(EquipmentSlotType slotType)
        {
            return GetUnlockedEquipment().Where(e => e.slotType == slotType).ToList();
        }

        /// <summary>
        /// Gets all equipment currently equipped on the active character
        /// </summary>
        /// <returns>Dictionary of equipped items by slot type</returns>
        public Dictionary<EquipmentSlotType, List<EquipmentData>> GetEquippedEquipment()
        {
            var result = new Dictionary<EquipmentSlotType, List<EquipmentData>>();

            // Initialize all slot types with empty lists
            foreach (EquipmentSlotType slotType in Enum.GetValues(typeof(EquipmentSlotType)))
            {
                result[slotType] = new List<EquipmentData>();
            }

            // Get active profile and character
            var profile = profileManager.ActiveProfile;
            if (profile == null)
                return result;

            string characterId = GetActiveCharacterId();
            if (string.IsNullOrEmpty(characterId) || !profile.CharacterProgress.TryGetValue(characterId, out var characterData))
                return result;

            // Add hand weapons
            foreach (var weaponId in characterData.EquippedHandWeapons)
            {
                if (equipmentDataLookup.TryGetValue(weaponId, out var weaponData))
                {
                    result[EquipmentSlotType.HandWeapon].Add(weaponData);
                }
            }

            // Add body weapon
            if (!string.IsNullOrEmpty(characterData.EquippedBodyWeapon) &&
                equipmentDataLookup.TryGetValue(characterData.EquippedBodyWeapon, out var bodyWeaponData))
            {
                result[EquipmentSlotType.BodyWeapon].Add(bodyWeaponData);
            }

            // Add power-ups
            foreach (var powerUpId in characterData.EquippedPowerupIds)
            {
                if (equipmentDataLookup.TryGetValue(powerUpId, out var powerUpData))
                {
                    result[EquipmentSlotType.PowerUp].Add(powerUpData);
                }
            }

            // Add armor
            if (!string.IsNullOrEmpty(characterData.EquippedArmor) &&
                equipmentDataLookup.TryGetValue(characterData.EquippedArmor, out var armorData))
            {
                result[EquipmentSlotType.Armor].Add(armorData);
            }

            // Add amulet
            if (!string.IsNullOrEmpty(characterData.EquippedAmulet) &&
                equipmentDataLookup.TryGetValue(characterData.EquippedAmulet, out var amuletData))
            {
                result[EquipmentSlotType.Amulet].Add(amuletData);
            }

            return result;
        }

        #endregion

        protected override void OnManagerDestroyed()
        {
            if (profileManager != null)
            {
                profileManager.UnsubscribeFromProfileSwitched(OnProfileSwitched);
            }

            base.OnManagerDestroyed();
        }
    }
}

// --- END FILE ---

// File: Shop/Mining/MiningManager.cs
// Size: 17111 characters
// ---
// File: Assets/Code/Shop/Mining/MiningManager.cs
//
// Purpose: Manages the Neural Mining System in Cyber Pickle.
// Handles node management, passive income generation, collection, and upgrades.
// Works with the profile system to persist mining data.
//
// Created: 2025-02-25
// Updated: 2025-02-25

using UnityEngine;
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using CyberPickle.Core.Management;
using CyberPickle.Core.Interfaces;
using CyberPickle.Core.Services.Authentication;
using CyberPickle.Core.Services.Authentication.Data;
using CyberPickle.Shop.Currency;

namespace CyberPickle.Shop.Mining
{
    /// <summary>
    /// Manager for the Neural Mining System
    /// </summary>
    public class MiningManager : Manager<MiningManager>, IInitializable
    {
        [Header("Mining Settings")]
        [SerializeField] private float basePassiveRate = 10f;        // CyberCoins per hour per node
        [SerializeField] private float activePlayRate = 30f;         // CyberCoins per hour per node during active play
        [SerializeField] private float levelUpgradeMultiplier = 0.2f; // 20% increase per level
        [SerializeField] private int maxNodeLevel = 10;
        [SerializeField] private float maxOfflineHours = 24f;        // Maximum hours of offline collection

        [Header("Node Costs")]
        [SerializeField] private int firstNodeCost = 0;              // First node is free
        [SerializeField] private int baseNodeCost = 500;             // Base cost for new nodes
        [SerializeField] private float nodeScalingFactor = 1.5f;     // Cost multiplier per node
        [SerializeField] private int baseUpgradeCost = 250;          // Base cost for upgrading nodes
        [SerializeField] private float upgradeLevelScalingFactor = 2f; // Cost multiplier per level

        // Events
        public event Action<float> OnCyberCoinsCollected;
        public event Action<string, int> OnNodeUpgraded;
        public event Action<string> OnNodePurchased;
        public event Action<float> OnPerformanceMultiplierApplied;
        public event Action<Dictionary<string, MiningNodeData>> OnMiningStatsUpdated;

        // Dependencies
        private ProfileManager profileManager;
        private CurrencyManager currencyManager;

        // Runtime tracking
        private DateTime lastCollectionTime;
        private float currentPerformanceMultiplier = 1f;
        private bool isPlaying = false;

        // Initialization flag
        private bool isInitialized = false;

        /// <summary>
        /// Initialize the Mining Manager
        /// </summary>
        public void Initialize()
        {
            if (isInitialized) return;

            Debug.Log("[MiningManager] Initializing...");

            // Get dependencies
            profileManager = ProfileManager.Instance;
            currencyManager = CurrencyManager.Instance;

            if (profileManager == null)
            {
                Debug.LogError("[MiningManager] ProfileManager not found!");
                return;
            }

            if (currencyManager == null)
            {
                Debug.LogError("[MiningManager] CurrencyManager not found!");
                return;
            }

            // Subscribe to profile events
            profileManager.SubscribeToProfileSwitched(OnProfileSwitched);
            profileManager.SubscribeToNewProfileCreated(OnNewProfileCreated);

            // Set last collection time to now
            lastCollectionTime = DateTime.UtcNow;

            isInitialized = true;
            Debug.Log("[MiningManager] Initialized successfully");
        }

        private void OnEnable()
        {
            if (isInitialized)
            {
                // Set up automatic collection check
                InvokeRepeating(nameof(UpdateMiningStats), 1f, 60f); // Check every minute
            }
        }

        private void OnDisable()
        {
            CancelInvoke(nameof(UpdateMiningStats));
        }

        /// <summary>
        /// Event handler for when a profile is switched
        /// </summary>
        private void OnProfileSwitched(string profileId)
        {
            Debug.Log($"[MiningManager] Profile switched to {profileId}");
            // Reset last collection time
            lastCollectionTime = DateTime.UtcNow;
            // Reset performance multiplier
            currentPerformanceMultiplier = 1f;
            // Update mining stats
            UpdateMiningStats();
        }

        /// <summary>
        /// Event handler for when a new profile is created
        /// </summary>
        private void OnNewProfileCreated(string profileId)
        {
            Debug.Log($"[MiningManager] New profile created: {profileId}");
            // Add starter node for new profile
            AddStarterNode(profileId);
        }

        /// <summary>
        /// Add a starter mining node for a new profile
        /// </summary>
        private async void AddStarterNode(string profileId)
        {
            var profile = profileManager.GetProfile(profileId);
            if (profile == null) return;

            // Add first node for free
            string nodeId = $"node_{Guid.NewGuid().ToString().Substring(0, 8)}";
            MiningNodeData starterNode = new MiningNodeData(nodeId)
            {
                // Default properties are set in the constructor
            };

            // Add to profile
            if (profile.MiningNodes.Count == 0)
            {
                var miningNodes = profile.MiningNodes as Dictionary<string, MiningNodeData>;
                if (miningNodes != null)
                {
                    miningNodes[nodeId] = starterNode;
                    await profileManager.UpdateProfileAsync(profile);
                    Debug.Log($"[MiningManager] Added starter node {nodeId} to profile {profileId}");
                    OnNodePurchased?.Invoke(nodeId);
                }
            }
        }

        #region Mining Node Management

        /// <summary>
        /// Purchase a new mining node
        /// </summary>
        /// <returns>True if successful, false otherwise</returns>
        public async Task<bool> PurchaseNewNode()
        {
            if (!isInitialized)
                return false;

            var profile = profileManager.ActiveProfile;
            if (profile == null)
                return false;

            // Calculate cost based on current node count
            int nodeCount = profile.MiningNodes.Count;
            int cost = CalculateNodePurchaseCost(nodeCount);

            // Check if player has enough Neural Credits
            if (!currencyManager.HasSufficientFunds(cost, CurrencyType.NeuralCredits))
            {
                Debug.Log($"[MiningManager] Insufficient Neural Credits to purchase node. Required: {cost}, Available: {currencyManager.NeuralCredits}");
                return false;
            }

            // Spend Neural Credits
            bool spentSuccess = await currencyManager.SpendCurrency(cost, CurrencyType.NeuralCredits);
            if (!spentSuccess)
                return false;

            // Create new node
            string nodeId = $"node_{Guid.NewGuid().ToString().Substring(0, 8)}";
            MiningNodeData newNode = new MiningNodeData(nodeId);

            // Add to profile
            var miningNodes = profile.MiningNodes as Dictionary<string, MiningNodeData>;
            if (miningNodes != null)
            {
                miningNodes[nodeId] = newNode;
                await profileManager.UpdateProfileAsync(profile);
                Debug.Log($"[MiningManager] Purchased new node {nodeId} for {cost} Neural Credits");
                OnNodePurchased?.Invoke(nodeId);
                return true;
            }

            // Failed to add node, refund Neural Credits
            await currencyManager.AddCurrency(cost, CurrencyType.NeuralCredits);
            return false;
        }

        /// <summary>
        /// Upgrade a mining node
        /// </summary>
        /// <param name="nodeId">ID of the node to upgrade</param>
        /// <returns>True if successful, false otherwise</returns>
        public async Task<bool> UpgradeNode(string nodeId)
        {
            if (!isInitialized || string.IsNullOrEmpty(nodeId))
                return false;

            var profile = profileManager.ActiveProfile;
            if (profile == null)
                return false;

            // Get the node
            var miningNodes = profile.MiningNodes as Dictionary<string, MiningNodeData>;
            if (miningNodes == null || !miningNodes.TryGetValue(nodeId, out var node))
            {
                Debug.LogError($"[MiningManager] Node {nodeId} not found");
                return false;
            }

            // Check if node is already at max level
            if (node.Level >= maxNodeLevel)
            {
                Debug.Log($"[MiningManager] Node {nodeId} is already at max level {maxNodeLevel}");
                return false;
            }

            // Calculate upgrade cost
            int cost = CalculateNodeUpgradeCost(node.Level);

            // Check if player has enough Neural Credits
            if (!currencyManager.HasSufficientFunds(cost, CurrencyType.NeuralCredits))
            {
                Debug.Log($"[MiningManager] Insufficient Neural Credits to upgrade node. Required: {cost}, Available: {currencyManager.NeuralCredits}");
                return false;
            }

            // Spend Neural Credits
            bool spentSuccess = await currencyManager.SpendCurrency(cost, CurrencyType.NeuralCredits);
            if (!spentSuccess)
                return false;

            // Upgrade node
            bool upgradeSuccess = node.Upgrade();
            if (!upgradeSuccess)
            {
                // Refund Neural Credits if upgrade fails
                await currencyManager.AddCurrency(cost, CurrencyType.NeuralCredits);
                return false;
            }

            // Update profile
            await profileManager.UpdateProfileAsync(profile);
            Debug.Log($"[MiningManager] Upgraded node {nodeId} to level {node.Level} for {cost} Neural Credits");
            OnNodeUpgraded?.Invoke(nodeId, node.Level);
            return true;
        }

        /// <summary>
        /// Calculate the cost to purchase a new node
        /// </summary>
        /// <param name="currentNodeCount">Current number of nodes</param>
        /// <returns>Cost in Neural Credits</returns>
        public int CalculateNodePurchaseCost(int currentNodeCount)
        {
            if (currentNodeCount == 0)
                return firstNodeCost;

            return Mathf.RoundToInt(baseNodeCost * Mathf.Pow(nodeScalingFactor, currentNodeCount - 1));
        }

        /// <summary>
        /// Calculate the cost to upgrade a node
        /// </summary>
        /// <param name="currentLevel">Current level of the node</param>
        /// <returns>Cost in Neural Credits</returns>
        public int CalculateNodeUpgradeCost(int currentLevel)
        {
            return Mathf.RoundToInt(baseUpgradeCost * Mathf.Pow(upgradeLevelScalingFactor, currentLevel - 1));
        }

        #endregion

        #region Mining Collection

        /// <summary>
        /// Collect accumulated CyberCoins
        /// </summary>
        /// <returns>Amount of CyberCoins collected</returns>
        public async Task<float> CollectMining()
        {
            if (!isInitialized)
                return 0f;

            var profile = profileManager.ActiveProfile;
            if (profile == null)
                return 0f;

            // Calculate how many hours have passed since last collection
            TimeSpan timeSinceLastCollection = DateTime.UtcNow - lastCollectionTime;
            float hoursElapsed = Mathf.Min((float)timeSinceLastCollection.TotalHours, maxOfflineHours);

            // Calculate total earnings
            float totalEarnings = await CalculatePendingEarnings();

            // If there's anything to collect
            if (totalEarnings > 0)
            {
                // Add CyberCoins to player's balance
                await currencyManager.AddCurrency(totalEarnings, CurrencyType.CyberCoins);

                // Reset collection time
                lastCollectionTime = DateTime.UtcNow;

                // Reset performance multiplier after collection
                currentPerformanceMultiplier = 1f;

                Debug.Log($"[MiningManager] Collected {totalEarnings} CyberCoins after {hoursElapsed:F1} hours");
                OnCyberCoinsCollected?.Invoke(totalEarnings);
            }

            return totalEarnings;
        }

        /// <summary>
        /// Calculate pending earnings from all mining nodes
        /// </summary>
        /// <returns>Total pending CyberCoins</returns>
        public async Task<float> CalculatePendingEarnings()
        {
            if (!isInitialized)
                return 0f;

            var profile = profileManager.ActiveProfile;
            if (profile == null)
                return 0f;

            float totalEarnings = 0f;

            // Get all nodes
            var miningNodes = profile.MiningNodes;
            foreach (var node in miningNodes.Values)
            {
                // Calculate earnings for this node
                float nodeEarnings = node.PendingCoins;
                totalEarnings += nodeEarnings;
            }

            // Apply performance multiplier
            totalEarnings *= currentPerformanceMultiplier;

            return totalEarnings;
        }

        /// <summary>
        /// Apply a performance multiplier to mining rate based on gameplay
        /// </summary>
        /// <param name="multiplier">Multiplier to apply</param>
        public void ApplyPerformanceMultiplier(float multiplier)
        {
            // Ensure multiplier is at least 1.0
            multiplier = Mathf.Max(1f, multiplier);

            // If the new multiplier is higher, use it
            if (multiplier > currentPerformanceMultiplier)
            {
                currentPerformanceMultiplier = multiplier;
                Debug.Log($"[MiningManager] Applied performance multiplier: {multiplier:F2}x");
                OnPerformanceMultiplierApplied?.Invoke(multiplier);
            }
        }

        /// <summary>
        /// Update mining stats and notify listeners
        /// </summary>
        private void UpdateMiningStats()
        {
            if (!isInitialized) return;

            var profile = profileManager.ActiveProfile;
            if (profile == null) return;

            // Notify listeners
            OnMiningStatsUpdated?.Invoke(profile.MiningNodes as Dictionary<string, MiningNodeData>);
        }

        /// <summary>
        /// Get the current mining rate
        /// </summary>
        /// <returns>Mining rate in CyberCoins per hour</returns>
        public float GetCurrentMiningRate()
        {
            if (!isInitialized)
                return 0f;

            var profile = profileManager.ActiveProfile;
            if (profile == null)
                return 0f;

            float totalRate = 0f;

            // Calculate rate from all nodes
            foreach (var node in profile.MiningNodes.Values)
            {
                // Rate depends on whether game is being played
                float nodeRate = isPlaying ? activePlayRate : basePassiveRate;

                // Apply level bonus
                nodeRate *= (1f + (node.Level - 1) * levelUpgradeMultiplier);

                totalRate += nodeRate;
            }

            // Apply performance multiplier
            totalRate *= currentPerformanceMultiplier;

            return totalRate;
        }

        /// <summary>
        /// Set the gameplay state for mining rate calculation
        /// </summary>
        /// <param name="playing">Whether the game is being played</param>
        public void SetPlayingState(bool playing)
        {
            isPlaying = playing;
            Debug.Log($"[MiningManager] Playing state set to: {playing}");
        }

        #endregion

        protected override void OnManagerDestroyed()
        {
            if (profileManager != null)
            {
                profileManager.UnsubscribeFromProfileSwitched(OnProfileSwitched);
                profileManager.UnsubscribeFromNewProfileCreated(OnNewProfileCreated);
            }

            CancelInvoke(nameof(UpdateMiningStats));

            base.OnManagerDestroyed();
        }
    }
}
// --- END FILE ---

// File: UI/Effects/GlitchTextEffect.cs
// Size: 7856 characters
// ---
using UnityEngine;
using TMPro;
using System.Collections;
using CyberPickle.UI.Effects.Config;

namespace CyberPickle.UI.Effects
{
    [RequireComponent(typeof(TextMeshProUGUI))]
    public class GlitchTextEffect : MonoBehaviour
    {
        [SerializeField] private GlitchTextConfig config;

        private TextMeshProUGUI textMesh;
        private Material glitchMaterial;
        private string originalText;

        void Start()
        {
            if (config == null)
            {
                Debug.LogError("GlitchTextConfig not assigned to GlitchTextEffect on " + gameObject.name);
                return;
            }

            textMesh = GetComponent<TextMeshProUGUI>();
            glitchMaterial = textMesh.fontMaterial;
            originalText = textMesh.text;

            if (glitchMaterial.shader.name != "TextMeshPro/Distance Field Glitch")
            {
                Debug.LogWarning("Please assign the 'TextMeshPro/Distance Field Glitch with Scanlines and Chromatic Aberration' shader to the font material.");
            }

            UpdateShaderProperties();
            StartCoroutine(FadeInRoutine());
            StartCoroutine(GlitchTextRoutine());
            StartCoroutine(RandomCharRoutine());
            StartCoroutine(PulseRoutine());
            StartCoroutine(DynamicGlitchIntensityRoutine());
            StartCoroutine(CharacterColorGlitchRoutine());
        }

        void OnValidate()
        {
            if (glitchMaterial == null)
            {
                textMesh = GetComponent<TextMeshProUGUI>();
                if (textMesh != null)
                {
                    glitchMaterial = textMesh.fontMaterial;
                }
            }

            if (glitchMaterial != null && config != null)
            {
                UpdateShaderProperties();
            }
        }

        void UpdateShaderProperties()
        {
            glitchMaterial.SetFloat("_GlitchIntensity", config.glitchIntensity);
            glitchMaterial.SetFloat("_GlitchAmplitude", config.glitchAmplitude);
            glitchMaterial.SetFloat("_GlitchSpeed", config.glitchSpeed);
            glitchMaterial.SetFloat("_ScanlineIntensity", config.scanlineIntensity);
            glitchMaterial.SetFloat("_ScanlineSpeed", config.scanlineSpeed);
            glitchMaterial.SetFloat("_ScanlineFrequency", config.scanlineFrequency);
            glitchMaterial.SetFloat("_ChromAberration", config.chromAberration);
        }

        IEnumerator FadeInRoutine()
        {
            float elapsedTime = 0f;
            Color color = textMesh.color;
            color.a = 0f;
            textMesh.color = color;

            while (elapsedTime < config.fadeDuration)
            {
                elapsedTime += Time.deltaTime;
                color.a = Mathf.Clamp01(elapsedTime / config.fadeDuration);
                textMesh.color = color;
                yield return null;
            }

            color.a = 1f;
            textMesh.color = color;
        }

        IEnumerator GlitchTextRoutine()
        {
            while (true)
            {
                yield return new WaitForSeconds(config.glitchInterval);
                if (Random.value < config.glitchIntensity)
                {
                    UpdateShaderProperties();
                    yield return new WaitForSeconds(0.1f);
                    glitchMaterial.SetFloat("_RGBSplitAmount", 0f);
                    UpdateShaderProperties();
                }
            }
        }

        IEnumerator RandomCharRoutine()
        {
            while (true)
            {
                yield return new WaitForSeconds(Random.Range(config.randomCharIntervalMin, config.randomCharIntervalMax));
                if (Random.value < config.randomCharIntensity)
                {
                    int charIndex = Random.Range(0, originalText.Length);
                    char randomChar = (char)Random.Range(33, 126);
                    string glitchedText = originalText.Substring(0, charIndex) + randomChar + originalText.Substring(charIndex + 1);
                    textMesh.text = glitchedText;
                    yield return new WaitForSeconds(Random.Range(config.randomCharDisplayDurationMin, config.randomCharDisplayDurationMax));
                    textMesh.text = originalText;
                }
            }
        }

        IEnumerator PulseRoutine()
        {
            Vector3 originalScale = textMesh.transform.localScale;
            while (true)
            {
                float scale = Mathf.Lerp(1f, config.pulseScale, Mathf.PingPong(Time.time * config.pulseSpeed, 1));
                textMesh.transform.localScale = originalScale * scale;
                yield return null;
            }
        }

        IEnumerator DynamicGlitchIntensityRoutine()
        {
            while (true)
            {
                yield return new WaitForSeconds(Random.Range(0f, config.glitchIntensityInterval));
                config.glitchIntensity = Random.Range(config.glitchIntensityMin, config.glitchIntensityMax);
                UpdateShaderProperties();
                yield return new WaitForSeconds(config.glitchIntensityDuration);
                config.glitchIntensity = 0f;
                UpdateShaderProperties();
            }
        }

        IEnumerator CharacterColorGlitchRoutine()
        {
            while (true)
            {
                yield return new WaitForSeconds(Random.Range(5f, 15f));
                if (Random.value < config.colorGlitchIntensity)
                {
                    int charIndex = Random.Range(0, originalText.Length);
                    Color originalColor = textMesh.color;
                    Color glitchColor = Random.value > 0.5f ? new Color(0.0f, 1.0f, 1.0f) : new Color(1.0f, 0.0f, 1.0f);

                    TMP_TextInfo textInfo = textMesh.textInfo;
                    textMesh.ForceMeshUpdate();
                    var charInfo = textInfo.characterInfo[charIndex];
                    if (charInfo.isVisible)
                    {
                        int meshIndex = charInfo.materialReferenceIndex;
                        int vertexIndex = charInfo.vertexIndex;
                        Color32[] newVertexColors = textInfo.meshInfo[meshIndex].colors32;
                        newVertexColors[vertexIndex + 0] = glitchColor;
                        newVertexColors[vertexIndex + 1] = glitchColor;
                        newVertexColors[vertexIndex + 2] = glitchColor;
                        newVertexColors[vertexIndex + 3] = glitchColor;
                        textMesh.UpdateVertexData(TMP_VertexDataUpdateFlags.Colors32);
                    }
                    yield return new WaitForSeconds(config.colorGlitchDuration);

                    textMesh.ForceMeshUpdate();
                    var charInfoRestore = textInfo.characterInfo[charIndex];
                    if (charInfoRestore.isVisible)
                    {
                        int meshIndex = charInfoRestore.materialReferenceIndex;
                        int vertexIndex = charInfoRestore.vertexIndex;
                        Color32[] newVertexColors = textInfo.meshInfo[meshIndex].colors32;
                        newVertexColors[vertexIndex + 0] = originalColor;
                        newVertexColors[vertexIndex + 1] = originalColor;
                        newVertexColors[vertexIndex + 2] = originalColor;
                        newVertexColors[vertexIndex + 3] = originalColor;
                        textMesh.UpdateVertexData(TMP_VertexDataUpdateFlags.Colors32);
                    }
                }
            }
        }
    }
}

// --- END FILE ---

// File: UI/EquipmentHubManager/EquipmentHubManager.cs
// Size: 11249 characters
// ---
// File: Assets/Code/UI/EquipmentHub/EquipmentHubManager.cs
//
// Purpose: Manages the Equipment Hub scene where the player configures character equipment, 
// accesses the shop, and manages mining operations before starting a game. Controls the
// scene's UI sections and handles transitions between different parts of the Equipment Hub.
//
// Created: 2025-02-26
// Updated: 2025-02-26

using UnityEngine;
using System.Collections;
using CyberPickle.Core.Management;
using CyberPickle.Core.Interfaces;
using CyberPickle.Core.Events;
using CyberPickle.Core.States;
using CyberPickle.Core.Services.Authentication;
using CyberPickle.Core.Services.Authentication.Data;
using CyberPickle.Characters.Data;
using CyberPickle.UI.Transitions;
using UnityEngine.SceneManagement;

namespace CyberPickle.UI.EquipmentHub
{
    /// <summary>
    /// Manages the Equipment Hub scene where the player configures character equipment, 
    /// accesses the shop, and manages mining operations before starting a game
    /// </summary>
    public class EquipmentHubManager : Manager<EquipmentHubManager>, IInitializable
    {
        [Header("Scene References")]
        [SerializeField] private Transform characterSpawnPoint;
        [SerializeField] private FadeScreenController fadeController;

        [Header("UI Sections")]
        [SerializeField] private GameObject equipmentSection;
        [SerializeField] private GameObject shopSection;
        [SerializeField] private GameObject miningSection;
        [SerializeField] private GameObject navigationPanel;

        [Header("Navigation Buttons")]
        [SerializeField] private UnityEngine.UI.Button equipmentButton;
        [SerializeField] private UnityEngine.UI.Button shopButton;
        [SerializeField] private UnityEngine.UI.Button miningButton;
        [SerializeField] private UnityEngine.UI.Button startGameButton;
        [SerializeField] private UnityEngine.UI.Button backButton;

        // Manager dependencies
        private ProfileManager profileManager;

        // Runtime data
        private GameObject spawnedCharacter;
        private CharacterData currentCharacterData;
        private string currentCharacterId;
        private bool isInitialized = false;

        /// <summary>
        /// Initializes the Equipment Hub manager and UI
        /// </summary>
        public void Initialize()
        {
            if (isInitialized) return;

            Debug.Log("[EquipmentHubManager] Initializing");

            // Get manager dependencies
            profileManager = ProfileManager.Instance;
            if (profileManager == null)
            {
                Debug.LogError("[EquipmentHubManager] Profile Manager not found!");
                return;
            }

            // Set initial section visibility
            SetInitialVisibility();

            // Setup navigation buttons
            SetupNavigationButtons();

            // Load character model
            StartCoroutine(LoadCharacterModel());

            isInitialized = true;
            Debug.Log("[EquipmentHubManager] Initialized successfully");
        }

        /// <summary>
        /// Sets the initial visibility of UI sections
        /// </summary>
        private void SetInitialVisibility()
        {
            // Show equipment section by default, hide others
            if (equipmentSection != null) equipmentSection.SetActive(true);
            if (shopSection != null) shopSection.SetActive(false);
            if (miningSection != null) miningSection.SetActive(false);

            // Ensure navigation panel is visible
            if (navigationPanel != null) navigationPanel.SetActive(true);

            // Fade in the scene if fade controller exists
            if (fadeController != null)
                fadeController.FadeFromBlack();
        }

        /// <summary>
        /// Sets up button listeners for navigation
        /// </summary>
        private void SetupNavigationButtons()
        {
            if (equipmentButton != null)
                equipmentButton.onClick.AddListener(() => SwitchToSection("Equipment"));

            if (shopButton != null)
                shopButton.onClick.AddListener(() => SwitchToSection("Shop"));

            if (miningButton != null)
                miningButton.onClick.AddListener(() => SwitchToSection("Mining"));

            if (startGameButton != null)
                startGameButton.onClick.AddListener(StartGame);

            if (backButton != null)
                backButton.onClick.AddListener(ReturnToCharacterSelect);
        }

        /// <summary>
        /// Loads the selected character model
        /// </summary>
        private IEnumerator LoadCharacterModel()
        {
            // Get the character ID from profile (for now we'll use a placeholder)
            // Later this should come from the profile's selected character
            currentCharacterId = "default_character";

            // When we have profile integration, use this:
            // var profile = profileManager.ActiveProfile;
            // if (profile != null)
            //    currentCharacterId = profile.LastSelectedCharacterId;

            // Load character data - update path as needed for your project
            currentCharacterData = Resources.Load<CharacterData>($"Characters/{currentCharacterId}");

            if (currentCharacterData == null)
            {
                Debug.LogError($"[EquipmentHubManager] Character data not found for ID: {currentCharacterId}");
                yield break;
            }

            // Make sure we have a spawn point
            if (characterSpawnPoint == null)
            {
                Debug.LogError("[EquipmentHubManager] Character spawn point is null!");
                yield break;
            }

            // Instantiate the character model
            spawnedCharacter = Instantiate(currentCharacterData.characterPrefab, characterSpawnPoint);
            spawnedCharacter.transform.localPosition = Vector3.zero;
            spawnedCharacter.transform.localRotation = Quaternion.Euler(0, 180, 0); // Face forward

            // Setup character animations
            var animator = spawnedCharacter.GetComponent<Animator>();
            if (animator != null)
            {
                animator.SetTrigger("Idle");
            }

            Debug.Log($"[EquipmentHubManager] Character model loaded: {currentCharacterData.displayName}");

            // Initialize sections that need the character reference
            InitializeEquipmentSection();
        }

        /// <summary>
        /// Initializes the equipment section with character data
        /// </summary>
        private void InitializeEquipmentSection()
        {
            // Initialize equipment UI with character data
            // This would be expanded with your equipment UI logic
        }

        /// <summary>
        /// Switches the active section in the hub
        /// </summary>
        /// <param name="sectionName">The name of the section to activate</param>
        public void SwitchToSection(string sectionName)
        {
            // Hide all sections first
            if (equipmentSection != null) equipmentSection.SetActive(false);
            if (shopSection != null) shopSection.SetActive(false);
            if (miningSection != null) miningSection.SetActive(false);

            // Show the requested section
            switch (sectionName)
            {
                case "Equipment":
                    if (equipmentSection != null)
                    {
                        equipmentSection.SetActive(true);
                        Debug.Log("[EquipmentHubManager] Switched to Equipment section");
                    }
                    break;
                case "Shop":
                    if (shopSection != null)
                    {
                        shopSection.SetActive(true);
                        Debug.Log("[EquipmentHubManager] Switched to Shop section");
                    }
                    break;
                case "Mining":
                    if (miningSection != null)
                    {
                        miningSection.SetActive(true);
                        Debug.Log("[EquipmentHubManager] Switched to Mining section");
                    }
                    break;
                default:
                    Debug.LogWarning($"[EquipmentHubManager] Unknown section: {sectionName}");
                    break;
            }
        }

        /// <summary>
        /// Starts the game and transitions to the level select screen
        /// </summary>
        public void StartGame()
        {
            StartCoroutine(TransitionToLevelSelect());
        }

        /// <summary>
        /// Returns to the character selection screen
        /// </summary>
        public void ReturnToCharacterSelect()
        {
            StartCoroutine(TransitionToCharacterSelect());
        }

        /// <summary>
        /// Transitions to the level selection scene
        /// </summary>
        private IEnumerator TransitionToLevelSelect()
        {
            // Fade out
            if (fadeController != null)
            {
                fadeController.FadeToBlack();
                yield return new WaitForSeconds(fadeController.FadeDuration);
            }

            // Change game state
            GameEvents.OnGameStateChanged.Invoke(GameState.LevelSelect);

            // Load level select scene
            SceneManager.LoadScene("LevelSelect");
        }

        /// <summary>
        /// Transitions back to the character selection scene
        /// </summary>
        private IEnumerator TransitionToCharacterSelect()
        {
            // Fade out
            if (fadeController != null)
            {
                fadeController.FadeToBlack();
                yield return new WaitForSeconds(fadeController.FadeDuration);
            }

            // Change game state
            GameEvents.OnGameStateChanged.Invoke(GameState.CharacterSelect);

            // Load character select scene
            SceneManager.LoadScene("CharacterSelect");
        }

        /// <summary>
        /// Cleanup when the manager is destroyed
        /// </summary>
        protected override void OnManagerDestroyed()
        {
            // Clean up button listeners
            if (equipmentButton != null)
                equipmentButton.onClick.RemoveAllListeners();

            if (shopButton != null)
                shopButton.onClick.RemoveAllListeners();

            if (miningButton != null)
                miningButton.onClick.RemoveAllListeners();

            if (startGameButton != null)
                startGameButton.onClick.RemoveAllListeners();

            if (backButton != null)
                backButton.onClick.RemoveAllListeners();

            // Call base method
            base.OnManagerDestroyed();
        }
    }
}

// --- END FILE ---

// File: UI/Transitions/FadeScreenController.cs
// Size: 6554 characters
// ---
// File: Assets/Code/UI/Transitions/FadeScreenController.cs
//
// Purpose: Controls screen fading transitions between scenes or major state changes.
// Provides fade-to-black and fade-from-black functionality with configurable duration and easing.
// Supports displaying a loading indicator during transitions.
//
// Created: 2025-02-25
// Updated: 2025-02-25

using UnityEngine;
using UnityEngine.UI;
using System.Collections;
using DG.Tweening;
using TMPro;

namespace CyberPickle.UI.Transitions
{
    /// <summary>
    /// Controls screen fading transitions between scenes or major state changes
    /// </summary>
    public class FadeScreenController : MonoBehaviour
    {
        [Header("Fade Settings")]
        [SerializeField] private Image fadeImage;
        [SerializeField] private float fadeDuration = 0.5f;
        [SerializeField] private Ease fadeEase = Ease.InOutQuad;

        [Header("Loading Indicator")]
        [SerializeField] private GameObject loadingIndicator;
        [SerializeField] private TextMeshProUGUI loadingText;

        private Sequence currentFadeSequence;

        /// <summary>
        /// Duration of the fade transition
        /// </summary>
        public float FadeDuration => fadeDuration;

        private void Awake()
        {
            ValidateReferences();

            // Make sure we start with a transparent fade image
            if (fadeImage != null)
            {
                fadeImage.color = new Color(fadeImage.color.r, fadeImage.color.g, fadeImage.color.b, 0f);
                fadeImage.gameObject.SetActive(false);
            }

            if (loadingIndicator != null)
                loadingIndicator.SetActive(false);
        }

        private void ValidateReferences()
        {
            // Ensure fade image exists
            if (fadeImage == null)
            {
                Debug.LogError("[FadeScreenController] Fade image not assigned! Creating a new one...");

                // Create a canvas if needed
                Canvas canvas = GetComponent<Canvas>();
                if (canvas == null)
                {
                    canvas = gameObject.AddComponent<Canvas>();
                    canvas.renderMode = RenderMode.ScreenSpaceOverlay;
                    canvas.sortingOrder = 999; // Ensure it's on top

                    // Add a canvas scaler
                    CanvasScaler scaler = gameObject.AddComponent<CanvasScaler>();
                    scaler.uiScaleMode = CanvasScaler.ScaleMode.ScaleWithScreenSize;
                    scaler.referenceResolution = new Vector2(1920, 1080);

                    // Add a graphic raycaster
                    gameObject.AddComponent<GraphicRaycaster>();
                }

                // Create fade image
                GameObject imageObj = new GameObject("FadeImage");
                imageObj.transform.SetParent(transform, false);

                RectTransform rectTransform = imageObj.AddComponent<RectTransform>();
                rectTransform.anchorMin = Vector2.zero;
                rectTransform.anchorMax = Vector2.one;
                rectTransform.sizeDelta = Vector2.zero;
                rectTransform.anchoredPosition = Vector2.zero;

                fadeImage = imageObj.AddComponent<Image>();
                fadeImage.color = Color.black;
                fadeImage.raycastTarget = false;

                Debug.Log("[FadeScreenController] Created fade image");
            }
        }

        /// <summary>
        /// Fades the screen to black
        /// </summary>
        public void FadeToBlack()
        {
            if (fadeImage == null) return;

            fadeImage.gameObject.SetActive(true);

            // Kill any existing fade
            if (currentFadeSequence != null && currentFadeSequence.IsActive())
                currentFadeSequence.Kill();

            // Create fade sequence
            currentFadeSequence = DOTween.Sequence();
            currentFadeSequence.Append(fadeImage.DOFade(1f, fadeDuration).SetEase(fadeEase));

            if (loadingIndicator != null)
            {
                currentFadeSequence.AppendCallback(() => {
                    loadingIndicator.SetActive(true);
                });
            }

            Debug.Log("[FadeScreenController] Fading to black");
        }

        /// <summary>
        /// Fades the screen from black back to transparent
        /// </summary>
        public void FadeFromBlack()
        {
            if (fadeImage == null) return;

            // Kill any existing fade
            if (currentFadeSequence != null && currentFadeSequence.IsActive())
                currentFadeSequence.Kill();

            if (loadingIndicator != null)
                loadingIndicator.SetActive(false);

            // Create fade sequence
            currentFadeSequence = DOTween.Sequence();
            currentFadeSequence.Append(fadeImage.DOFade(0f, fadeDuration).SetEase(fadeEase));
            currentFadeSequence.AppendCallback(() => {
                fadeImage.gameObject.SetActive(false);
            });

            Debug.Log("[FadeScreenController] Fading from black");
        }

        /// <summary>
        /// Updates the loading text if it exists
        /// </summary>
        public void SetLoadingText(string text)
        {
            if (loadingText != null)
                loadingText.text = text;
        }

        /// <summary>
        /// Performs a full fade cycle (transparent to black and back)
        /// </summary>
        public IEnumerator FadeCycle(float holdDuration = 0.2f)
        {
            FadeToBlack();
            yield return new WaitForSeconds(fadeDuration + holdDuration);
            FadeFromBlack();
        }

        /// <summary>
        /// Fades to black, executes an action, then fades back
        /// </summary>
        public IEnumerator FadeAction(System.Action action, float holdDuration = 0.2f)
        {
            FadeToBlack();
            yield return new WaitForSeconds(fadeDuration);

            if (action != null)
                action();

            yield return new WaitForSeconds(holdDuration);
            FadeFromBlack();
        }

        private void OnDestroy()
        {
            if (currentFadeSequence != null && currentFadeSequence.IsActive())
                currentFadeSequence.Kill();
        }
    }
}

// --- END FILE ---

// File: Core/Base/Events/GameEvent.cs
// Size: 1118 characters
// ---
using System;
using System.Collections.Generic;

namespace CyberPickle.Core.Events
{
    public class GameEvent
    {
        private readonly List<Action> listeners = new List<Action>();

        public void AddListener(Action listener)
        {
            listeners.Add(listener);
        }

        public void RemoveListener(Action listener)
        {
            listeners.Remove(listener);
        }

        public void Invoke()
        {
            for (int i = listeners.Count - 1; i >= 0; i--)
                listeners[i]?.Invoke();
        }
    }

    public class GameEvent<T>
    {
        private readonly List<Action<T>> listeners = new List<Action<T>>();

        public void AddListener(Action<T> listener)
        {
            listeners.Add(listener);
        }

        public void RemoveListener(Action<T> listener)
        {
            listeners.Remove(listener);
        }

        public void Invoke(T value)
        {
            for (int i = listeners.Count - 1; i >= 0; i--)
                listeners[i]?.Invoke(value);
        }
    }
}

// --- END FILE ---

// File: Core/Base/Interfaces/ICleanable.cs
// Size: 117 characters
// ---
namespace CyberPickle.Core.Interfaces
{
    public interface ICleanable
    {
        void Cleanup();
    }
}

// --- END FILE ---

// File: Core/Base/Interfaces/IInitializable.cs
// Size: 122 characters
// ---
namespace CyberPickle.Core.Interfaces
{
    public interface IInitializable
    {
        void Initialize();
    }
}
// --- END FILE ---

// File: Core/Base/Manager/Manager.cs
// Size: 4527 characters
// ---
using UnityEngine;
using CyberPickle.Core.Interfaces;
using System.Threading;

namespace CyberPickle.Core.Management
{
    /// <summary>
    /// Base manager class implementing the singleton pattern for all game managers
    /// </summary>
    public abstract class Manager<T> : MonoBehaviour where T : Manager<T>
    {
        private static T instance;
        private static readonly object lockObject = new object();
        private static bool isQuitting = false;
        protected CancellationTokenSource cancellationTokenSource;

        public static T Instance
        {
            get
            {
                if (instance == null)
                {
                    // Check if we're quitting or in play mode
                    if (!Application.isPlaying)
                    {
                        Debug.LogWarning($"[{typeof(T).Name}] Instance will not be created because the application is not in play mode.");
                        return null;
                    }

                    lock (lockObject)
                    {
                        if (instance == null)
                        {
                            instance = FindObjectOfType<T>();
                            if (instance == null)
                            {
                                GameObject go = new GameObject($"[{typeof(T).Name}]");
                                instance = go.AddComponent<T>();
                                DontDestroyOnLoad(go);
                            }
                        }
                    }
                }
                return instance;
            }
        }

        protected virtual void Awake()
        {
            if (instance == null)
            {
                instance = (T)this;
                DontDestroyOnLoad(gameObject);
                cancellationTokenSource = new CancellationTokenSource();
                OnManagerAwake();
            }
            else if (instance != this)
            {
                Debug.LogWarning($"[{typeof(T).Name}] Instance already exists, destroying duplicate!");
                Destroy(gameObject);
            }
        }

        protected virtual void OnManagerAwake()
        {
            // If this manager is initializable, initialize it automatically
            if (this is IInitializable initializable)
            {
                Debug.Log($"<color=yellow>[{typeof(T).Name}] Auto-initializing...</color>");
                initializable.Initialize();
            }
        }

        protected virtual void OnEnable()
        {
            if (cancellationTokenSource == null || cancellationTokenSource.IsCancellationRequested)
            {
                cancellationTokenSource = new CancellationTokenSource();
            }
            OnManagerEnabled();
        }

        protected virtual void OnDisable()
        {
            OnManagerDisabled();
        }

        protected virtual void OnDestroy()
        {
            if (instance == this)
            {
                OnManagerDestroyed();
                instance = null;

                // Cancel any pending async operations
                if (cancellationTokenSource != null)
                {
                    cancellationTokenSource.Cancel();
                    cancellationTokenSource.Dispose();
                    cancellationTokenSource = null;
                }
            }
        }

        protected virtual void OnApplicationQuit()
        {
            isQuitting = true;

            // Cancel any pending async operations
            if (cancellationTokenSource != null && !cancellationTokenSource.IsCancellationRequested)
            {
                cancellationTokenSource.Cancel();
            }

            OnManagerApplicationQuit();
        }

        // Virtual methods for derived classes to override
        protected virtual void OnManagerEnabled() { }
        protected virtual void OnManagerDisabled() { }
        protected virtual void OnManagerDestroyed() { }
        protected virtual void OnManagerApplicationQuit() { }

        // Helper method to check if this is the active instance
        protected bool IsActiveInstance => instance == this;

        // Helper method to check if the application is quitting
        protected bool IsQuitting => Application.isPlaying && !Application.isEditor && (Time.frameCount == 0 || !enabled);
    }
}
// --- END FILE ---

// File: Core/Boot/Config/BootConfig.cs
// Size: 647 characters
// ---
using UnityEngine;

namespace CyberPickle.Core.Config
{
    [CreateAssetMenu(fileName = "BootConfig", menuName = "CyberPickle/Config/Boot")]
    public class BootConfig : ScriptableObject
    {
        [Header("Scene Settings")]
        public string mainMenuSceneName = "MainMenu";

        [Header("Timing Settings")]
        public float fadeInDuration = 1.5f;
        public float displayDuration = 2.0f;
        public float fadeOutDuration = 1.5f;
        public float minimumLoadingTime = 3.0f;

        [Header("Loading Settings")]
        public bool waitForInput = true;
        public string[] loadingTips;
    }
}

// --- END FILE ---

// File: Core/Boot/UI/BootUIController.cs
// Size: 1867 characters
// ---
using UnityEngine;
using UnityEngine.UI;
using TMPro;

namespace CyberPickle.Core.Boot.UI
{
    public class BootUIController : MonoBehaviour
    {
        [Header("UI References")]
        [SerializeField] private CanvasGroup logoCanvasGroup;
        [SerializeField] private TextMeshProUGUI companyNameText;
        [SerializeField] private Slider loadingBarSlider;
        [SerializeField] private TextMeshProUGUI loadingText;

        private void Awake()
        {
            ValidateReferences();
        }

        private void ValidateReferences()
        {
            if (logoCanvasGroup == null)
                Debug.LogError("[BootUIController] Logo CanvasGroup is not assigned!");
            if (companyNameText == null)
                Debug.LogError("[BootUIController] Company Name Text is not assigned!");
            if (loadingBarSlider == null)
                Debug.LogError("[BootUIController] Loading Bar Slider is not assigned!");
            if (loadingText == null)
                Debug.LogError("[BootUIController] Loading Text is not assigned!");
        }

        public void UpdateProgress(float progress)
        {
            if (loadingBarSlider != null)
            {
                loadingBarSlider.value = progress;
            }
        }

        public void UpdateLoadingText(string text)
        {
            if (loadingText != null)
            {
                loadingText.text = text;
                Debug.Log($"[BootUIController] Loading text updated: {text}");
            }
        }

        public void SetLogoAlpha(float alpha)
        {
            if (logoCanvasGroup != null)
            {
                logoCanvasGroup.alpha = alpha;
                Debug.Log($"[BootUIController] Logo alpha updated: {alpha:F2}");
            }
        }
    }
}
// --- END FILE ---

// File: Core/GameManager/Config/GameConfig.cs
// Size: 947 characters
// ---
using UnityEngine;

namespace CyberPickle.Core.Config
{
    [CreateAssetMenu(fileName = "GameConfig", menuName = "CyberPickle/Config/Game")]
    public class GameConfig : ScriptableObject
    {
        [Header("Scene Names")]
        public string mainMenuSceneName = "MainMenu";
        public string characterSelectSceneName = "CharacterSelect";
        public string equipmentSelectSceneName = "EquipmentSelect";
        public string levelSelectSceneName = "LevelSelect";
        public string gameSceneName = "Game";
        public string postGameSceneName = "PostGame";

        [Header("Game Settings")]
        public float gameStartDelay = 3f;
        public float gameOverDelay = 2f;
        public bool enableTutorial = true;

        [Header("Debug Settings")]
        public bool enableDebugMode = false;
        public bool skipBootSequence = false;
        public bool unlockAllCharacters = false;
    }
}

// --- END FILE ---

// File: Core/GameManager/Events/EventManager.cs
// Size: 1443 characters
// ---
using CyberPickle.Core.Management;
using CyberPickle.Core.Interfaces;

namespace CyberPickle.Core.Events
{
    public class EventManager : Manager<EventManager>, IInitializable
    {
        private bool isInitialized;

        public void Initialize()
        {
            if (isInitialized) return;

            // Initialize any event-related systems
            RegisterGlobalEventListeners();

            isInitialized = true;
        }

        private void RegisterGlobalEventListeners()
        {
            // Register for analytics
            GameEvents.OnLevelCompleted.AddListener((levelId) =>
                TrackLevelCompletion(levelId));

            GameEvents.OnAchievementUnlocked.AddListener((achievementId) =>
                TrackAchievement(achievementId));

            // Add more global event listeners as needed
        }

        private void TrackLevelCompletion(string levelId)
        {
            // Will be implemented when Analytics system is ready
            UnityEngine.Debug.Log($"Level completed: {levelId}");
        }

        private void TrackAchievement(string achievementId)
        {
            // Will be implemented when Achievement system is ready
            UnityEngine.Debug.Log($"Achievement unlocked: {achievementId}");
        }

        protected override void OnManagerAwake()
        {
            Initialize();
        }
    }
}

// --- END FILE ---

// File: Core/GameManager/Events/GameEvents.cs
// Size: 5470 characters
// ---
using CyberPickle.Core.GameFlow.States.ProfileCard;
using CyberPickle.Core.Services.Authentication.Data;
using CyberPickle.Core.States;
using System.Collections.Generic;

namespace CyberPickle.Core.Events
{
    public static class GameEvents
    {
        // Game State Events
        public static readonly GameEvent OnGameInitialized = new GameEvent();
        public static readonly GameEvent OnGameStarted = new GameEvent();
        public static readonly GameEvent OnGamePaused = new GameEvent();
        public static readonly GameEvent OnGameResumed = new GameEvent();
        public static readonly GameEvent OnGameOver = new GameEvent();

        // Player Events
        public static readonly GameEvent<int> OnExperienceGained = new GameEvent<int>();
        public static readonly GameEvent<int> OnLevelUp = new GameEvent<int>();
        public static readonly GameEvent<float> OnHealthChanged = new GameEvent<float>();
        public static readonly GameEvent OnPlayerDied = new GameEvent();

        // Progress Events
        public static readonly GameEvent<string> OnAchievementUnlocked = new GameEvent<string>();
        public static readonly GameEvent<string> OnLevelCompleted = new GameEvent<string>();
        public static readonly GameEvent<string> OnCharacterUnlocked = new GameEvent<string>();

        // Economy Events
        public static readonly GameEvent<int> OnCurrencyChanged = new GameEvent<int>();
        public static readonly GameEvent<string> OnItemPurchased = new GameEvent<string>();
        public static readonly GameEvent<string> OnItemEquipped = new GameEvent<string>();

        
        // Input related events
        public static readonly GameEvent OnMainMenuInput = new GameEvent();
        public static readonly GameEvent<float> OnHorizontalInput = new GameEvent<float>();
        public static readonly GameEvent OnPauseRequested = new GameEvent();
        public static readonly GameEvent OnResumeRequested = new GameEvent();
        public static readonly GameEvent<GameState> OnGameStateChanged = new GameEvent<GameState>();
        public static GameEvent<float> OnProfileNavigationInput = new GameEvent<float>();

        // Authentication events
        public static readonly GameEvent OnAuthenticationRequested = new GameEvent();
        public static readonly GameEvent OnProfileLoadRequested = new GameEvent();

        // Profile-related events
        public static readonly GameEvent<List<ProfileData>> OnProfilesLoaded = new GameEvent<List<ProfileData>>();
        public static readonly GameEvent OnProfilesCleared = new GameEvent();
        public static readonly GameEvent<string> OnProfileSelected = new GameEvent<string>();
        public static readonly GameEvent<string> OnProfileCreated = new GameEvent<string>();
        public static readonly GameEvent<string> OnProfileDeleted = new GameEvent<string>();
        public static readonly GameEvent<string> OnProfileRestored = new GameEvent<string>();

        // UI Animation Events
        public static readonly GameEvent OnUIAnimationStarted = new GameEvent();
        public static readonly GameEvent OnUIAnimationCompleted = new GameEvent();
        public static readonly GameEvent OnProfileUIReady = new GameEvent();

        // Profile Card UI Events
        public static readonly GameEvent<ProfileCardState> OnProfileCardStateChanged = new GameEvent<ProfileCardState>();
        public static readonly GameEvent OnProfileCardClicked = new GameEvent();
        public static readonly GameEvent OnProfileCardTransitionComplete = new GameEvent();
        public static readonly GameEvent<bool> OnProfileCardInteractionEnabled = new GameEvent<bool>();

        //Camera Events
        public static readonly GameEvent OnCameraTransitionComplete = new GameEvent();

        // Character Selection Events
        public static readonly GameEvent<string> OnCharacterHoverEnter = new GameEvent<string>();
        public static readonly GameEvent<string> OnCharacterHoverExit = new GameEvent<string>();
        public static readonly GameEvent<string> OnCharacterSelected = new GameEvent<string>();
        public static readonly GameEvent<string> OnCharacterDetailsRequested = new GameEvent<string>();
        public static readonly GameEvent<string> OnCharacterConfirmationRequested = new GameEvent<string>();
        public static readonly GameEvent OnCharacterConfirmed = new GameEvent();
        public static readonly GameEvent OnCharacterSelectionCancelled = new GameEvent();

        /// <summary>
        /// Event raised when the mouse pointer enters a character in the selection screen
        /// </summary>
        /// <param name="characterId">ID of the character being hovered</param>

        /// <summary>
        /// Event raised when the mouse pointer exits a character in the selection screen
        /// </summary>
        /// <param name="characterId">ID of the character no longer being hovered</param>

        /// <summary>
        /// Event raised when a character is selected via left-click
        /// </summary>
        /// <param name="characterId">ID of the selected character</param>

        /// <summary>
        /// Event raised when character details are requested via right-click
        /// </summary>
        /// <param name="characterId">ID of the character whose details are requested</param>

    }
}

// --- END FILE ---

// File: Core/GameManager/States/GameState.cs
// Size: 307 characters
// ---
namespace CyberPickle.Core.States
{
    public enum GameState
    {
        None,
        Loading,
        ProfileSelection,
        MainMenu,
        CharacterSelect,
        EquipmentSelect,
        LevelSelect,
        Playing,
        Paused,
        PostGame,
        GameOver
    }
}

// --- END FILE ---

// File: Core/Services/Authentication/AuthenticationManager.cs
// Size: 9074 characters
// ---
// File: Assets/Code/Core/Services/Authentication/AuthenticationManager.cs
//
// Purpose: Manages authentication state in the game.
// Provides centralized control over user authentication.
//
// Dependencies:
// - Unity.Services.Authentication for base authentication
// - CyberPickle.Core.Events for game-wide event system
// - CyberPickle.Core.Management for base manager pattern
//
// Created: 2024-01-13
// Updated: 2024-01-14

using UnityEngine;
using System;
using System.Threading.Tasks;
using Unity.Services.Core;
using Unity.Services.Authentication;
using CyberPickle.Core.Management;
using CyberPickle.Core.Events;
using CyberPickle.Core.Interfaces;

namespace CyberPickle.Core.Services.Authentication
{
    public class AuthenticationManager : Manager<AuthenticationManager>, IInitializable
    {
        private AuthenticationState currentState = AuthenticationState.NotInitialized;
        private AuthenticationEvents authEvents;
        private bool isInitialized;

        public AuthenticationState CurrentState => currentState;
        public bool IsSignedIn => AuthenticationService.Instance.IsSignedIn;
        public string CurrentPlayerId => AuthenticationService.Instance.PlayerId;

        protected override void OnManagerAwake()
        {
            authEvents = new AuthenticationEvents();
        }

        public async void Initialize()
        {
            if (isInitialized) return;

            try
            {
                SetState(AuthenticationState.NotInitialized);

                // Initialize Unity Services
                await UnityServices.InitializeAsync();

                // Subscribe to Authentication events
                SubscribeToAuthEvents();

                // Check for cached session
                if (AuthenticationService.Instance.SessionTokenExists)
                {
                    authEvents.InvokeSessionTokenFound(AuthenticationService.Instance.PlayerId);
                }

                SetState(AuthenticationState.NotAuthenticated);
                isInitialized = true;

                Debug.Log("Authentication Manager initialized successfully");
            }
            catch (Exception e)
            {
                Debug.LogError($"Failed to initialize Authentication Manager: {e.Message}");
                SetState(AuthenticationState.AuthenticationFailed);
            }
        }

        private void SubscribeToAuthEvents()
        {
            AuthenticationService.Instance.SignedIn += OnSignedIn;
            AuthenticationService.Instance.SignedOut += OnSignedOut;
            AuthenticationService.Instance.Expired += OnSessionExpired;
        }

        private void UnsubscribeFromAuthEvents()
        {
            if (AuthenticationService.Instance != null)
            {
                AuthenticationService.Instance.SignedIn -= OnSignedIn;
                AuthenticationService.Instance.SignedOut -= OnSignedOut;
                AuthenticationService.Instance.Expired -= OnSessionExpired;
            }
        }

        #region Authentication Methods

        public async Task<bool> SignInAnonymouslyAsync()
        {
            if (currentState == AuthenticationState.AuthenticationInProgress)
            {
                Debug.LogWarning("Authentication already in progress");
                return false;
            }

            try
            {
                SetState(AuthenticationState.AuthenticationInProgress);

                await AuthenticationService.Instance.SignInAnonymouslyAsync();

                // Sign-in successful, events are handled in OnSignedIn

                return true;
            }
            catch (AuthenticationException e)
            {
                HandleAuthenticationError(e);
                return false;
            }
            catch (RequestFailedException e)
            {
                HandleRequestError(e);
                return false;
            }
        }

        public void SignOut()
        {
            try
            {
                AuthenticationService.Instance.SignOut();
                SetState(AuthenticationState.NotAuthenticated);
                authEvents.InvokeSignedOut();
            }
            catch (Exception e)
            {
                Debug.LogError($"Error during sign out: {e.Message}");
            }
        }

        #endregion

        #region Event Handlers

        private void OnSignedIn()
        {
            Debug.Log("[AuthManager] SignedIn event received");
            SetState(AuthenticationState.Authenticated);
            authEvents.InvokeAuthenticationCompleted(AuthenticationService.Instance.PlayerId);
            Debug.Log($"[AuthManager] Signed in successfully. Player ID: {AuthenticationService.Instance.PlayerId}");
        }

        private void OnSignedOut()
        {
            SetState(AuthenticationState.NotAuthenticated);
            authEvents.InvokeSignedOut();
            Debug.Log("Signed out successfully");
        }

        private void OnSessionExpired()
        {
            SetState(AuthenticationState.SessionExpired);
            authEvents.InvokeSessionExpired();
            Debug.Log("Session expired");
        }

        #endregion

        #region Error Handling

        private void HandleAuthenticationError(AuthenticationException e)
        {
            string errorMessage = $"Authentication error: {e.Message}";
            Debug.LogError(errorMessage);
            SetState(AuthenticationState.AuthenticationFailed);
            authEvents.InvokeAuthenticationFailed(errorMessage);
        }

        private void HandleRequestError(RequestFailedException e)
        {
            string errorMessage = $"Request failed: {e.Message} (Error Code: {e.ErrorCode})";
            Debug.LogError(errorMessage);
            SetState(AuthenticationState.AuthenticationFailed);
            authEvents.InvokeAuthenticationFailed(errorMessage);
        }

        #endregion

        private void SetState(AuthenticationState newState)
        {
            if (currentState != newState)
            {
                Debug.Log($"[AuthManager] State changing from {currentState} to {newState}");
                currentState = newState;
                authEvents.InvokeAuthenticationStateChanged(newState);
            }
        }

        #region Event Subscription Methods

        public void SubscribeToAuthenticationStateChanged(Action<AuthenticationState> callback)
            => authEvents.OnAuthenticationStateChanged += callback;

        public void UnsubscribeFromAuthenticationStateChanged(Action<AuthenticationState> callback)
            => authEvents.OnAuthenticationStateChanged -= callback;

        public void SubscribeToAuthenticationCompleted(Action<string> callback)
            => authEvents.OnAuthenticationCompleted += callback;

        public void UnsubscribeFromAuthenticationCompleted(Action<string> callback)
            => authEvents.OnAuthenticationCompleted -= callback;

        public void SubscribeToAuthenticationFailed(Action<string> callback)
            => authEvents.OnAuthenticationFailed += callback;

        public void UnsubscribeFromAuthenticationFailed(Action<string> callback)
            => authEvents.OnAuthenticationFailed -= callback;

        // Session event subscriptions
        public void SubscribeToSessionTokenFound(Action<string> callback)
            => authEvents.OnSessionTokenFound += callback;

        public void UnsubscribeFromSessionTokenFound(Action<string> callback)
            => authEvents.OnSessionTokenFound -= callback;

        public void SubscribeToSessionExpired(Action callback)
            => authEvents.OnSessionExpired += callback;

        public void UnsubscribeFromSessionExpired(Action callback)
            => authEvents.OnSessionExpired -= callback;

        public void SubscribeToSignedOut(Action callback)
            => authEvents.OnSignedOut += callback;

        public void UnsubscribeFromSignedOut(Action callback)
            => authEvents.OnSignedOut -= callback;

        #endregion

        protected override void OnManagerDestroyed()
        {
            if (!IsActiveInstance) return;

            try
            {
                // Ensure clean sign out if necessary
                if (AuthenticationService.Instance != null && AuthenticationService.Instance.IsSignedIn)
                {
                    AuthenticationService.Instance.SignOut();
                }

                // Unsubscribe from events
                UnsubscribeFromAuthEvents();

                Debug.Log("[AuthManager] Cleanup completed successfully");
            }
            catch (Exception ex)
            {
                Debug.LogError($"[AuthManager] Error during cleanup: {ex.Message}");
            }
        }

    }
}

// --- END FILE ---

// File: Core/Services/Authentication/ProfileManager.cs
// Size: 14376 characters
// ---
// File: Assets/Code/Core/Services/Authentication/ProfileManager.cs

using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using UnityEngine;
using System.Linq;
using CyberPickle.Core.Management;
using CyberPickle.Core.Interfaces;
using CyberPickle.Core.Services.Authentication.Data;
using System.Threading;

namespace CyberPickle.Core.Services.Authentication
{
    public class ProfileOperationResult
    {
        public bool Success { get; }
        public string Message { get; }
        public Exception Error { get; }

        private ProfileOperationResult(bool success, string message, Exception error = null)
        {
            Success = success;
            Message = message;
            Error = error;
        }

        public static ProfileOperationResult Succeeded(string message = null)
            => new ProfileOperationResult(true, message);

        public static ProfileOperationResult Failed(string message, Exception error = null)
            => new ProfileOperationResult(false, message, error);
    }

    public class ProfileManager : Manager<ProfileManager>, IInitializable
    {
        private ProfileContainer profileContainer;
        private ProfileManagementEvents profileEvents;
        private bool isInitialized;
        private bool isAutosaveEnabled = true;
        private readonly object saveLock = new object();

        public bool IsInitialized => isInitialized;
        public ProfileData ActiveProfile => profileContainer?.ActiveProfile;

        public void Initialize()
        {
            if (isInitialized) return;

            Debug.Log("[ProfileManager] Starting initialization");

            try
            {
                profileContainer = ProfileContainer.Load();
                Debug.Log($"[ProfileManager] Loaded profile container. Has profiles: {profileContainer?.Profiles?.Count > 0}");

                if (profileContainer == null)
                {
                    profileContainer = new ProfileContainer();
                    Debug.Log("[ProfileManager] Created new profile container");
                }

                profileEvents = new ProfileManagementEvents();
                isInitialized = true;
                Debug.Log("[ProfileManager] Initialization complete");
            }
            catch (Exception e)
            {
                Debug.LogError($"[ProfileManager] Failed to initialize: {e.Message}");
                throw;
            }
        }

        protected override void OnManagerAwake()
        {
            Debug.Log("[ProfileManager] OnManagerAwake called");
            Initialize();
        }

        private void ValidateState()
        {
            if (!isInitialized)
            {
                throw new InvalidOperationException("[ProfileManager] Manager not initialized");
            }

            if (profileContainer == null)
            {
                throw new InvalidOperationException("[ProfileManager] Profile container is null");
            }
        }

        public async Task<ProfileOperationResult> CreateProfileAsync(string profileId, string playerId, string displayName)
        {
            try
            {
                ValidateState();

                Debug.Log($"[ProfileManager] Creating profile: {displayName} (ID: {profileId})");
                var profile = new ProfileData(profileId, playerId, displayName);
                profileContainer.AddProfile(profile);
                profileContainer.SetActiveProfile(profileId);

                await SaveProfilesAsync();
                profileEvents.InvokeNewProfileCreated(profileId);

                return ProfileOperationResult.Succeeded($"Profile created successfully: {profileId}");
            }
            catch (Exception ex)
            {
                Debug.LogError($"[ProfileManager] Failed to create profile: {ex.Message}");
                return ProfileOperationResult.Failed("Failed to create profile", ex);
            }
        }

        public ProfileData GetProfile(string profileId)
        {
            try
            {
                ValidateState();
                return profileContainer.GetProfile(profileId);
            }
            catch (Exception ex)
            {
                Debug.LogError($"[ProfileManager] Failed to get profile {profileId}: {ex.Message}");
                return null;
            }
        }

        public async Task<ProfileOperationResult> AddProfileAsync(ProfileData profile)
        {
            try
            {
                ValidateState();

                Debug.Log($"[ProfileManager] Adding profile: {profile.DisplayName}");
                profileContainer.AddProfile(profile);
                await SaveProfilesAsync();
                profileEvents?.InvokeNewProfileCreated(profile.ProfileId);

                return ProfileOperationResult.Succeeded($"Profile added successfully: {profile.DisplayName}");
            }
            catch (Exception ex)
            {
                Debug.LogError($"[ProfileManager] Failed to add profile: {ex.Message}");
                return ProfileOperationResult.Failed("Failed to add profile", ex);
            }
        }

        public async Task<ProfileOperationResult> DeleteProfileAsync(string profileId)
        {
            try
            {
                ValidateState();

                Debug.Log($"[ProfileManager] Deleting profile: {profileId}");

                // Check if profile exists
                var profile = GetProfile(profileId);
                if (profile == null)
                {
                    return ProfileOperationResult.Failed($"Profile not found: {profileId}");
                }

                // If deleting active profile, handle special case
                if (ActiveProfile?.ProfileId == profileId)
                {
                    var nextProfile = profileContainer.Profiles
                        .FirstOrDefault(p => p.ProfileId != profileId);

                    if (nextProfile != null)
                    {
                        profileContainer.SetActiveProfile(nextProfile.ProfileId);
                    }
                }

                profileContainer.RemoveProfile(profileId);
                await SaveProfilesAsync();
                profileEvents?.InvokeProfileDeleted(profileId);

                return ProfileOperationResult.Succeeded($"Profile deleted successfully: {profileId}");
            }
            catch (Exception ex)
            {
                Debug.LogError($"[ProfileManager] Failed to delete profile: {ex.Message}");
                return ProfileOperationResult.Failed("Failed to delete profile", ex);
            }
        }

        public async Task<ProfileOperationResult> UpdateProfileAsync(ProfileData profile)
        {
            try
            {
                ValidateState();

                Debug.Log($"[ProfileManager] Updating profile: {profile.ProfileId}");
                profileContainer.UpdateProfile(profile);
                await SaveProfilesAsync();

                return ProfileOperationResult.Succeeded($"Profile updated successfully: {profile.ProfileId}");
            }
            catch (Exception ex)
            {
                Debug.LogError($"[ProfileManager] Failed to update profile: {ex.Message}");
                return ProfileOperationResult.Failed("Failed to update profile", ex);
            }
        }

        public async Task<ProfileOperationResult> SwitchActiveProfileAsync(string profileId)
        {
            try
            {
                ValidateState();

                var profile = GetProfile(profileId);
                if (profile == null)
                {
                    return ProfileOperationResult.Failed($"Profile not found: {profileId}");
                }

                profileContainer.SetActiveProfile(profileId);
                Debug.Log($"[ProfileManager] ActiveProfile set to {ActiveProfile?.ProfileId} at {Time.time}"); ;
                await SaveProfilesAsync();

                profileEvents.InvokeProfileSwitched(profileId);

                return ProfileOperationResult.Succeeded($"Profile switched successfully: {profileId}");
            }
            catch (Exception ex)
            {
                Debug.LogError($"[ProfileManager] Failed to switch profile: {ex.Message}");
                return ProfileOperationResult.Failed("Failed to switch profile", ex);
            }
        }

        public IReadOnlyList<ProfileData> GetAllProfiles()
        {
            try
            {
                ValidateState();
                return profileContainer.Profiles;
            }
            catch (Exception ex)
            {
                Debug.LogError($"[ProfileManager] Failed to get profiles: {ex.Message}");
                return new List<ProfileData>();
            }
        }

        public async Task<ProfileOperationResult> UpdateActiveProfileProgressAsync(float playTime, int score, float distance, int level)
        {
            try
            {
                ValidateState();

                if (ActiveProfile == null)
                {
                    return ProfileOperationResult.Failed("No active profile");
                }

                ActiveProfile.UpdateProgress(playTime, score, distance, level);
                profileContainer.UpdateProfile(ActiveProfile);
                await SaveProfilesAsync();

                return ProfileOperationResult.Succeeded("Profile progress updated successfully");
            }
            catch (Exception ex)
            {
                Debug.LogError($"[ProfileManager] Failed to update profile progress: {ex.Message}");
                return ProfileOperationResult.Failed("Failed to update profile progress", ex);
            }
        }

        private async Task SaveProfilesAsync()
        {
            if (!isAutosaveEnabled || profileContainer == null) return;

            try
            {
                var token = cancellationTokenSource?.Token ?? CancellationToken.None;
                if (token.IsCancellationRequested)
                {
                    Debug.Log("[ProfileManager] Save operation cancelled due to application quit");
                    return;
                }

                // Check IsQuitting on the main thread before starting the save operation
                bool isQuitting = IsQuitting;
                if (isQuitting)
                {
                    Debug.Log("[ProfileManager] Skipping save due to application quit");
                    return;
                }

                // Run the save operation on a background thread
                await Task.Run(() =>
                {
                    lock (saveLock)
                    {
                        profileContainer.SaveProfiles();
                    }
                }, token);

                Debug.Log("[ProfileManager] Profile save completed successfully");
            }
            catch (OperationCanceledException)
            {
                Debug.Log("[ProfileManager] Save operation was cancelled");
            }
            catch (Exception ex)
            {
                Debug.LogError($"[ProfileManager] Failed to save profiles: {ex.Message}");
            }
        }

        public async Task<ProfileOperationResult> ClearAllProfilesAsync()
        {
            try
            {
                ValidateState();

                profileContainer.ClearAll();
                await SaveProfilesAsync();

                return ProfileOperationResult.Succeeded("All profiles cleared successfully");
            }
            catch (Exception ex)
            {
                Debug.LogError($"[ProfileManager] Failed to clear profiles: {ex.Message}");
                return ProfileOperationResult.Failed("Failed to clear profiles", ex);
            }
        }

        #region Event Subscription Methods
        public void SubscribeToProfileLoaded(Action<string> callback)
            => profileEvents.OnProfileLoaded += callback;

        public void UnsubscribeFromProfileLoaded(Action<string> callback)
            => profileEvents.OnProfileLoaded -= callback;

        public void SubscribeToProfileSwitched(Action<string> callback)
        {
            if (profileEvents == null)
            {
                Debug.LogError("[ProfileManager] profileEvents is null in SubscribeToProfileSwitched");
                return;
            }
            profileEvents.OnProfileSwitched += callback;
        }

        public void UnsubscribeFromProfileSwitched(Action<string> callback)
            => profileEvents.OnProfileSwitched -= callback;

        public void SubscribeToNewProfileCreated(Action<string> callback)
            => profileEvents.OnNewProfileCreated += callback;

        public void UnsubscribeFromNewProfileCreated(Action<string> callback)
            => profileEvents.OnNewProfileCreated -= callback;

        public void SubscribeToProfileDeleted(Action<string> callback)
            => profileEvents.OnProfileDeleted += callback;

        public void UnsubscribeFromProfileDeleted(Action<string> callback)
            => profileEvents.OnProfileDeleted -= callback;
        #endregion

        protected override void OnDestroy()
        {
            if (isInitialized)
            {
                try
                {
                    // Don't wait for async operations during cleanup
                    if (!IsQuitting)
                    {
                        SaveProfilesAsync().GetAwaiter().GetResult();
                    }
                }
                catch (Exception ex)
                {
                    Debug.LogError($"[ProfileManager] Error during cleanup: {ex.Message}");
                }
                finally
                {
                    isInitialized = false;
                    profileEvents = null;
                }
            }

            base.OnDestroy();
        }
    }
}



// --- END FILE ---

// File: Core/Services/LeaderBoard/LeaderboardManager.cs
// Size: 352 characters
// ---
using CyberPickle.Core.Management;
using CyberPickle.Core.Interfaces;

namespace CyberPickle.Core.Services.Leaderboard
{
    public class LeaderboardManager : Manager<LeaderboardManager>, IInitializable
    {
        public void Initialize()
        {
            UnityEngine.Debug.Log("LeaderboardManager initialized");
        }
    }
}

// --- END FILE ---

// File: Core/Services/Steam/SteamManager.cs
// Size: 368 characters
// ---
// Core/Services/Steam/SteamManager.cs
using CyberPickle.Core.Management;
using CyberPickle.Core.Interfaces;

namespace CyberPickle.Core.Services.Steam
{
    public class SteamManager : Manager<SteamManager>, IInitializable
    {
        public void Initialize()
        {
            UnityEngine.Debug.Log("SteamManager initialized");
        }
    }
}

// --- END FILE ---

// File: Shop/Equipment/Data/AmuletData.cs
// Size: 11641 characters
// ---
// File: Assets/Code/Shop/Equipment/Data/AmuletData.cs
//
// Purpose: Defines the data structure for amulet equipment in Cyber Pickle.
// Contains amulet-specific properties including luck bonuses, drop rate
// modifications, and special rare effects.
//
// Created: 2025-02-25
// Updated: 2025-02-25

using UnityEngine;
using System;
using System.Collections.Generic;
using CyberPickle.Core.Services.Authentication.Data;

namespace CyberPickle.Shop.Equipment.Data
{
    /// <summary>
    /// Defines the specialty focus of an amulet
    /// </summary>
    public enum AmuletSpecialty
    {
        Fortune,      // Focuses on luck and drop rate
        Magnetism,    // Focuses on item attraction
        Recovery,     // Focuses on health recovery
        Currency,     // Focuses on currency gains
        Experience,   // Focuses on experience gains
        Resilience,   // Focuses on damage resistance
        Mining        // Enhances neural mining efficiency
    }

    /// <summary>
    /// ScriptableObject that defines data for amulet equipment
    /// </summary>
    [CreateAssetMenu(fileName = "Amulet", menuName = "CyberPickle/Equipment/AmuletData")]
    public class AmuletData : EquipmentData
    {
        [Header("Amulet Properties")]
        [Tooltip("The specialty focus of this amulet")]
        public AmuletSpecialty specialty = AmuletSpecialty.Fortune;

        [Tooltip("Base luck bonus")]
        public float baseLuckBonus = 0.1f;

        [Tooltip("Base drop rate bonus (percentage)")]
        [Range(0f, 100f)]
        public float baseDropRateBonus = 10f;

        [Tooltip("Base currency bonus (percentage)")]
        [Range(0f, 100f)]
        public float baseCurrencyBonus = 0f;

        [Tooltip("Base experience bonus (percentage)")]
        [Range(0f, 100f)]
        public float baseExperienceBonus = 0f;

        [Tooltip("Neural mining efficiency bonus (percentage)")]
        [Range(0f, 100f)]
        public float baseMiningBonus = 0f;

        [Header("Special Ability")]
        [Tooltip("Does this amulet have a special ability?")]
        public bool hasSpecialAbility = false;

        [Tooltip("Description of special ability")]
        [TextArea(2, 4)]
        public string specialAbilityDescription;

        [Tooltip("Probability of rare item drops (percentage)")]
        [Range(0f, 100f)]
        public float rareItemDropChance = 0f;

        [Header("Visual & Audio")]
        [Tooltip("VFX prefab for when the special ability activates")]
        public GameObject specialAbilityVFX;

        [Tooltip("Color of the amulet glow")]
        public Color glowColor = Color.yellow;

        [Header("Upgrade Scaling")]
        [Tooltip("Luck bonus increase per level (multiplier)")]
        [Range(1f, 2f)]
        public float luckUpgradeMultiplier = 1.2f;

        [Tooltip("Other bonuses increase per level (multiplier)")]
        [Range(1f, 1.5f)]
        public float otherBonusesUpgradeMultiplier = 1.15f;

        /// <summary>
        /// Validates the amulet data when it's created or modified in the editor.
        /// </summary>
        protected override void OnValidate()
        {
            // Ensure correct slot type
            slotType = EquipmentSlotType.Amulet;

            base.OnValidate();

            // Additional amulet-specific validation
            ValidateAmuletFields();
        }

        /// <summary>
        /// Validates amulet-specific fields
        /// </summary>
        private void ValidateAmuletFields()
        {
            baseLuckBonus = Mathf.Max(0f, baseLuckBonus);
            baseDropRateBonus = Mathf.Max(0f, baseDropRateBonus);
            baseCurrencyBonus = Mathf.Max(0f, baseCurrencyBonus);
            baseExperienceBonus = Mathf.Max(0f, baseExperienceBonus);
            baseMiningBonus = Mathf.Max(0f, baseMiningBonus);
            rareItemDropChance = Mathf.Clamp(rareItemDropChance, 0f, 100f);

            if (hasSpecialAbility && string.IsNullOrEmpty(specialAbilityDescription))
            {
                specialAbilityDescription = "Activates a special ability.";
                Debug.LogWarning($"[AmuletData] Special ability description is empty for {displayName}");
            }

            // Set default values based on specialty
            if (specialty == AmuletSpecialty.Fortune && baseLuckBonus <= 0)
            {
                baseLuckBonus = 0.1f;
                baseDropRateBonus = 10f;
            }
            else if (specialty == AmuletSpecialty.Currency && baseCurrencyBonus <= 0)
            {
                baseCurrencyBonus = 15f;
            }
            else if (specialty == AmuletSpecialty.Experience && baseExperienceBonus <= 0)
            {
                baseExperienceBonus = 15f;
            }
            else if (specialty == AmuletSpecialty.Mining && baseMiningBonus <= 0)
            {
                baseMiningBonus = 20f;
            }
        }

        /// <summary>
        /// Gets the luck bonus for the specified upgrade level
        /// </summary>
        /// <param name="level">Upgrade level</param>
        /// <returns>Luck bonus at that level</returns>
        public float GetLuckBonusForLevel(int level)
        {
            level = Mathf.Clamp(level, 1, maxUpgradeLevel);
            return baseLuckBonus * Mathf.Pow(luckUpgradeMultiplier, level - 1);
        }

        /// <summary>
        /// Gets the drop rate bonus for the specified upgrade level
        /// </summary>
        /// <param name="level">Upgrade level</param>
        /// <returns>Drop rate bonus percentage at that level</returns>
        public float GetDropRateBonusForLevel(int level)
        {
            level = Mathf.Clamp(level, 1, maxUpgradeLevel);
            return baseDropRateBonus * Mathf.Pow(otherBonusesUpgradeMultiplier, level - 1);
        }

        /// <summary>
        /// Gets the currency bonus for the specified upgrade level
        /// </summary>
        /// <param name="level">Upgrade level</param>
        /// <returns>Currency bonus percentage at that level</returns>
        public float GetCurrencyBonusForLevel(int level)
        {
            level = Mathf.Clamp(level, 1, maxUpgradeLevel);
            return baseCurrencyBonus * Mathf.Pow(otherBonusesUpgradeMultiplier, level - 1);
        }

        /// <summary>
        /// Gets the experience bonus for the specified upgrade level
        /// </summary>
        /// <param name="level">Upgrade level</param>
        /// <returns>Experience bonus percentage at that level</returns>
        public float GetExperienceBonusForLevel(int level)
        {
            level = Mathf.Clamp(level, 1, maxUpgradeLevel);
            return baseExperienceBonus * Mathf.Pow(otherBonusesUpgradeMultiplier, level - 1);
        }

        /// <summary>
        /// Gets the mining bonus for the specified upgrade level
        /// </summary>
        /// <param name="level">Upgrade level</param>
        /// <returns>Mining bonus percentage at that level</returns>
        public float GetMiningBonusForLevel(int level)
        {
            level = Mathf.Clamp(level, 1, maxUpgradeLevel);
            return baseMiningBonus * Mathf.Pow(otherBonusesUpgradeMultiplier, level - 1);
        }

        /// <summary>
        /// Gets the rare item drop chance for the specified upgrade level
        /// </summary>
        /// <param name="level">Upgrade level</param>
        /// <returns>Rare item drop chance percentage at that level</returns>
        public float GetRareItemDropChanceForLevel(int level)
        {
            if (rareItemDropChance <= 0)
                return 0f;

            level = Mathf.Clamp(level, 1, maxUpgradeLevel);

            // Rare drop chance increases linearly with level
            return rareItemDropChance + (rareItemDropChance * 0.2f * (level - 1));
        }

        /// <summary>
        /// Gets the stats for the specified upgrade level
        /// </summary>
        public override StatDescriptor[] GetStatsForLevel(int upgradeLevel)
        {
            upgradeLevel = Mathf.Clamp(upgradeLevel, 1, maxUpgradeLevel);

            List<StatDescriptor> stats = new List<StatDescriptor>();

            // Add stats based on specialty
            switch (specialty)
            {
                case AmuletSpecialty.Fortune:
                    stats.Add(new StatDescriptor("Luck", GetLuckBonusForLevel(upgradeLevel)));
                    stats.Add(new StatDescriptor("Drop Rate", GetDropRateBonusForLevel(upgradeLevel), true));
                    if (rareItemDropChance > 0)
                    {
                        stats.Add(new StatDescriptor("Rare Drop Chance", GetRareItemDropChanceForLevel(upgradeLevel), true));
                    }
                    break;

                case AmuletSpecialty.Magnetism:
                    stats.Add(new StatDescriptor("Magnetic Field", 0.5f * upgradeLevel));
                    stats.Add(new StatDescriptor("Item Attraction", 15f * upgradeLevel, true));
                    break;

                case AmuletSpecialty.Recovery:
                    stats.Add(new StatDescriptor("Health Regen", 0.5f * upgradeLevel));
                    stats.Add(new StatDescriptor("Health Pickup Effect", 20f * upgradeLevel, true));
                    break;

                case AmuletSpecialty.Currency:
                    stats.Add(new StatDescriptor("Neural Credits Gain", GetCurrencyBonusForLevel(upgradeLevel), true));
                    stats.Add(new StatDescriptor("CyberCoins Chance", 2f * upgradeLevel, true));
                    break;

                case AmuletSpecialty.Experience:
                    stats.Add(new StatDescriptor("Experience Gain", GetExperienceBonusForLevel(upgradeLevel), true));
                    break;

                case AmuletSpecialty.Resilience:
                    stats.Add(new StatDescriptor("Damage Reduction", 3f * upgradeLevel, true));
                    stats.Add(new StatDescriptor("Recovery Speed", 5f * upgradeLevel, true));
                    break;

                case AmuletSpecialty.Mining:
                    stats.Add(new StatDescriptor("Mining Efficiency", GetMiningBonusForLevel(upgradeLevel), true));
                    stats.Add(new StatDescriptor("Node Upgrade Discount", 5f * upgradeLevel, true));
                    break;
            }

            // Always add luck if not already added and it's greater than 0
            if (specialty != AmuletSpecialty.Fortune && baseLuckBonus > 0)
            {
                stats.Add(new StatDescriptor("Luck", GetLuckBonusForLevel(upgradeLevel)));
            }

            // Add special ability info if applicable
            if (hasSpecialAbility)
            {
                stats.Add(new StatDescriptor("Special Ability", 100f, false));
            }

            return stats.ToArray();
        }

#if UNITY_EDITOR
        /// <summary>
        /// Validates required references are assigned in the editor
        /// </summary>
        public override bool ValidateReferences()
        {
            bool valid = base.ValidateReferences();

            if (hasSpecialAbility && specialAbilityVFX == null)
            {
                Debug.LogWarning($"[AmuletData] Special ability VFX is missing for {displayName}");
            }

            return valid;
        }
#endif
    }
}

// --- END FILE ---

// File: Shop/Equipment/Data/ArmorData.cs
// Size: 10424 characters
// ---
// File: Assets/Code/Shop/Equipment/Data/ArmorData.cs
//
// Purpose: Defines the data structure for armor equipment in Cyber Pickle.
// Contains armor-specific properties like defense bonuses, special effects,
// and weight/speed impact values.
//
// Created: 2025-02-25
// Updated: 2025-02-25

using UnityEngine;
using System;
using System.Collections.Generic;
using CyberPickle.Core.Services.Authentication.Data;

namespace CyberPickle.Shop.Equipment.Data
{
    /// <summary>
    /// Defines the armor's primary attribute focus
    /// </summary>
    public enum ArmorFocusType
    {
        Balanced,     // Equal focus on all attributes
        Defensive,    // Focus on defense and health
        Offensive,    // Focus on damage and attack speed
        Mobility,     // Focus on speed and magnetic field
        Utility       // Focus on luck and area of effect
    }

    /// <summary>
    /// ScriptableObject that defines data for armor equipment
    /// </summary>
    [CreateAssetMenu(fileName = "Armor", menuName = "CyberPickle/Equipment/ArmorData")]
    public class ArmorData : EquipmentData
    {
        [Header("Armor Properties")]
        [Tooltip("The focus type of this armor piece")]
        public ArmorFocusType focusType = ArmorFocusType.Balanced;

        [Tooltip("Base defense bonus")]
        public float baseDefenseBonus = 10f;

        [Tooltip("Base health bonus")]
        public float baseHealthBonus = 20f;

        [Tooltip("Speed modifier (negative values slow down the player)")]
        public float speedModifier = 0f;

        [Tooltip("Health regeneration bonus")]
        public float healthRegenBonus = 0f;

        [Header("Special Effects")]
        [Tooltip("Does this armor have a special effect?")]
        public bool hasSpecialEffect = false;

        [Tooltip("Description of special effect")]
        [TextArea(2, 4)]
        public string specialEffectDescription;

        [Tooltip("Chance to trigger the special effect (if applicable)")]
        [Range(0f, 1f)]
        public float specialEffectChance = 0.1f;

        [Tooltip("Cooldown for special effect (if applicable)")]
        public float specialEffectCooldown = 10f;

        [Header("Visual & Audio")]
        [Tooltip("Visual effect prefab when special effect activates")]
        public GameObject specialEffectVFX;

        [Tooltip("Sound effect when special effect activates")]
        public AudioClip specialEffectSound;

        [Tooltip("Override character material with this (if not null)")]
        public Material armorMaterial;

        [Header("Upgrade Scaling")]
        [Tooltip("Defense increase per level (multiplier)")]
        [Range(1f, 2f)]
        public float defenseUpgradeMultiplier = 1.2f;

        [Tooltip("Health increase per level (multiplier)")]
        [Range(1f, 2f)]
        public float healthUpgradeMultiplier = 1.15f;

        [Tooltip("Special effect chance increase per level (flat addition)")]
        [Range(0f, 0.1f)]
        public float specialEffectChanceIncrease = 0.02f;

        /// <summary>
        /// Validates the armor data when it's created or modified in the editor.
        /// </summary>
        protected override void OnValidate()
        {
            // Ensure correct slot type
            slotType = EquipmentSlotType.Armor;

            base.OnValidate();

            // Additional armor-specific validation
            ValidateArmorFields();
        }

        /// <summary>
        /// Validates armor-specific fields
        /// </summary>
        private void ValidateArmorFields()
        {
            baseDefenseBonus = Mathf.Max(0f, baseDefenseBonus);
            baseHealthBonus = Mathf.Max(0f, baseHealthBonus);

            // Speed modifier can be negative (slows down), but not too extreme
            speedModifier = Mathf.Clamp(speedModifier, -0.3f, 0.3f);

            healthRegenBonus = Mathf.Max(0f, healthRegenBonus);

            if (hasSpecialEffect)
            {
                specialEffectChance = Mathf.Clamp01(specialEffectChance);
                specialEffectCooldown = Mathf.Max(1f, specialEffectCooldown);

                if (string.IsNullOrEmpty(specialEffectDescription))
                {
                    specialEffectDescription = "Activates a special effect.";
                    Debug.LogWarning($"[ArmorData] Special effect description is empty for {displayName}");
                }
            }
        }

        /// <summary>
        /// Gets the defense bonus for the specified upgrade level
        /// </summary>
        /// <param name="level">Upgrade level</param>
        /// <returns>Defense bonus at that level</returns>
        public float GetDefenseBonusForLevel(int level)
        {
            level = Mathf.Clamp(level, 1, maxUpgradeLevel);
            return baseDefenseBonus * Mathf.Pow(defenseUpgradeMultiplier, level - 1);
        }

        /// <summary>
        /// Gets the health bonus for the specified upgrade level
        /// </summary>
        /// <param name="level">Upgrade level</param>
        /// <returns>Health bonus at that level</returns>
        public float GetHealthBonusForLevel(int level)
        {
            level = Mathf.Clamp(level, 1, maxUpgradeLevel);
            return baseHealthBonus * Mathf.Pow(healthUpgradeMultiplier, level - 1);
        }

        /// <summary>
        /// Gets the health regeneration bonus for the specified upgrade level
        /// </summary>
        /// <param name="level">Upgrade level</param>
        /// <returns>Health regen bonus at that level</returns>
        public float GetHealthRegenBonusForLevel(int level)
        {
            level = Mathf.Clamp(level, 1, maxUpgradeLevel);

            if (healthRegenBonus <= 0f)
                return 0f;

            // Health regen scales linearly with level
            return healthRegenBonus * (1f + (0.2f * (level - 1)));
        }

        /// <summary>
        /// Gets the special effect chance for the specified upgrade level
        /// </summary>
        /// <param name="level">Upgrade level</param>
        /// <returns>Special effect chance at that level</returns>
        public float GetSpecialEffectChanceForLevel(int level)
        {
            if (!hasSpecialEffect)
                return 0f;

            level = Mathf.Clamp(level, 1, maxUpgradeLevel);
            return Mathf.Clamp01(specialEffectChance + (specialEffectChanceIncrease * (level - 1)));
        }

        /// <summary>
        /// Gets the special effect cooldown for the specified upgrade level
        /// </summary>
        /// <param name="level">Upgrade level</param>
        /// <returns>Special effect cooldown at that level</returns>
        public float GetSpecialEffectCooldownForLevel(int level)
        {
            if (!hasSpecialEffect)
                return 0f;

            level = Mathf.Clamp(level, 1, maxUpgradeLevel);

            // Cooldown reduces by 10% per level (multiplicative)
            return specialEffectCooldown * Mathf.Pow(0.9f, level - 1);
        }

        /// <summary>
        /// Gets the stats for the specified upgrade level
        /// </summary>
        public override StatDescriptor[] GetStatsForLevel(int upgradeLevel)
        {
            upgradeLevel = Mathf.Clamp(upgradeLevel, 1, maxUpgradeLevel);

            List<StatDescriptor> stats = new List<StatDescriptor>();

            // Always add the main armor stats
            stats.Add(new StatDescriptor("Defense", GetDefenseBonusForLevel(upgradeLevel)));
            stats.Add(new StatDescriptor("Health", GetHealthBonusForLevel(upgradeLevel)));

            // Add speed modifier if not zero
            if (speedModifier != 0f)
            {
                stats.Add(new StatDescriptor("Speed", speedModifier * 100f, true, speedModifier > 0f));
            }

            // Add health regen if applicable
            if (healthRegenBonus > 0f)
            {
                stats.Add(new StatDescriptor("Health Regen", GetHealthRegenBonusForLevel(upgradeLevel)));
            }

            // Add special effect stats if applicable
            if (hasSpecialEffect)
            {
                stats.Add(new StatDescriptor("Effect Chance", GetSpecialEffectChanceForLevel(upgradeLevel) * 100f, true));
                stats.Add(new StatDescriptor("Effect Cooldown", GetSpecialEffectCooldownForLevel(upgradeLevel), false, false));
            }

            // Add additional stats based on focus type
            switch (focusType)
            {
                case ArmorFocusType.Offensive:
                    stats.Add(new StatDescriptor("Power", 5f * upgradeLevel, false, true));
                    break;

                case ArmorFocusType.Mobility:
                    if (speedModifier <= 0) // Only add if not already added above
                    {
                        stats.Add(new StatDescriptor("Speed", 3f * upgradeLevel, false, true));
                    }
                    stats.Add(new StatDescriptor("Magnetic Field", 0.2f * upgradeLevel, false, true));
                    break;

                case ArmorFocusType.Utility:
                    stats.Add(new StatDescriptor("Luck", 0.05f * upgradeLevel, false, true));
                    stats.Add(new StatDescriptor("Area of Effect", 0.1f * upgradeLevel, false, true));
                    break;
            }

            return stats.ToArray();
        }

#if UNITY_EDITOR
        /// <summary>
        /// Validates required references are assigned in the editor
        /// </summary>
        public override bool ValidateReferences()
        {
            bool valid = base.ValidateReferences();

            if (hasSpecialEffect)
            {
                if (specialEffectVFX == null)
                {
                    Debug.LogWarning($"[ArmorData] Special effect VFX is missing for {displayName}");
                }

                if (specialEffectSound == null)
                {
                    Debug.LogWarning($"[ArmorData] Special effect sound is missing for {displayName}");
                }
            }

            return valid;
        }
#endif
    }
}

// --- END FILE ---

// File: Shop/Equipment/Data/EquipmentData.cs
// Size: 6388 characters
// ---
// File: Assets/Code/Shop/Equipment/Data/EquipmentData.cs
//
// Purpose: Defines the base data structure for all equipment types in Cyber Pickle.
// This ScriptableObject is the parent class for weapons, power-ups, armor, and amulets.
// Contains shared properties and functionality across all equipment types.
//
// Created: 2025-02-25
// Updated: 2025-02-25

using UnityEngine;
using System;
using CyberPickle.Core.Services.Authentication.Data;

namespace CyberPickle.Shop.Equipment.Data
{
    /// <summary>
    /// Base ScriptableObject class for all equipment types in the game.
    /// Defines common properties and functions shared across different equipment.
    /// </summary>
    public abstract class EquipmentData : ScriptableObject
    {
        [Header("Basic Info")]
        [Tooltip("Unique identifier for the equipment")]
        public string equipmentId;

        [Tooltip("Display name shown in the UI")]
        public string displayName;

        [Tooltip("Equipment description shown in shop and inventory")]
        [TextArea(3, 5)]
        public string description;

        [Header("Equipment Type")]
        [Tooltip("Type of equipment slot this item uses")]
        public EquipmentSlotType slotType;

        [Header("Visual References")]
        [Tooltip("2D icon for UI elements")]
        public Sprite equipmentIcon;

        [Tooltip("3D model prefab for this equipment")]
        public GameObject equipmentPrefab;

        [Header("Economy")]
        [Tooltip("Base cost in Neural Credits")]
        public int neuralCreditCost;

        [Tooltip("Cost in CyberCoins (if purchasable with premium currency)")]
        public int cyberCoinCost;

        [Header("Unlock Requirements")]
        [Tooltip("If true, equipment is available from the start")]
        public bool unlockedByDefault;

        [Tooltip("Minimum player level required to unlock")]
        public int requiredPlayerLevel;

        [Tooltip("Achievement IDs required to unlock this equipment")]
        public string[] requiredAchievements;

        [Header("Upgrade Path")]
        [Tooltip("Maximum upgrade level")]
        [Range(1, 5)]
        public int maxUpgradeLevel = 5;

        /// <summary>
        /// Validates the equipment data when it's created or modified in the editor.
        /// Automatically generates an equipmentId if none is provided.
        /// </summary>
        protected virtual void OnValidate()
        {
            if (string.IsNullOrEmpty(equipmentId))
            {
                equipmentId = $"{slotType.ToString().ToLower()}_{displayName?.ToLower().Replace(" ", "_") ?? "undefined"}";
                Debug.Log($"[EquipmentData] Auto-generated equipmentId: {equipmentId}");
            }

            ValidateFields();
        }

        /// <summary>
        /// Validates equipment fields have appropriate values
        /// </summary>
        protected virtual void ValidateFields()
        {
            neuralCreditCost = Mathf.Max(0, neuralCreditCost);
            cyberCoinCost = Mathf.Max(0, cyberCoinCost);
            requiredPlayerLevel = Mathf.Max(1, requiredPlayerLevel);
        }

        /// <summary>
        /// Gets the equipment's stats for the specified upgrade level
        /// </summary>
        /// <param name="upgradeLevel">The upgrade level to get stats for (1-5)</param>
        /// <returns>An array of stat descriptors for display</returns>
        public abstract StatDescriptor[] GetStatsForLevel(int upgradeLevel);

        /// <summary>
        /// Gets the cost to upgrade this equipment to the specified level
        /// </summary>
        /// <param name="currentLevel">Current level of the equipment</param>
        /// <param name="targetLevel">Target level to upgrade to</param>
        /// <returns>The cost in Neural Credits to upgrade</returns>
        public virtual int GetUpgradeCost(int currentLevel, int targetLevel)
        {
            if (currentLevel >= targetLevel || currentLevel < 1 || targetLevel > maxUpgradeLevel)
                return 0;

            // Base upgrade cost calculation
            int baseCost = neuralCreditCost / 2;
            float multiplier = 1.5f;

            int totalCost = 0;
            for (int level = currentLevel; level < targetLevel; level++)
            {
                totalCost += Mathf.RoundToInt(baseCost * Mathf.Pow(multiplier, level - 1));
            }

            return totalCost;
        }

#if UNITY_EDITOR
        /// <summary>
        /// Validates required references are assigned in the editor
        /// </summary>
        public virtual bool ValidateReferences()
        {
            if (equipmentIcon == null)
            {
                Debug.LogError($"[EquipmentData] Equipment icon is missing for {displayName}");
                return false;
            }

            return true;
        }
#endif
    }

    /// <summary>
    /// Struct to describe a single stat for display purposes
    /// </summary>
    [Serializable]
    public struct StatDescriptor
    {
        /// <summary>
        /// The name of the stat
        /// </summary>
        public string statName;

        /// <summary>
        /// The value of the stat (can be raw number or percentage)
        /// </summary>
        public float value;

        /// <summary>
        /// Whether this stat should be displayed as a percentage
        /// </summary>
        public bool isPercentage;

        /// <summary>
        /// Whether higher values are better (green) or worse (red)
        /// </summary>
        public bool higherIsBetter;

        /// <summary>
        /// Creates a new stat descriptor
        /// </summary>
        public StatDescriptor(string name, float value, bool isPercentage = false, bool higherIsBetter = true)
        {
            this.statName = name;
            this.value = value;
            this.isPercentage = isPercentage;
            this.higherIsBetter = higherIsBetter;
        }

        /// <summary>
        /// Gets the formatted display value as a string
        /// </summary>
        public string GetDisplayValue()
        {
            return isPercentage ? $"{value:F1}%" : $"{value:F1}";
        }
    }
}

// --- END FILE ---

// File: Shop/Equipment/Data/PowerUpData.cs
// Size: 11887 characters
// ---
// File: Assets/Code/Shop/Equipment/Data/PowerUpData.cs
//
// Purpose: Defines the data structure for power-ups in Cyber Pickle.
// Contains power-up effects and their scaling with upgrade levels.
// Supports synergies with weapons to unlock final weapon forms.
//
// Created: 2025-02-25
// Updated: 2025-02-25

using UnityEngine;
using System;
using System.Collections.Generic;
using CyberPickle.Core.Services.Authentication.Data;

namespace CyberPickle.Shop.Equipment.Data
{
    /// <summary>
    /// Defines the type of effect a power-up provides
    /// </summary>
    public enum PowerUpEffectType
    {
        StatBoost,      // Directly boosts a character stat
        WeaponBoost,    // Enhances weapon performance
        SpecialEffect,  // Provides a special gameplay effect
        DefensiveAbility, // Provides a defensive ability
        PassiveAbility  // Provides a passive ability
    }

    /// <summary>
    /// Scriptable Object that defines data for power-up equipment
    /// </summary>
    [CreateAssetMenu(fileName = "PowerUp", menuName = "CyberPickle/Equipment/PowerUpData")]
    public class PowerUpData : EquipmentData
    {
        [Header("Power-Up Properties")]
        [Tooltip("The type of effect this power-up provides")]
        public PowerUpEffectType effectType = PowerUpEffectType.StatBoost;

        [Tooltip("Duration of the effect in seconds (0 = permanent)")]
        public float baseDuration = 0f;

        [Tooltip("Cooldown before the power-up can be activated again (0 = passive effect)")]
        public float baseCooldown = 0f;

        [Tooltip("Is this power-up automatically activated or manually triggered?")]
        public bool isPassive = true;

        [Header("Stat Boosts")]
        [Tooltip("The stat this power-up affects (if applicable)")]
        public string affectedStat = "Power";

        [Tooltip("Base amount to boost the stat by")]
        public float baseStatBoost = 10f;

        [Tooltip("Is the stat boost a flat value (false) or percentage (true)?")]
        public bool isPercentageBased = true;

        [Header("Weapon Enhancement")]
        [Tooltip("Compatible weapon types for enhanced effects")]
        public EquipmentSlotType[] compatibleWeaponTypes;

        [Tooltip("Weapon IDs that have special synergy with this power-up")]
        public string[] synergisticWeaponIds;

        [Tooltip("Weapon properties affected by this power-up")]
        public string[] affectedWeaponProperties;

        [Tooltip("Base multiplier for weapon enhancement")]
        public float baseWeaponEnhancementMultiplier = 1.2f;

        [Header("Special Effects")]
        [Tooltip("Description of special effects for level 1")]
        [TextArea(2, 5)]
        public string baseEffectDescription;

        [Tooltip("Description of special effects for max level")]
        [TextArea(2, 5)]
        public string maxLevelEffectDescription;

        [Header("Visual & Audio")]
        [Tooltip("VFX prefab for when the power-up is active")]
        public GameObject activeEffectPrefab;

        [Tooltip("Sound effect for activation")]
        public AudioClip activationSound;

        [Header("Upgrade Scaling")]
        [Tooltip("Effect strength increase per level (multiplier)")]
        [Range(1f, 2f)]
        public float effectStrengthUpgradeMultiplier = 1.2f;

        [Tooltip("Duration increase per level (multiplier)")]
        [Range(1f, 1.5f)]
        public float durationUpgradeMultiplier = 1.15f;

        [Tooltip("Cooldown reduction per level (multiplier)")]
        [Range(0.5f, 1f)]
        public float cooldownReductionMultiplier = 0.9f;

        /// <summary>
        /// Validates the power-up data when it's created or modified in the editor.
        /// </summary>
        protected override void OnValidate()
        {
            // Ensure correct slot type
            slotType = EquipmentSlotType.PowerUp;

            base.OnValidate();

            // Additional power-up specific validation
            ValidatePowerUpFields();
        }

        /// <summary>
        /// Validates power-up specific fields
        /// </summary>
        private void ValidatePowerUpFields()
        {
            // Ensure base values are valid
            baseDuration = Mathf.Max(0f, baseDuration);
            baseCooldown = Mathf.Max(0f, baseCooldown);
            baseStatBoost = Mathf.Max(0f, baseStatBoost);
            baseWeaponEnhancementMultiplier = Mathf.Max(1f, baseWeaponEnhancementMultiplier);

            // Ensure scaling multipliers are in valid ranges
            effectStrengthUpgradeMultiplier = Mathf.Max(1f, effectStrengthUpgradeMultiplier);

            if (baseDuration > 0)
                durationUpgradeMultiplier = Mathf.Max(1f, durationUpgradeMultiplier);

            if (baseCooldown > 0)
                cooldownReductionMultiplier = Mathf.Clamp(cooldownReductionMultiplier, 0.5f, 1f);
        }

        /// <summary>
        /// Gets the power-up's effect strength for a specified upgrade level
        /// </summary>
        /// <param name="level">Upgrade level of the power-up</param>
        /// <returns>The effect strength value at that level</returns>
        public float GetEffectStrengthForLevel(int level)
        {
            level = Mathf.Clamp(level, 1, maxUpgradeLevel);

            switch (effectType)
            {
                case PowerUpEffectType.StatBoost:
                    return baseStatBoost * Mathf.Pow(effectStrengthUpgradeMultiplier, level - 1);

                case PowerUpEffectType.WeaponBoost:
                    return baseWeaponEnhancementMultiplier + (0.1f * (level - 1));

                default:
                    return Mathf.Pow(effectStrengthUpgradeMultiplier, level - 1);
            }
        }

        /// <summary>
        /// Gets the power-up's duration for a specified upgrade level
        /// </summary>
        /// <param name="level">Upgrade level of the power-up</param>
        /// <returns>The duration in seconds at that level</returns>
        public float GetDurationForLevel(int level)
        {
            if (baseDuration <= 0) return 0f; // Permanent effect

            level = Mathf.Clamp(level, 1, maxUpgradeLevel);
            return baseDuration * Mathf.Pow(durationUpgradeMultiplier, level - 1);
        }

        /// <summary>
        /// Gets the power-up's cooldown for a specified upgrade level
        /// </summary>
        /// <param name="level">Upgrade level of the power-up</param>
        /// <returns>The cooldown in seconds at that level</returns>
        public float GetCooldownForLevel(int level)
        {
            if (baseCooldown <= 0) return 0f; // No cooldown

            level = Mathf.Clamp(level, 1, maxUpgradeLevel);
            return baseCooldown * Mathf.Pow(cooldownReductionMultiplier, level - 1);
        }

        /// <summary>
        /// Gets a formatted effect description for the specified level
        /// </summary>
        /// <param name="level">Upgrade level of the power-up</param>
        /// <returns>A formatted description of the effect at that level</returns>
        public string GetEffectDescriptionForLevel(int level)
        {
            level = Mathf.Clamp(level, 1, maxUpgradeLevel);

            // For level 1, return the base description
            if (level == 1)
                return baseEffectDescription;

            // For max level, return the max level description
            if (level == maxUpgradeLevel && !string.IsNullOrEmpty(maxLevelEffectDescription))
                return maxLevelEffectDescription;

            // For intermediate levels, generate a description based on effect type
            string description = baseEffectDescription;

            // Replace placeholders with actual values
            description = description.Replace("{strength}", GetEffectStrengthForLevel(level).ToString("F1"));
            description = description.Replace("{duration}", GetDurationForLevel(level).ToString("F1"));
            description = description.Replace("{cooldown}", GetCooldownForLevel(level).ToString("F1"));

            return description;
        }

        /// <summary>
        /// Gets the stats for the specified upgrade level
        /// </summary>
        public override StatDescriptor[] GetStatsForLevel(int upgradeLevel)
        {
            upgradeLevel = Mathf.Clamp(upgradeLevel, 1, maxUpgradeLevel);

            List<StatDescriptor> stats = new List<StatDescriptor>();

            // Add stats based on effect type
            switch (effectType)
            {
                case PowerUpEffectType.StatBoost:
                    stats.Add(new StatDescriptor(
                        affectedStat,
                        GetEffectStrengthForLevel(upgradeLevel),
                        isPercentageBased,
                        true
                    ));
                    break;

                case PowerUpEffectType.WeaponBoost:
                    stats.Add(new StatDescriptor(
                        "Weapon Boost",
                        (GetEffectStrengthForLevel(upgradeLevel) - 1) * 100f,
                        true,
                        true
                    ));
                    break;

                case PowerUpEffectType.SpecialEffect:
                case PowerUpEffectType.DefensiveAbility:
                case PowerUpEffectType.PassiveAbility:
                    stats.Add(new StatDescriptor(
                        "Effect Strength",
                        GetEffectStrengthForLevel(upgradeLevel) * 100f,
                        true,
                        true
                    ));
                    break;
            }

            // Add duration if applicable
            if (baseDuration > 0)
            {
                stats.Add(new StatDescriptor(
                    "Duration",
                    GetDurationForLevel(upgradeLevel),
                    false,
                    true
                ));
            }

            // Add cooldown if applicable
            if (baseCooldown > 0)
            {
                stats.Add(new StatDescriptor(
                    "Cooldown",
                    GetCooldownForLevel(upgradeLevel),
                    false,
                    false  // Lower is better for cooldown
                ));
            }

            return stats.ToArray();
        }

        /// <summary>
        /// Determines if this power-up can enhance the specified weapon
        /// </summary>
        /// <param name="weaponId">The ID of the weapon to check</param>
        /// <returns>True if compatible, false otherwise</returns>
        public bool IsCompatibleWithWeapon(string weaponId)
        {
            if (string.IsNullOrEmpty(weaponId))
                return false;

            // Check if weapon is in synergistic list
            for (int i = 0; i < synergisticWeaponIds.Length; i++)
            {
                if (synergisticWeaponIds[i] == weaponId)
                    return true;
            }

            return false;
        }

#if UNITY_EDITOR
        /// <summary>
        /// Validates required references are assigned in the editor
        /// </summary>
        public override bool ValidateReferences()
        {
            bool valid = base.ValidateReferences();

            if (activationSound == null && !isPassive)
            {
                Debug.LogWarning($"[PowerUpData] Activation sound is missing for non-passive power-up {displayName}");
            }

            return valid;
        }
#endif
    }
}
// --- END FILE ---

// File: Shop/Equipment/Data/WeaponData.cs
// Size: 10077 characters
// ---
// File: Assets/Code/Shop/Equipment/Data/WeaponData.cs
//
// Purpose: Defines the data structure for weapons in Cyber Pickle.
// Contains weapon-specific properties like damage, fire rate, and special effects.
// Supports hand weapons and body weapons with their unique characteristics.
//
// Created: 2025-02-25
// Updated: 2025-02-25

using UnityEngine;
using System;
using System.Collections.Generic;
using CyberPickle.Core.Services.Authentication.Data;

namespace CyberPickle.Shop.Equipment.Data
{
    /// <summary>
    /// Defines possible weapon attack types
    /// </summary>
    public enum WeaponAttackType
    {
        Projectile,
        Beam,
        Area,
        Melee
    }

    /// <summary>
    /// ScriptableObject that defines data for weapon equipment
    /// </summary>
    [CreateAssetMenu(fileName = "Weapon", menuName = "CyberPickle/Equipment/WeaponData")]
    public class WeaponData : EquipmentData
    {
        [Header("Weapon Properties")]
        [Tooltip("The type of weapon - hand or body")]
        public EquipmentSlotType weaponType = EquipmentSlotType.HandWeapon;

        [Tooltip("How this weapon attacks")]
        public WeaponAttackType attackType = WeaponAttackType.Projectile;

        [Tooltip("Base damage per attack/projectile")]
        public float baseDamage = 10f;

        [Tooltip("Base fire rate in shots per second")]
        public float baseFireRate = 2f;

        [Tooltip("Base projectile speed (if applicable)")]
        public float baseProjectileSpeed = 10f;

        [Tooltip("Base area of effect radius (if applicable)")]
        public float baseAreaOfEffect = 1f;

        [Tooltip("Base pierce count (0 = no pierce)")]
        public int basePierceCount = 0;

        [Tooltip("Does this weapon have a critical hit chance?")]
        public bool canCriticalHit = false;

        [Tooltip("Base critical hit chance (if applicable)")]
        [Range(0f, 1f)]
        public float baseCriticalChance = 0.05f;

        [Tooltip("Critical hit damage multiplier")]
        public float criticalDamageMultiplier = 2f;

        [Header("Audio & VFX")]
        [Tooltip("Prefab for projectile or attack VFX")]
        public GameObject projectilePrefab;

        [Tooltip("Sound effect for firing")]
        public AudioClip fireSound;

        [Tooltip("Sound effect for hitting")]
        public AudioClip hitSound;

        [Tooltip("VFX prefab for hit effect")]
        public GameObject hitEffectPrefab;

        [Header("Upgrade Scaling")]
        [Tooltip("Damage increase per level (multiplier)")]
        [Range(1f, 2f)]
        public float damageUpgradeMultiplier = 1.2f;

        [Tooltip("Fire rate increase per level (multiplier)")]
        [Range(1f, 1.5f)]
        public float fireRateUpgradeMultiplier = 1.1f;

        [Tooltip("Other stats upgrade multiplier")]
        [Range(1f, 1.5f)]
        public float otherStatsUpgradeMultiplier = 1.15f;

        [Header("Final Form")]
        [Tooltip("Final weapon form when fully upgraded with associated power-up")]
        public WeaponData finalForm;

        [Tooltip("Required power-up ID to unlock final form")]
        public string requiredPowerUpId;

        /// <summary>
        /// Validates the weapon data when it's created or modified in the editor.
        /// </summary>
        protected override void OnValidate()
        {
            // Set the slot type based on weapon type
            slotType = weaponType;

            base.OnValidate();

            // Additional weapon-specific validation
            ValidateWeaponFields();
        }

        /// <summary>
        /// Validates weapon-specific fields
        /// </summary>
        private void ValidateWeaponFields()
        {
            baseDamage = Mathf.Max(0.1f, baseDamage);
            baseFireRate = Mathf.Max(0.1f, baseFireRate);
            baseProjectileSpeed = Mathf.Max(0.1f, baseProjectileSpeed);
            baseAreaOfEffect = Mathf.Max(0.1f, baseAreaOfEffect);
            basePierceCount = Mathf.Max(0, basePierceCount);

            if (canCriticalHit)
            {
                baseCriticalChance = Mathf.Clamp(baseCriticalChance, 0f, 1f);
                criticalDamageMultiplier = Mathf.Max(1f, criticalDamageMultiplier);
            }
        }

        /// <summary>
        /// Gets the weapon's damage for the specified upgrade level
        /// </summary>
        /// <param name="level">Upgrade level of the weapon</param>
        /// <returns>The damage value at that level</returns>
        public float GetDamageForLevel(int level)
        {
            level = Mathf.Clamp(level, 1, maxUpgradeLevel);
            return baseDamage * Mathf.Pow(damageUpgradeMultiplier, level - 1);
        }

        /// <summary>
        /// Gets the weapon's fire rate for the specified upgrade level
        /// </summary>
        /// <param name="level">Upgrade level of the weapon</param>
        /// <returns>The fire rate value at that level</returns>
        public float GetFireRateForLevel(int level)
        {
            level = Mathf.Clamp(level, 1, maxUpgradeLevel);
            return baseFireRate * Mathf.Pow(fireRateUpgradeMultiplier, level - 1);
        }

        /// <summary>
        /// Gets the weapon's projectile speed for the specified upgrade level
        /// </summary>
        /// <param name="level">Upgrade level of the weapon</param>
        /// <returns>The projectile speed value at that level</returns>
        public float GetProjectileSpeedForLevel(int level)
        {
            level = Mathf.Clamp(level, 1, maxUpgradeLevel);
            return baseProjectileSpeed * Mathf.Pow(otherStatsUpgradeMultiplier, level - 1);
        }

        /// <summary>
        /// Gets the weapon's area of effect for the specified upgrade level
        /// </summary>
        /// <param name="level">Upgrade level of the weapon</param>
        /// <returns>The area of effect value at that level</returns>
        public float GetAreaOfEffectForLevel(int level)
        {
            level = Mathf.Clamp(level, 1, maxUpgradeLevel);
            return baseAreaOfEffect * Mathf.Pow(otherStatsUpgradeMultiplier, level - 1);
        }

        /// <summary>
        /// Gets the weapon's pierce count for the specified upgrade level
        /// </summary>
        /// <param name="level">Upgrade level of the weapon</param>
        /// <returns>The pierce count at that level</returns>
        public int GetPierceCountForLevel(int level)
        {
            level = Mathf.Clamp(level, 1, maxUpgradeLevel);
            // Pierce increases every 2 levels
            return basePierceCount + ((level - 1) / 2);
        }

        /// <summary>
        /// Gets the weapon's critical hit chance for the specified upgrade level
        /// </summary>
        /// <param name="level">Upgrade level of the weapon</param>
        /// <returns>The critical hit chance at that level</returns>
        public float GetCriticalChanceForLevel(int level)
        {
            if (!canCriticalHit) return 0f;

            level = Mathf.Clamp(level, 1, maxUpgradeLevel);
            // Critical chance increases by 1% per level up to a maximum of base + 0.2
            return Mathf.Min(baseCriticalChance + (0.01f * (level - 1)), baseCriticalChance + 0.2f);
        }

        /// <summary>
        /// Gets an array of stat descriptors for the specified upgrade level
        /// </summary>
        public override StatDescriptor[] GetStatsForLevel(int upgradeLevel)
        {
            upgradeLevel = Mathf.Clamp(upgradeLevel, 1, maxUpgradeLevel);

            List<StatDescriptor> stats = new List<StatDescriptor>();

            // Add base stats
            stats.Add(new StatDescriptor("Damage", GetDamageForLevel(upgradeLevel)));
            stats.Add(new StatDescriptor("Fire Rate", GetFireRateForLevel(upgradeLevel)));

            // Add attack type specific stats
            switch (attackType)
            {
                case WeaponAttackType.Projectile:
                    stats.Add(new StatDescriptor("Projectile Speed", GetProjectileSpeedForLevel(upgradeLevel)));

                    if (basePierceCount > 0 || upgradeLevel > 2)
                    {
                        stats.Add(new StatDescriptor("Pierce Count", GetPierceCountForLevel(upgradeLevel)));
                    }
                    break;

                case WeaponAttackType.Area:
                    stats.Add(new StatDescriptor("Area of Effect", GetAreaOfEffectForLevel(upgradeLevel)));
                    break;

                case WeaponAttackType.Beam:
                    stats.Add(new StatDescriptor("Range", GetAreaOfEffectForLevel(upgradeLevel)));
                    break;
            }

            // Add critical hit stats if applicable
            if (canCriticalHit)
            {
                stats.Add(new StatDescriptor("Critical Chance", GetCriticalChanceForLevel(upgradeLevel) * 100f, true));
                stats.Add(new StatDescriptor("Critical Damage", criticalDamageMultiplier * 100f, true));
            }

            return stats.ToArray();
        }

#if UNITY_EDITOR
        /// <summary>
        /// Validates required references are assigned in the editor
        /// </summary>
        public override bool ValidateReferences()
        {
            bool valid = base.ValidateReferences();

            if (projectilePrefab == null && attackType == WeaponAttackType.Projectile)
            {
                Debug.LogError($"[WeaponData] Projectile prefab is missing for {displayName}");
                valid = false;
            }

            if (fireSound == null)
            {
                Debug.LogWarning($"[WeaponData] Fire sound is missing for {displayName}");
            }

            return valid;
        }
#endif
    }
}

// --- END FILE ---

// File: Shop/Mining/UI/MiningUIController.cs
// Size: 320 characters
// ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class MiningUIController : MonoBehaviour
{
    // Start is called before the first frame update
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}

// --- END FILE ---

// File: UI/Components/ProfileCard/ProfileCardExpanded.cs
// Size: 6637 characters
// ---
// File: Assets/Code/UI/Components/ProfileCard/ProfileCardExpanded.cs
//
// Purpose: Handles the expanded view of the profile card showing detailed information
// and providing minimize and profile switch options.
//
// Created: 2024-02-11

using UnityEngine;
using UnityEngine.UI;
using TMPro;
using System;
using CyberPickle.Core.Events;
using CyberPickle.Core.Services.Authentication;
using CyberPickle.Core.Services.Authentication.Data;
using CyberPickle.Core.States;

namespace CyberPickle.UI.Components.ProfileCard
{
    public class ProfileCardExpanded : MonoBehaviour
    {
        [Header("Card Elements")]
        [SerializeField] private Image backgroundPanel;
        [SerializeField] private Image neonBorder;

        [Header("Header Section")]
        [SerializeField] private TextMeshProUGUI profileNameText;
        [SerializeField] private TextMeshProUGUI lastLoginText;
        [SerializeField] private Image avatarImage;

        [Header("Stats Grid")]
        [SerializeField] private GridLayoutGroup statsGrid;
        [SerializeField] private TextMeshProUGUI levelStatValue;
        [SerializeField] private TextMeshProUGUI timeStatValue;
        [SerializeField] private TextMeshProUGUI scoreStatValue;

        [Header("Buttons")]
        [SerializeField] private Button minimizeButton;
        [SerializeField] private TextMeshProUGUI minimizeButtonText;
        [SerializeField] private Button switchProfileButton;
        [SerializeField] private TextMeshProUGUI switchProfileButtonText;

        private ProfileData currentProfile;
        private CanvasGroup canvasGroup;

        private void Awake()
        {
            canvasGroup = GetComponent<CanvasGroup>();
            ValidateReferences();
            SetupButtons();
        }

        private void OnEnable()
        {
            SubscribeToEvents();
        }

        private void OnDisable()
        {
            UnsubscribeFromEvents();
        }

        private void ValidateReferences()
        {
            if (profileNameText == null)
                Debug.LogError("[ProfileCardExpanded] Profile name text is missing!");
            if (lastLoginText == null)
                Debug.LogError("[ProfileCardExpanded] Last login text is missing!");
            if (minimizeButton == null)
                Debug.LogError("[ProfileCardExpanded] Minimize button is missing!");
            if (switchProfileButton == null)
                Debug.LogError("[ProfileCardExpanded] Switch Profile button is missing!");
            if (canvasGroup == null)
                canvasGroup = gameObject.AddComponent<CanvasGroup>();
        }

        private void SetupButtons()
        {
            if (minimizeButton != null)
            {
                minimizeButton.onClick.AddListener(() => GameEvents.OnProfileCardClicked.Invoke());
                if (minimizeButtonText != null)
                    minimizeButtonText.text = "Minimize";
            }

            if (switchProfileButton != null)
            {
                switchProfileButton.onClick.AddListener(HandleSwitchProfileClick);
                if (switchProfileButtonText != null)
                    switchProfileButtonText.text = "Change Profile";
            }
        }

        private void SubscribeToEvents()
        {
            GameEvents.OnProfileCardInteractionEnabled.AddListener(SetInteractable);
        }

        private void UnsubscribeFromEvents()
        {
            GameEvents.OnProfileCardInteractionEnabled.RemoveListener(SetInteractable);
        }

        public void UpdateDisplay(ProfileData profileData)
        {
            if (profileData == null) return;

            currentProfile = profileData;

            // Update header information
            if (profileNameText != null)
                profileNameText.text = profileData.DisplayName;

            if (lastLoginText != null)
                lastLoginText.text = FormatLastLoginTime(profileData.LastLoginTime);

            // Update stats
            if (levelStatValue != null)
                levelStatValue.text = profileData.Level.ToString();

            if (timeStatValue != null)
                timeStatValue.text = FormatPlayTime(profileData.TotalPlayTime);

            if (scoreStatValue != null)
                scoreStatValue.text = profileData.HighestScore.ToString();

            // Avatar implementation can be added later
            if (avatarImage != null)
                avatarImage.gameObject.SetActive(false);
        }

        private void HandleSwitchProfileClick()
        {
            GameEvents.OnGameStateChanged.Invoke(GameState.ProfileSelection);
            GameEvents.OnProfileLoadRequested.Invoke();

        }

        public void SetInteractable(bool interactable)
        {
            if (minimizeButton != null)
                minimizeButton.interactable = interactable;

            if (switchProfileButton != null)
                switchProfileButton.interactable = interactable;

            if (canvasGroup != null)
            {
                canvasGroup.interactable = interactable;
                canvasGroup.blocksRaycasts = interactable;
            }
        }

        private string FormatPlayTime(float playTimeInSeconds)
        {
            TimeSpan time = TimeSpan.FromSeconds(playTimeInSeconds);
            if (time.TotalHours >= 1)
                return $"{(int)time.TotalHours}h {time.Minutes}m";
            else if (time.Minutes >= 1)
                return $"{time.Minutes}m {time.Seconds}s";
            else
                return $"{time.Seconds}s";
        }

        private string FormatLastLoginTime(DateTime lastLoginTime)
        {
            TimeSpan timeSince = DateTime.Now - lastLoginTime;

            if (timeSince.TotalDays >= 1)
                return $"{(int)timeSince.TotalDays} days ago";
            else if (timeSince.TotalHours >= 1)
                return $"{(int)timeSince.TotalHours} hours ago";
            else if (timeSince.TotalMinutes >= 1)
                return $"{(int)timeSince.TotalMinutes} minutes ago";
            else
                return "Just now";
        }

        private void OnDestroy()
        {
            if (minimizeButton != null)
                minimizeButton.onClick.RemoveAllListeners();

            if (switchProfileButton != null)
                switchProfileButton.onClick.RemoveAllListeners();

            UnsubscribeFromEvents();
        }
    }
}

// --- END FILE ---

// File: UI/Components/ProfileCard/ProfileCardManager.cs
// Size: 16116 characters
// ---
// File: Assets/Code/UI/Components/ProfileCard/ProfileCardManager.cs
//
// Purpose: Manages the profile card UI component states and transitions across different game screens.
// Maintains the current profile display state and handles interactions with the card.
//
// Created: 2024-02-11

using UnityEngine;
using System.Collections;
using CyberPickle.Core.Management;
using CyberPickle.Core.Interfaces;
using CyberPickle.Core.Events;
using CyberPickle.Core.Services.Authentication;
using CyberPickle.Core.Services.Authentication.Data;
using CyberPickle.Core.GameFlow.States.ProfileCard;
using CyberPickle.Core.States;

namespace CyberPickle.UI.Components.ProfileCard
{
    public class ProfileCardManager : Manager<ProfileCardManager>, IInitializable
    {
        [Header("References")]
        [SerializeField] private GameObject minimalCardPrefab;
        [SerializeField] private GameObject expandedCardPrefab;
        [SerializeField] private Canvas mainCanvas;

        [Header("Animation Settings")]
        [SerializeField] private float transitionDuration = 0.3f;
        [SerializeField] private float cornerPadding = 20f;

        private ProfileCardState currentState = ProfileCardState.Hidden;
        private GameObject currentCardInstance;
        private ProfileData currentProfileData;
        private bool isTransitioning;
        private Vector2 minimizedPosition;
        private Vector2 expandedPosition;
        private bool isInitialized;

        public ProfileCardState CurrentState => currentState;
        public bool IsTransitioning => isTransitioning;
        public ProfileData CurrentProfileData => currentProfileData;

        public void Initialize()
        {
            if (isInitialized) return;

            ValidateReferences();
            SubscribeToEvents();
            CalculatePositions();

            isInitialized = true;
            Debug.Log("[ProfileCardManager] Initialized");
        }

        private void ValidateReferences()
        {
            if (minimalCardPrefab == null)
                Debug.LogError("[ProfileCardManager] Minimal card prefab is not assigned!");
            if (expandedCardPrefab == null)
                Debug.LogError("[ProfileCardManager] Expanded card prefab is not assigned!");
            if (mainCanvas == null)
                mainCanvas = FindObjectOfType<Canvas>();
            if (mainCanvas == null)
                Debug.LogError("[ProfileCardManager] No main canvas found in scene!");
        }

        private void SubscribeToEvents()
        {
            GameEvents.OnProfileCardClicked.AddListener(HandleCardClicked);
            GameEvents.OnProfileSelected.AddListener(HandleProfileSelected);
            GameEvents.OnGameStateChanged.AddListener(HandleGameStateChanged);
            GameEvents.OnProfileLoadRequested.AddListener(HandleProfileLoadRequested);
        }
        private void HandleProfileLoadRequested()
        {
            // When returning to profile selection, hide the card
            if (currentCardInstance != null)
            {
                Debug.Log("[ProfileCardManager] Profile load requested, hiding card");
                currentCardInstance.SetActive(false);
                currentState = ProfileCardState.Hidden;
                Debug.Log($"[ProfileCardManagerHandleprofileloadrequested] Card active hidden");
            }
        }


        private void CalculatePositions()
        {
            if (mainCanvas == null) return;

            RectTransform canvasRect = mainCanvas.GetComponent<RectTransform>();

            // Top-right corner positioning
            float padding = 20f;
            minimizedPosition = new Vector2(-padding, -padding);

            // Expanded position also in top-right
            float expandedPadding = 40f;
            expandedPosition = new Vector2(-expandedPadding, -expandedPadding);
        }

        public void SetProfile(ProfileData profileData)
        {
            if (profileData == null)
            {
                Debug.LogError("[ProfileCardManager] Attempted to set null profile data");
                return;
            }

            currentProfileData = profileData;
            UpdateCardDisplay();
        }

        private void UpdateCardDisplay()
        {
            if (currentProfileData == null || isTransitioning) return;

            switch (currentState)
            {
                case ProfileCardState.Minimized:
                    UpdateMinimalCard();
                    break;
                case ProfileCardState.Expanded:
                    UpdateExpandedCard();
                    break;
            }
        }

        private void UpdateMinimalCard()
        {
            if (currentCardInstance == null ||
                currentCardInstance.GetComponent<ProfileCardMinimal>() == null)
            {
                CreateMinimalCard();
            }

            var minimalCard = currentCardInstance.GetComponent<ProfileCardMinimal>();
            if (minimalCard != null)
            {
                minimalCard.UpdateDisplay(currentProfileData);
            }
        }

        private void UpdateExpandedCard()
        {
            if (currentCardInstance == null ||
                currentCardInstance.GetComponent<ProfileCardExpanded>() == null)
            {
                CreateExpandedCard();
            }

            var expandedCard = currentCardInstance.GetComponent<ProfileCardExpanded>();
            if (expandedCard != null)
            {
                expandedCard.UpdateDisplay(currentProfileData);
            }
        }

        private void CreateMinimalCard()
        {
            Debug.Log("[ProfileCardManager] Creating minimal card...");

            if (currentCardInstance != null)
            {
                Debug.Log("[ProfileCardManager] Destroying previous card instance");
                Destroy(currentCardInstance);
            }

            currentCardInstance = Instantiate(minimalCardPrefab, mainCanvas.transform);
            Debug.Log($"[ProfileCardManager] Minimal card created. Active state: {currentCardInstance.activeSelf}");

            var cardRect = currentCardInstance.GetComponent<RectTransform>();
            SetupCardTransform(cardRect, minimizedPosition);

            // Ensure the card is active
            currentCardInstance.SetActive(true);
            Debug.Log($"[ProfileCardManager] After setup. Active state: {currentCardInstance.activeSelf}");

            var minimalCard = currentCardInstance.GetComponent<ProfileCardMinimal>();
            if (minimalCard != null && currentProfileData != null)
            {
                minimalCard.UpdateDisplay(currentProfileData);
                Debug.Log($"[ProfileCardManager] Updated minimal card display for profile: {currentProfileData.DisplayName}");
            }
            else
            {
                Debug.LogError("[ProfileCardManager] Failed to initialize minimal card display");
            }
        }

        private void CreateExpandedCard()
        {
            if (currentCardInstance != null)
                Destroy(currentCardInstance);

            currentCardInstance = Instantiate(expandedCardPrefab, mainCanvas.transform);
            var cardRect = currentCardInstance.GetComponent<RectTransform>();

            // For expanded card, we want it centered
            cardRect.anchorMin = new Vector2(0.5f, 0.5f);
            cardRect.anchorMax = new Vector2(0.5f, 0.5f);
            cardRect.pivot = new Vector2(0.5f, 0.5f);
            cardRect.anchoredPosition = Vector2.zero;

            // Update the card display immediately
            var expandedCard = currentCardInstance.GetComponent<ProfileCardExpanded>();
            if (expandedCard != null && currentProfileData != null)
            {
                expandedCard.UpdateDisplay(currentProfileData);
            }
            else
            {
                Debug.LogError("[ProfileCardManager] Failed to initialize expanded card display");
            }
        }

        private void SetupCardTransform(RectTransform cardRect, Vector2 position)
        {
            if (cardRect == null) return;

            // Set the anchors to top-right corner
            cardRect.anchorMin = Vector2.one;
            cardRect.anchorMax = Vector2.one;
            cardRect.pivot = Vector2.one;

            // When using top-right anchoring, negative values move in from the corner
            float padding = 20f;
            cardRect.anchoredPosition = new Vector2(-padding, -padding);
        }

        public void TransitionToState(ProfileCardState targetState)
        {
            if (currentState == targetState || isTransitioning) return;
            StartCoroutine(TransitionRoutine(targetState));
        }

        private IEnumerator TransitionRoutine(ProfileCardState targetState)
        {
            isTransitioning = true;
            currentState = ProfileCardState.Transitioning;
            GameEvents.OnProfileCardStateChanged.Invoke(ProfileCardState.Transitioning);
            GameEvents.OnProfileCardInteractionEnabled.Invoke(false);

            Vector3 startPosition = currentCardInstance != null ?
                currentCardInstance.transform.position : Vector3.zero;

            // Create and set up the target state card
            GameObject targetCard = null;
            RectTransform targetRect = null;

            switch (targetState)
            {
                case ProfileCardState.Minimized:
                    targetCard = Instantiate(minimalCardPrefab, mainCanvas.transform);
                    targetRect = targetCard.GetComponent<RectTransform>();
                    SetupMinimizedCardPosition(targetRect);
                    var minimalCard = targetCard.GetComponent<ProfileCardMinimal>();
                    if (minimalCard != null && currentProfileData != null)
                    {
                        minimalCard.UpdateDisplay(currentProfileData);
                    }
                    break;

                case ProfileCardState.Expanded:
                    targetCard = Instantiate(expandedCardPrefab, mainCanvas.transform);
                    targetRect = targetCard.GetComponent<RectTransform>();
                    SetupExpandedCardPosition(targetRect);
                    var expandedCard = targetCard.GetComponent<ProfileCardExpanded>();
                    if (expandedCard != null && currentProfileData != null)
                    {
                        expandedCard.UpdateDisplay(currentProfileData);
                    }
                    break;
            }

            if (targetCard != null)
            {
                // Set initial position to match current card
                targetRect.position = startPosition;

                // Get target position based on state
                Vector2 targetPosition = targetState == ProfileCardState.Minimized ?
                    minimizedPosition : expandedPosition;

                // Perform transition
                float elapsedTime = 0f;
                while (elapsedTime < transitionDuration)
                {
                    elapsedTime += Time.deltaTime;
                    float t = elapsedTime / transitionDuration;
                    float smoothT = t * t * (3f - 2f * t); // Smooth interpolation

                    targetRect.anchoredPosition = Vector2.Lerp(
                        targetRect.anchoredPosition,
                        targetPosition,
                        smoothT
                    );

                    yield return null;
                }

                // Ensure final position
                targetRect.anchoredPosition = targetPosition;

                // Cleanup old card
                if (currentCardInstance != null && currentCardInstance != targetCard)
                {
                    Destroy(currentCardInstance);
                }
                currentCardInstance = targetCard;
            }

            currentState = targetState;
            isTransitioning = false;

            GameEvents.OnProfileCardStateChanged.Invoke(currentState);
            GameEvents.OnProfileCardTransitionComplete.Invoke();
            GameEvents.OnProfileCardInteractionEnabled.Invoke(true);
        }

        private void SetupMinimizedCardPosition(RectTransform cardRect)
        {
            // Set the anchors to top-right corner
            cardRect.anchorMin = Vector2.one;
            cardRect.anchorMax = Vector2.one;
            cardRect.pivot = Vector2.one;

            // Position from top-right corner with padding
            float padding = 20f;
            minimizedPosition = new Vector2(-padding, -padding);
        }

        private void SetupExpandedCardPosition(RectTransform cardRect)
        {
            // For expanded, keep it in the top-right but with more space
            cardRect.anchorMin = Vector2.one;
            cardRect.anchorMax = Vector2.one;
            cardRect.pivot = new Vector2(1f, 1f);

            // Calculate expanded position (still in top-right, but larger)
            float xPadding = 40f;  // Increased padding for expanded state
            float yPadding = 40f;
            expandedPosition = new Vector2(-xPadding, -yPadding);
        }
        private void HandleCardClicked()
        {
            if (isTransitioning) return;

            switch (currentState)
            {
                case ProfileCardState.Minimized:
                    TransitionToState(ProfileCardState.Expanded);
                    break;
                case ProfileCardState.Expanded:
                    TransitionToState(ProfileCardState.Minimized);
                    break;
            }
        }

        private void HandleProfileSelected(string profileId)
        {
            var profileManager = ProfileManager.Instance;
            if (profileManager != null)
            {
                var profile = profileManager.GetProfile(profileId);
                if (profile != null)
                {
                    SetProfile(profile);
                    if (currentState == ProfileCardState.Hidden)
                    {
                        TransitionToState(ProfileCardState.Minimized);
                    }
                }
            }
        }

        private void HandleGameStateChanged(GameState newState)
        {
            switch (newState)
            {
                case GameState.MainMenu:
                    if (currentProfileData != null && currentState == ProfileCardState.Hidden)
                    {
                        TransitionToState(ProfileCardState.Minimized);
                    }
                    break;

                case GameState.ProfileSelection:
                    // Hide the card completely
                    if (currentCardInstance != null)
                    {
                        Destroy(currentCardInstance);
                        currentCardInstance = null;
                    }
                    currentState = ProfileCardState.Hidden;
                    Debug.Log($"[ProfileCardManagerHandleGameStateChanged] Card active hidden");
                    break;
            }
        }

        protected override void OnManagerDestroyed()
        {
            GameEvents.OnProfileCardClicked.RemoveListener(HandleCardClicked);
            GameEvents.OnProfileSelected.RemoveListener(HandleProfileSelected);
            GameEvents.OnGameStateChanged.RemoveListener(HandleGameStateChanged);
            GameEvents.OnProfileLoadRequested.RemoveListener(HandleProfileLoadRequested);

            if (currentCardInstance != null)
                Destroy(currentCardInstance);
        }
    }
}

// --- END FILE ---

// File: UI/Components/ProfileCard/ProfileCardMinimal.cs
// Size: 3676 characters
// ---
// File: Assets/Code/UI/Components/ProfileCard/ProfileCardMinimal.cs
//
// Purpose: Handles the minimized corner view of the profile card showing essential information
// and handling basic interactions.
//
// Created: 2024-02-11

using UnityEngine;
using UnityEngine.UI;
using TMPro;
using CyberPickle.Core.Events;
using CyberPickle.Core.Services.Authentication.Data;

namespace CyberPickle.UI.Components.ProfileCard
{
    public class ProfileCardMinimal : MonoBehaviour
    {
        [Header("UI Elements")]
        [SerializeField] private TextMeshProUGUI playerNameText;
        [SerializeField] private TextMeshProUGUI levelText;
        [SerializeField] private Image avatarImage;
        [SerializeField] private Button cardButton;

        [Header("Animation")]
        [SerializeField] private CanvasGroup canvasGroup;
        [SerializeField] private float hoverScaleMultiplier = 1.05f;

        private Vector3 originalScale;
        private ProfileData currentProfile;

        private void Awake()
        {
            ValidateReferences();
            SetupInteractions();
        }

        private void OnEnable()
        {
            SubscribeToEvents();
        }

        private void OnDisable()
        {
            UnsubscribeFromEvents();
        }

        private void ValidateReferences()
        {
            if (playerNameText == null)
                Debug.LogError("[ProfileCardMinimal] Player name text is missing!");
            if (levelText == null)
                Debug.LogError("[ProfileCardMinimal] Level text is missing!");
            if (cardButton == null)
                cardButton = GetComponent<Button>();
            if (canvasGroup == null)
                canvasGroup = GetComponent<CanvasGroup>();

            originalScale = transform.localScale;
        }

        private void SetupInteractions()
        {
            if (cardButton != null)
            {
                cardButton.onClick.AddListener(() => GameEvents.OnProfileCardClicked.Invoke());
            }
        }

        private void SubscribeToEvents()
        {
            GameEvents.OnProfileCardInteractionEnabled.AddListener(SetInteractable);
        }

        private void UnsubscribeFromEvents()
        {
            GameEvents.OnProfileCardInteractionEnabled.RemoveListener(SetInteractable);
        }

        public void UpdateDisplay(ProfileData profileData)
        {
            if (profileData == null) return;

            currentProfile = profileData;

            if (playerNameText != null)
                playerNameText.text = profileData.DisplayName;

            if (levelText != null)
                levelText.text = $"Level {profileData.Level}";
        }

        public void SetInteractable(bool interactable)
        {
            if (cardButton != null)
                cardButton.interactable = interactable;

            if (canvasGroup != null)
            {
                canvasGroup.interactable = interactable;
                canvasGroup.blocksRaycasts = interactable;
            }
        }

        private void OnDestroy()
        {
            if (cardButton != null)
                cardButton.onClick.RemoveAllListeners();

            UnsubscribeFromEvents();
        }

        #region Mouse Interaction Handlers

        public void OnPointerEnter()
        {
            transform.localScale = originalScale * hoverScaleMultiplier;
        }

        public void OnPointerExit()
        {
            transform.localScale = originalScale;
        }

        #endregion
    }
}
// --- END FILE ---

// File: UI/Effects/Config/GlitchTextConfig.cs
// Size: 2377 characters
// ---
using UnityEngine;

namespace CyberPickle.UI.Effects.Config
{
    [CreateAssetMenu(fileName = "GlitchTextConfig", menuName = "CyberPickle/UI/Effects/GlitchTextConfig")]
    public class GlitchTextConfig : ScriptableObject
    {
        [Header("Glitch Effect Settings")]
        [Range(0.1f, 2f)]
        public float glitchInterval = 0.95f;

        [Range(0f, 1f)]
        public float glitchIntensity;

        [Range(0f, 1f)]
        public float glitchIntensityMax;

        [Range(0f, 1f)]
        public float glitchIntensityMin;

        [Range(0f, 0.5f)]
        public float glitchAmplitude = 0.1f;

        [Range(0f, 10f)]
        public float glitchSpeed = 5f;

        [Header("Random Character Effect Settings")]
        [Range(0.1f, 2f)]
        public float randomCharIntervalMin = 0.5f;

        [Range(0.1f, 2f)]
        public float randomCharIntervalMax = 2f;

        [Range(0.01f, 0.5f)]
        public float randomCharDisplayDurationMin = 0.05f;

        [Range(0.1f, 1f)]
        public float randomCharDisplayDurationMax = 0.3f;

        [Range(0f, 1f)]
        public float randomCharIntensity = 0.5f;

        [Header("Fade-In Effect Settings")]
        [Range(0.1f, 5f)]
        public float fadeDuration = 2f;

        [Header("Pulse Animation Settings")]
        [Range(1f, 1.5f)]
        public float pulseScale = 1.1f;

        [Range(0.1f, 5f)]
        public float pulseSpeed = 1f;

        [Header("Scanline Effect Settings")]
        [Range(0f, 1f)]
        public float scanlineIntensity = 1f;

        [Range(0f, 10f)]
        public float scanlineSpeed = 4.1f;

        [Range(100f, 2000f)]
        public float scanlineFrequency = 800f;

        [Header("Chromatic Aberration Settings")]
        [Range(0f, 0.01f)]
        public float chromAberration = 0.002f;

        [Header("Color Glitch Effect Settings")]
        [Range(0f, 1f)]
        public float colorGlitchIntensity = 0.5f;

        [Range(0.1f, 2f)]
        public float colorGlitchDuration = 0.5f;

        [Header("Dynamic Glitch Intensity Settings")]
        [Range(0.1f, 5f)]
        public float glitchIntensityDuration = 2f;

        [Range(5f, 15f)]
        public float glitchIntensityInterval = 10f;

        [Range(0f, 0.05f)]
        public float rgbSplitAmount = 0.01f;
    }
}
// --- END FILE ---

// File: UI/Screens/MainMenu/CreateProfileCardController.cs
// Size: 13469 characters
// ---
// File: Assets/Code/UI/Screens/MainMenu/CreateProfileCardController.cs
//
// Purpose: Controls the create profile card UI and transitions between card content and terminal interface.
// This controller focuses solely on UI handling and delegates profile creation to the ProfileManager.
//
// Created: 2024-01-13
// Updated: 2024-01-14

using UnityEngine;
using TMPro;
using UnityEngine.UI;
using System.Collections;
using System;
using System.Threading.Tasks;
using CyberPickle.Core.Services.Authentication;
using CyberPickle.Core.Services.Authentication.Flow.Commands;
using CyberPickle.Core.Events;
using CyberPickle.Core.Services.Authentication.Flow;
using CyberPickle.Core.States;

namespace CyberPickle.UI.Screens.MainMenu
{
    public class CreateProfileCardController : MonoBehaviour
    {
        [Header("Card Content")]
        [SerializeField] private GameObject cardContent;
        [SerializeField] private CanvasGroup cardContentCanvasGroup;

        [Header("Terminal Interface")]
        [SerializeField] private GameObject terminalInterface;
        [SerializeField] private CanvasGroup terminalCanvasGroup;
        [SerializeField] private TMP_InputField inputField;
        [SerializeField] private Button confirmButton;
        [SerializeField] private Button cancelButton;
        [SerializeField] private TextMeshProUGUI statusText;

        [Header("Validation")]
        [SerializeField] private GameObject validationSection;
        [SerializeField] private TextMeshProUGUI[] validationMessages;

        [Header("Animation Settings")]
        [SerializeField] private float transitionDuration = 0.5f;
        [SerializeField] private float statusMessageDuration = 3f;

        private bool isProcessing;
        private ProfileManager profileManager;
        private AuthenticationManager authManager;
        private AuthenticationFlowManager flowManager;
        private Coroutine statusMessageCoroutine;

        private void Awake()
        {
            
            profileManager = ProfileManager.Instance;
            authManager = AuthenticationManager.Instance;
            flowManager = AuthenticationFlowManager.Instance;

            InitializeComponents();
            SetInitialState();
            SubscribeToEvents();
            Debug.Log($"[CreateProfileCardController]: Awake");
        }

        public void ResetCard()
        {
            if (statusMessageCoroutine != null)
                StopCoroutine(statusMessageCoroutine);

            isProcessing = false;

            if (inputField != null)
            {
                inputField.text = string.Empty;
                inputField.interactable = true;
                
            }

            if (statusText != null)
                statusText.text = string.Empty;

            SetInitialState();
            Debug.Log("[CreateProfileCardController] Card reset completed");
        }

        private void InitializeComponents()
        {
            InitializeCanvasGroups();
            InitializeButtons();
            InitializeInputField();
        }

        private void InitializeCanvasGroups()
        {
            if (cardContentCanvasGroup == null && cardContent != null)
                cardContentCanvasGroup = cardContent.GetComponent<CanvasGroup>() ?? cardContent.gameObject.AddComponent<CanvasGroup>();

            if (terminalCanvasGroup == null && terminalInterface != null)
                terminalCanvasGroup = terminalInterface.GetComponent<CanvasGroup>() ?? terminalInterface.gameObject.AddComponent<CanvasGroup>();
        }

        private void InitializeButtons()
        {
            // Setup card button
            Button cardButton = cardContent.GetComponent<Button>() ?? cardContent.gameObject.AddComponent<Button>();
            cardButton.onClick.AddListener(StartProfileCreation);

            // Setup other buttons
            if (confirmButton != null)
                confirmButton.onClick.AddListener(HandleProfileConfirmationAsync);

            if (cancelButton != null)
                cancelButton.onClick.AddListener(CancelProfileCreation);
        }

        private void InitializeInputField()
        {
            if (inputField != null)
                inputField.onValueChanged.AddListener(ValidateInput);
        }

        private void SubscribeToEvents()
        {
            if (profileManager != null)
            {
                profileManager.SubscribeToNewProfileCreated(HandleProfileCreated);
            }
        }

        private void SetInitialState()
        {
            // Show card content, hide terminal
            SetCardContentActive(true, 1f);
            SetTerminalInterfaceActive(false, 0f);

            if (cardContent != null)
            {
                cardContent.SetActive(true);
                var button = cardContent.GetComponent<Button>();
                if (button != null)
                    button.interactable = true;
            }

            if (terminalInterface != null)
                terminalInterface.SetActive(false);

            if (validationSection != null)
                validationSection.SetActive(false);
        }

        public void StartProfileCreation()
        {
            if (isProcessing) return;
            isProcessing = true;

            if (terminalInterface != null)
            {
                terminalInterface.SetActive(true);
                if (terminalCanvasGroup != null)
                    terminalCanvasGroup.alpha = 0f;
            }

            StartCoroutine(TransitionToTerminal());
        }

        private async void HandleProfileConfirmationAsync()
        {
            if (string.IsNullOrWhiteSpace(inputField.text)) return;

            string displayName = inputField.text.Trim();
            SetInteractable(false);
            UpdateStatus("Creating profile...");

            try
            {
                var command = new CreateProfileCommand(profileManager, displayName);
                await flowManager.ExecuteCommand(command);

                // Success will be handled in HandleProfileCreated
            }
            catch (Exception ex)
            {
                SetInteractable(true);
                ShowTemporaryStatus($"Failed to create profile: {ex.Message}", isError: true);
                Debug.LogError($"[CreateProfileCard] Error creating profile: {ex.Message}");
            }
        }

        private void HandleProfileCreated(string profileId)
        {
            if (!gameObject.activeInHierarchy) return;

            ShowTemporaryStatus("Profile created successfully!");
            Debug.Log("CreateProfileControler : ProfileCreated");
            ResetCard();
            Debug.Log("CreateProfileControler : ProfileReset");
            // Transition to main menu state just like when selecting a profile
            GameEvents.OnGameStateChanged.Invoke(GameState.MainMenu);
        }

        private void ShowTemporaryStatus(string message, bool isError = false)
        {
            if (statusMessageCoroutine != null)
                StopCoroutine(statusMessageCoroutine);

            statusMessageCoroutine = StartCoroutine(ShowStatusMessageRoutine(message, isError));
        }

        private IEnumerator ShowStatusMessageRoutine(string message, bool isError)
        {
            UpdateStatus(message);
            if (statusText != null)
                statusText.color = isError ? Color.red : Color.white;

            yield return new WaitForSeconds(statusMessageDuration);

            if (statusText != null)
            {
                statusText.text = "";
                statusText.color = Color.white;
            }
        }

        private void ValidateInput(string input)
        {
            if (string.IsNullOrEmpty(input))
            {
                SetConfirmButtonState(false);
                return;
            }

            bool isValid = true;
            isValid &= input.Length >= 3 && input.Length <= 20;
            isValid &= System.Text.RegularExpressions.Regex.IsMatch(input, "^[a-zA-Z0-9_]+$");

            SetConfirmButtonState(isValid);
            UpdateValidationMessages(input);
        }

        private IEnumerator TransitionToTerminal()
        {
            Debug.Log("[CreateProfileCard] Starting transition to terminal interface");

            float elapsedTime = 0f;
            while (elapsedTime < transitionDuration)
            {
                elapsedTime += Time.deltaTime;
                float normalizedTime = elapsedTime / transitionDuration;

                SetCardContentActive(false, 1 - normalizedTime);
                SetTerminalInterfaceActive(true, normalizedTime);

                yield return null;
            }

            if (cardContent != null)
                cardContent.SetActive(false);

            FinalizeTransition();
            isProcessing = false;
        }

        private void FinalizeTransition()
        {
            SetCardContentActive(false);
            SetTerminalInterfaceActive(true);

            if (inputField != null)
            {
                inputField.text = string.Empty;
                inputField.Select();
                inputField.ActivateInputField();
            }

            if (validationSection != null)
                validationSection.SetActive(true);
        }


        private void CancelProfileCreation()
        {
            StartCoroutine(TransitionToCard());
        }

        private IEnumerator TransitionToCard()
        {
            float elapsedTime = 0f;
            while (elapsedTime < transitionDuration)
            {
                elapsedTime += Time.deltaTime;
                float normalizedTime = elapsedTime / transitionDuration;

                SetCardContentActive(true, normalizedTime);
                SetTerminalInterfaceActive(false, 1 - normalizedTime);

                yield return null;
            }

            SetInitialState();
            isProcessing = false;
        }

        private void SetCardContentActive(bool active, float alpha = 1f)
        {
            if (cardContentCanvasGroup == null) return;

            cardContentCanvasGroup.alpha = alpha;
            cardContentCanvasGroup.interactable = active;
            cardContentCanvasGroup.blocksRaycasts = active;
        }

        private void SetTerminalInterfaceActive(bool active, float alpha = 1f)
        {
            if (terminalCanvasGroup == null) return;

            terminalCanvasGroup.alpha = alpha;
            terminalCanvasGroup.interactable = active;
            terminalCanvasGroup.blocksRaycasts = active;
        }

        private void SetConfirmButtonState(bool enabled)
        {
            if (confirmButton != null)
                confirmButton.interactable = enabled;
        }

        private void SetInteractable(bool interactable)
        {
            if (inputField != null)
                inputField.interactable = interactable;
            if (confirmButton != null)
                confirmButton.interactable = interactable;
            if (cancelButton != null)
                cancelButton.interactable = interactable;
        }

        private void UpdateStatus(string message)
        {
            if (statusText != null)
                statusText.text = message;
        }

        private void UpdateValidationMessages(string input)
        {
            if (validationMessages == null || validationMessages.Length == 0)
                return;

            if (validationMessages.Length > 0)
                validationMessages[0].text = input.Length >= 3 && input.Length <= 20 ?
                    "Length: Valid" : "Length: Must be 3-20 characters";

            if (validationMessages.Length > 1)
                validationMessages[1].text = System.Text.RegularExpressions.Regex.IsMatch(input, "^[a-zA-Z0-9_]+$") ?
                    "Characters: Valid" : "Characters: Use only letters, numbers, and underscore";
        }

        private void OnDestroy()
        {
            if (statusMessageCoroutine != null)
                StopCoroutine(statusMessageCoroutine);

            UnsubscribeFromEvents();
            CleanupEventListeners();
        }

        private void UnsubscribeFromEvents()
        {
            if (profileManager != null)
            {
                profileManager.UnsubscribeFromNewProfileCreated(HandleProfileCreated);
            }
        }

        private void CleanupEventListeners()
        {
            if (cardContent != null)
            {
                var button = cardContent.GetComponent<Button>();
                if (button != null)
                    button.onClick.RemoveListener(StartProfileCreation);
            }

            if (confirmButton != null)
                confirmButton.onClick.RemoveListener(HandleProfileConfirmationAsync);

            if (cancelButton != null)
                cancelButton.onClick.RemoveListener(CancelProfileCreation);

            if (inputField != null)
                inputField.onValueChanged.RemoveListener(ValidateInput);
        }
    }
}

// --- END FILE ---

// File: UI/Screens/MainMenu/MainMenuButtonsController.cs
// Size: 9119 characters
// ---
using UnityEngine;
using UnityEngine.UI;
using TMPro;
using CyberPickle.Core.Events;
using CyberPickle.Core.States;
using System.Collections;
using CyberPickle.Core;
using CyberPickle.Core.Services.Authentication;

namespace CyberPickle.UI.Screens.MainMenu
{
    /// <summary>
    /// Controls the main menu buttons behavior and animations.
    /// Assumes it's attached to the MainMenuButtonsPanel GameObject.
    /// </summary>
    public class MainMenuButtonsController : MonoBehaviour
    {
        [Header("Button References")]
        [SerializeField] private Button startButton;
        [SerializeField] private Button optionsButton;
        [SerializeField] private Button quitButton;

        private CanvasGroup buttonsPanelCanvasGroup;
        private bool isTransitioning = false;

        private void Awake()
        {
            Debug.Log("[MainMenuButtonsController] Awake called");
            ValidateReferences();
            InitializeButtonStates();
        }

        private void OnEnable()
        {
            Debug.Log("[MainMenuButtonsController] OnEnable called - Current game state: " + GameManager.Instance.CurrentState);
            SubscribeToEvents();
            SetupButtonListeners();

            // Force check current state
            if (GameManager.Instance.CurrentState == GameState.MainMenu)
            {
                Debug.Log("[MainMenuButtonsController] Already in MainMenu state, forcing button activation");
                ForceActivateButtons();
            }
        }

        private void ValidateReferences()
        {
            buttonsPanelCanvasGroup = GetComponent<CanvasGroup>();
            if (buttonsPanelCanvasGroup == null)
            {
                buttonsPanelCanvasGroup = gameObject.AddComponent<CanvasGroup>();
            }

            Debug.Log($"[MainMenuButtonsController] Start Button: {(startButton != null ? "Found" : "Missing")}");
            Debug.Log($"[MainMenuButtonsController] Options Button: {(optionsButton != null ? "Found" : "Missing")}");
            Debug.Log($"[MainMenuButtonsController] Quit Button: {(quitButton != null ? "Found" : "Missing")}");

            if (buttonsPanelCanvasGroup != null)
            {
                Debug.Log($"[MainMenuButtonsController] CanvasGroup - interactable: {buttonsPanelCanvasGroup.interactable}, blocksRaycasts: {buttonsPanelCanvasGroup.blocksRaycasts}, alpha: {buttonsPanelCanvasGroup.alpha}");
            }
        }

        private void InitializeButtonStates()
        {
            Debug.Log("[MainMenuButtonsController] Initializing button states");
            SetButtonsInteractable(true); // Start with buttons interactable
            if (buttonsPanelCanvasGroup != null)
            {
                buttonsPanelCanvasGroup.alpha = 1f;
                buttonsPanelCanvasGroup.interactable = true;
                buttonsPanelCanvasGroup.blocksRaycasts = true;
                Debug.Log("[MainMenuButtonsController] CanvasGroup initialized and set to interactive");
            }
        }

        private void SubscribeToEvents()
        {
            GameEvents.OnGameStateChanged.AddListener(HandleGameStateChanged);
            GameEvents.OnUIAnimationCompleted.AddListener(HandleUIAnimationCompleted);
            GameEvents.OnProfileSelected.AddListener(HandleProfileSelected);
            Debug.Log("[MainMenuButtonsController] Events subscribed");
        }

        private void SetupButtonListeners()
        {
            if (startButton != null)
            {
                startButton.onClick.RemoveAllListeners();
                startButton.onClick.AddListener(OnStartClicked);
            }
            if (optionsButton != null)
            {
                optionsButton.onClick.RemoveAllListeners();
                optionsButton.onClick.AddListener(OnOptionsClicked);
            }
            if (quitButton != null)
            {
                quitButton.onClick.RemoveAllListeners();
                quitButton.onClick.AddListener(OnQuitClicked);
            }
            Debug.Log("[MainMenuButtonsController] Button listeners setup complete");
        }

        private void HandleGameStateChanged(GameState newState)
        {
            Debug.Log($"[MainMenuButtonsController] Game state changed to: {newState}");

            if (newState == GameState.MainMenu)
            {
                Debug.Log("[MainMenuButtonsController] Transitioning to MainMenu state");
                ForceActivateButtons();
            }
        }

        private void HandleUIAnimationCompleted()
        {
            Debug.Log("[MainMenuButtonsController] UI Animation completed");
            if (GameManager.Instance.CurrentState == GameState.MainMenu)
            {
                Debug.Log("[MainMenuButtonsController] UI Animation completed in MainMenu state - Activating buttons");
                ForceActivateButtons();
            }
        }

        private void HandleProfileSelected(string profileId)
        {
            Debug.Log($"[MainMenuButtonsController] Profile selected: {profileId}");
            if (!string.IsNullOrEmpty(profileId) && GameManager.Instance.CurrentState == GameState.MainMenu)
            {
                ForceActivateButtons();
            }
        }

        private void ForceActivateButtons()
        {
            Debug.Log("[MainMenuButtonsController] Force activating buttons");

            // Log button states before activation
            LogButtonStates("Before activation");

            if (buttonsPanelCanvasGroup != null)
            {
                buttonsPanelCanvasGroup.alpha = 1f;
                buttonsPanelCanvasGroup.interactable = true;
                buttonsPanelCanvasGroup.blocksRaycasts = true;
            }

            SetButtonsInteractable(true);

            // Log button states after activation
            LogButtonStates("After activation");
        }

        private void SetButtonsInteractable(bool interactable)
        {
            if (startButton != null)
            {
                startButton.interactable = interactable;
                Debug.Log($"[MainMenuButtonsController] Set Start button interactable: {interactable}");
            }
            if (optionsButton != null)
            {
                optionsButton.interactable = interactable;
            }
            if (quitButton != null)
            {
                quitButton.interactable = interactable;
            }

            if (buttonsPanelCanvasGroup != null)
            {
                buttonsPanelCanvasGroup.interactable = interactable;
                buttonsPanelCanvasGroup.blocksRaycasts = interactable;
                Debug.Log($"[MainMenuButtonsController] Set CanvasGroup - interactable: {interactable}, blocksRaycasts: {interactable}");
            }
        }

        private void LogButtonStates(string context)
        {
            Debug.Log($"[MainMenuButtonsController] Button States ({context}):");
            if (startButton != null)
                Debug.Log($"[MainMenuButtonsController] Start button interactable: {startButton.interactable}");
            if (optionsButton != null)
                Debug.Log($"[MainMenuButtonsController] Options button interactable: {optionsButton.interactable}");
            if (quitButton != null)
                Debug.Log($"[MainMenuButtonsController] Quit button interactable: {quitButton.interactable}");
            if (buttonsPanelCanvasGroup != null)
                Debug.Log($"[MainMenuButtonsController] CanvasGroup - interactable: {buttonsPanelCanvasGroup.interactable}, blocksRaycasts: {buttonsPanelCanvasGroup.blocksRaycasts}, alpha: {buttonsPanelCanvasGroup.alpha}");
        }

        private void OnStartClicked()
        {
            Debug.Log("[MainMenuButtonsController] Start button clicked");
            Debug.Log($"[MainMenu] Starting character select. Active profile: {ProfileManager.Instance.ActiveProfile?.ProfileId}");
            GameEvents.OnGameStateChanged.Invoke(GameState.CharacterSelect);            
        }

        private void OnOptionsClicked()
        {
            Debug.Log("[MainMenuButtonsController] Options button clicked");
            // TODO: Implement options menu
        }

        private void OnQuitClicked()
        {
            Debug.Log("[MainMenuButtonsController] Quit button clicked");
#if UNITY_EDITOR
            UnityEditor.EditorApplication.isPlaying = false;
#else
            Application.Quit();
#endif
        }

        private void OnDisable()
        {
            GameEvents.OnGameStateChanged.RemoveListener(HandleGameStateChanged);
            GameEvents.OnUIAnimationCompleted.RemoveListener(HandleUIAnimationCompleted);
            GameEvents.OnProfileSelected.RemoveListener(HandleProfileSelected);
            Debug.Log("[MainMenuButtonsController] Events unsubscribed");
        }
    }
}
// --- END FILE ---

// File: UI/Screens/MainMenu/MainMenuController.cs
// Size: 10126 characters
// ---
// File: Assets/Code/UI/Screens/MainMenu/MainMenuController.cs
// Namespace: CyberPickle.UI.Screens.MainMenu
//
// Purpose: Controls the main menu flow and transitions to authentication
// Handles the "Press Any Button" state and triggers authentication process via events

using UnityEngine;
using TMPro;
using CyberPickle.Core.Events;
using CyberPickle.Core.States;
using System.Collections;

namespace CyberPickle.UI.Screens.MainMenu
{
    public class MainMenuController : MonoBehaviour
    {
        [Header("UI References")]
        [SerializeField] private TextMeshProUGUI pressAnyButtonText;
        [SerializeField] private GameObject authPanel;
        [SerializeField] private GameObject profileSelectionPanel;
        [SerializeField] private GameObject mainMenuButtonsPanel;

        [Header("Animation")]
        [SerializeField] private float fadeOutDuration = 0.5f;
        [SerializeField] private float panelTransitionDuration = 0.3f;

        [Header("Title Animation")]
        [SerializeField] private RectTransform titleRectTransform;
        [SerializeField] private float titleAnimationDuration = 0.5f;
        [SerializeField] private Vector2 titleMainMenuPosition = new Vector2(0, 500);
        [SerializeField] private Vector2 titleProfileSelectPosition = new Vector2(0, 954);

        private bool isWaitingForInput = true;
        private CanvasGroup pressButtonCanvasGroup;

        private void Awake()
        {
            Debug.Log("[MainMenuController] Awake");
            pressButtonCanvasGroup = pressAnyButtonText.gameObject.GetComponent<CanvasGroup>();
            if (pressButtonCanvasGroup == null)
            {
                pressButtonCanvasGroup = pressAnyButtonText.gameObject.AddComponent<CanvasGroup>();
            }
        }

        private void Start()
        {
            InitializeUI();
            SubscribeToEvents();
            Debug.Log("[MainMenuController] Start completed");
        }

        private void InitializeUI()
        {
            Debug.Log("[MainMenuController] Initializing UI");
            pressButtonCanvasGroup.alpha = 1f;
            isWaitingForInput = true;

            // Hide all panels initially
            if (authPanel != null)
            {
                authPanel.SetActive(false);
                Debug.Log("[MainMenuController] Auth panel hidden");
            }
            if (profileSelectionPanel != null)
            {
                profileSelectionPanel.SetActive(false);
                Debug.Log("[MainMenuController] Profile selection panel hidden");
            }
            if (mainMenuButtonsPanel != null)
            {
                mainMenuButtonsPanel.SetActive(false);
                Debug.Log("[MainMenuController] Main menu buttons panel hidden");
            }
        }

        private void SubscribeToEvents()
        {
            GameEvents.OnProfileLoadRequested.AddListener(HandleProfileLoadRequested);
            GameEvents.OnGameStateChanged.AddListener(HandleGameStateChanged);
            Debug.Log("[MainMenuController] Events subscribed");
        }

        private void Update()
        {
            if (isWaitingForInput && (Input.anyKeyDown || Input.GetMouseButtonDown(0)))
            {
                HandleMainMenuInput();
            }
        }

        private void HandleMainMenuInput()
        {
            Debug.Log("[MainMenuController] Main menu input detected");
            isWaitingForInput = false;
            StartCoroutine(TransitionToAuth());
        }

        private IEnumerator TransitionToAuth()
        {
            Debug.Log("[MainMenuController] Starting transition to auth");
            GameEvents.OnUIAnimationStarted.Invoke();

            float elapsedTime = 0f;
            while (elapsedTime < fadeOutDuration)
            {
                elapsedTime += Time.deltaTime;
                pressButtonCanvasGroup.alpha = Mathf.Lerp(1f, 0f, elapsedTime / fadeOutDuration);
                yield return null;
            }

            pressAnyButtonText.gameObject.SetActive(false);
            if (authPanel != null)
            {
                authPanel.SetActive(true);
                Debug.Log("[MainMenuController] Auth panel activated");
            }

            Debug.Log("[MainMenuController] Auth transition complete");
            GameEvents.OnUIAnimationCompleted.Invoke();
            GameEvents.OnAuthenticationRequested.Invoke();
        }

        private void HandleProfileLoadRequested()
        {
            Debug.Log("[MainMenuController] Profile load requested");
            StartCoroutine(TransitionToPanels(authPanel, profileSelectionPanel));
            StartCoroutine(AnimateTitlePosition(titleProfileSelectPosition));
        }

        private void HandleGameStateChanged(GameState newState)
        {
            Debug.Log($"[MainMenuController] Game state changed to: {newState}");
            switch (newState)
            {
                case GameState.MainMenu:
                    StartCoroutine(AnimateTitlePosition(titleMainMenuPosition));
                    StartCoroutine(TransitionToPanels(profileSelectionPanel, mainMenuButtonsPanel));
                    break;

                case GameState.ProfileSelection:
                    StartCoroutine(AnimateTitlePosition(titleProfileSelectPosition));
                    StartCoroutine(TransitionToPanels(mainMenuButtonsPanel, profileSelectionPanel));
                    break;

                case GameState.CharacterSelect:
                case GameState.EquipmentSelect:
                case GameState.LevelSelect:
                    HideAllPanels();
                    break;
            }
        }

        private IEnumerator AnimateTitlePosition(Vector2 targetPosition)
        {
            if (titleRectTransform == null) yield break;

            Debug.Log($"[MainMenuController] Starting title animation to position: {targetPosition}");
            Vector2 startPosition = titleRectTransform.anchoredPosition;
            float elapsedTime = 0f;

            while (elapsedTime < titleAnimationDuration)
            {
                elapsedTime += Time.deltaTime;
                float progress = elapsedTime / titleAnimationDuration;
                float smoothProgress = Mathf.SmoothStep(0, 1, progress);
                titleRectTransform.anchoredPosition = Vector2.Lerp(startPosition, targetPosition, smoothProgress);
                yield return null;
            }

            titleRectTransform.anchoredPosition = targetPosition;
            Debug.Log("[MainMenuController] Title animation completed");
        }
        //ASDF
        private IEnumerator TransitionToPanels(GameObject panelToHide, GameObject panelToShow)
        {
            Debug.Log($"[MainMenuController] Starting panel transition - Hide: {panelToHide?.name}, Show: {panelToShow?.name}");
            GameEvents.OnUIAnimationStarted.Invoke();

            if (panelToHide != null)
            {
                CanvasGroup hideCanvasGroup = panelToHide.GetComponent<CanvasGroup>();
                if (hideCanvasGroup == null)
                {
                    hideCanvasGroup = panelToHide.AddComponent<CanvasGroup>();
                    Debug.Log($"[MainMenuController] Added CanvasGroup to {panelToHide.name}");
                }

                float elapsedTime = 0f;
                while (elapsedTime < panelTransitionDuration)
                {
                    elapsedTime += Time.deltaTime;
                    hideCanvasGroup.alpha = Mathf.Lerp(1f, 0f, elapsedTime / panelTransitionDuration);
                    yield return null;
                }

                panelToHide.SetActive(false);
                Debug.Log($"[MainMenuController] Panel {panelToHide.name} hidden");
            }

            if (panelToShow != null)
            {
                CanvasGroup showCanvasGroup = panelToShow.GetComponent<CanvasGroup>();
                if (showCanvasGroup == null)
                {
                    showCanvasGroup = panelToShow.AddComponent<CanvasGroup>();
                    Debug.Log($"[MainMenuController] Added CanvasGroup to {panelToShow.name}");
                }

                showCanvasGroup.alpha = 0f;
                panelToShow.SetActive(true);

                // Important: Set these immediately when showing the panel
                showCanvasGroup.interactable = true;
                showCanvasGroup.blocksRaycasts = true;

                float elapsedTime = 0f;
                while (elapsedTime < panelTransitionDuration)
                {
                    elapsedTime += Time.deltaTime;
                    showCanvasGroup.alpha = Mathf.Lerp(0f, 1f, elapsedTime / panelTransitionDuration);
                    yield return null;
                }

                showCanvasGroup.alpha = 1f;
                Debug.Log($"[MainMenuController] Panel {panelToShow.name} shown and activated");
            }

            GameEvents.OnUIAnimationCompleted.Invoke();
            Debug.Log("[MainMenuController] Panel transition complete");
        }

        private void HideAllPanels()
        {
            Debug.Log("[MainMenuController] Hiding all panels");
            if (pressAnyButtonText != null) pressAnyButtonText.gameObject.SetActive(false);
            if (authPanel != null) authPanel.SetActive(false);
            if (profileSelectionPanel != null) profileSelectionPanel.SetActive(false);
            if (mainMenuButtonsPanel != null) mainMenuButtonsPanel.SetActive(false);
        }

        private void OnDestroy()
        {
            GameEvents.OnProfileLoadRequested.RemoveListener(HandleProfileLoadRequested);
            GameEvents.OnGameStateChanged.RemoveListener(HandleGameStateChanged);
            StopAllCoroutines();
            Debug.Log("[MainMenuController] Cleaned up and destroyed");
        }
    }
}
// --- END FILE ---

// File: UI/Screens/MainMenu/ProfileCardController.cs
// Size: 4146 characters
// ---
// File: Assets/Code/UI/Screens/MainMenu/ProfileCardController.cs
//
// Purpose: Controls the profile card UI, displays profile information, and handles user interactions such as selection and deletion.
// This controller focuses solely on UI handling and delegates profile actions to the ProfileSelectionController.
//
// Created: 2024-01-15
// Updated: 2024-01-15
//
// Dependencies:
// - TMPro for TextMeshProUGUI components
// - UnityEngine.UI for UI elements like Button
// - CyberPickle.Core.Services.Authentication.Data for ProfileData
// - System for event handling

using UnityEngine;
using UnityEngine.UI;
using TMPro;
using System;
using CyberPickle.Core.Services.Authentication.Data;

namespace CyberPickle.UI.Screens.MainMenu
{
    public class ProfileCardController : MonoBehaviour
    {
        // Header Section
        [Header("Header Section")]
        [SerializeField] private TextMeshProUGUI profileNameText;
        [SerializeField] private TextMeshProUGUI lastLoginText;

        // Stats Grid
        [Header("Stats Grid")]
        [SerializeField] private TextMeshProUGUI levelValueText;
        [SerializeField] private TextMeshProUGUI timeValueText;
        [SerializeField] private TextMeshProUGUI scoreValueText;

        // Buttons
        [Header("Buttons")]
        [SerializeField] private Button selectButton;
        [SerializeField] private Button deleteButton;

        // Events
        public event Action<ProfileData> OnProfileSelected;
        public event Action<ProfileData> OnProfileDeleted;

        // Private variables
        private ProfileData profileData;

        // Public property to expose profileData
        public ProfileData ProfileData => profileData;

        /// <summary>
        /// Initializes the profile card with profile data.
        /// </summary>
        /// <param name="profile">The profile data to display.</param>
        public void Initialize(ProfileData profile)
        {
            profileData = profile;

            // Set header information
            profileNameText.text = profile.DisplayName;
            lastLoginText.text = FormatLastLoginTime(profile.LastLoginTime);

            // Set stats
            levelValueText.text = profile.Level.ToString();
            timeValueText.text = FormatPlayTime(profile.TotalPlayTime);
            scoreValueText.text = profile.HighestScore.ToString();

            // Set up button listeners
            selectButton.onClick.AddListener(OnSelectButtonClicked);
            deleteButton.onClick.AddListener(OnDeleteButtonClicked);
        }

        private void OnSelectButtonClicked()
        {
            OnProfileSelected?.Invoke(profileData);
        }

        private void OnDeleteButtonClicked()
        {
            OnProfileDeleted?.Invoke(profileData);
        }

        private string FormatLastLoginTime(DateTime lastLoginTime)
        {
            TimeSpan timeSinceLastLogin = DateTime.Now - lastLoginTime;
            if (timeSinceLastLogin.TotalDays >= 1)
                return $"{(int)timeSinceLastLogin.TotalDays} days ago";
            else if (timeSinceLastLogin.TotalHours >= 1)
                return $"{(int)timeSinceLastLogin.TotalHours} hours ago";
            else if (timeSinceLastLogin.TotalMinutes >= 1)
                return $"{(int)timeSinceLastLogin.TotalMinutes} minutes ago";
            else
                return "Just now";
        }

        private string FormatPlayTime(float playTimeInSeconds)
        {
            TimeSpan time = TimeSpan.FromSeconds(playTimeInSeconds);
            if (time.TotalHours >= 1)
                return $"{(int)time.TotalHours}h {time.Minutes}m";
            else if (time.Minutes >= 1)
                return $"{time.Minutes}m {time.Seconds}s";
            else
                return $"{time.Seconds}s";
        }

        private void OnDestroy()
        {
            selectButton.onClick.RemoveListener(OnSelectButtonClicked);
            deleteButton.onClick.RemoveListener(OnDeleteButtonClicked);
        }
    }
}


// --- END FILE ---

// File: UI/Screens/MainMenu/ProfileSelectionController.cs
// Size: 23662 characters
// ---
// File: Assets/Code/UI/Screens/MainMenu/ProfileSelectionController.cs
//
// Purpose: Handles the profile selection interface and transitions to main menu.
// Manages profile card creation, selection, and animation.
//
// Created: 2024-01-13
// Updated: 2024-01-15
//
// Dependencies:
// - CyberPickle.Core.Services.Authentication for authentication management
// - CyberPickle.Core.Services.Authentication for profile management
// - CyberPickle.Core.Events for game-wide event system

using UnityEngine;
using TMPro;
using UnityEngine.UI;
using System.Collections;
using System.Linq;
using System.Threading.Tasks;
using System.Collections.Generic;
using CyberPickle.Core.Services.Authentication;
using CyberPickle.Core.Services.Authentication.Data;
using CyberPickle.Core.Services.Authentication.Flow;
using CyberPickle.Core.Services.Authentication.Flow.Commands;
using CyberPickle.Core.Events;
using CyberPickle.Core.States;
using System;
using CyberPickle.UI.Components.ProfileCard;
using CyberPickle.Core.GameFlow.States.ProfileCard;

namespace CyberPickle.UI.Screens.MainMenu
{
    public class ProfileSelectionController : MonoBehaviour
    {
        [Header("Panel References")]
        [SerializeField] private GameObject profileSelectionPanel;
        [SerializeField] private Transform profilesContainer;
        [SerializeField] private GameObject profileCardPrefab;
        [SerializeField] private GameObject createProfileCardPrefab;

        [Header("Header Elements")]
        [SerializeField] private TextMeshProUGUI playerIdText;
        [SerializeField] private TextMeshProUGUI statusText;
        [SerializeField] private TextMeshProUGUI titleText;

        [Header("UI Elements")]
        [SerializeField] private Button backButton;
        [SerializeField] private CanvasGroup mainMenuButtonsGroup;
        [SerializeField] private CanvasGroup deleteConfirmationDialog;

        [Header("Animation Settings")]
        [SerializeField] private float transitionDuration = 0.5f;
        [SerializeField] private Vector3 cornerPosition = new Vector3(800f, 400f, 0f);
        [SerializeField] private Vector3 cornerScale = new Vector3(0.7f, 0.7f, 0.7f);
        [SerializeField] private float statusMessageDuration = 3f;

        [Header("Canvas References")]
        [SerializeField] private Canvas mainCanvas;
        

        private AuthenticationManager authManager;
        private ProfileManager profileManager;
        private ProfileCardManager profileCardManager;
        private AuthenticationFlowManager flowManager;
        private List<GameObject> instantiatedCards = new List<GameObject>();
        private CreateProfileCardController createProfileCard;
        private bool isTransitioning;
        private Coroutine statusMessageCoroutine;
        

        #region Initialization

        private void Awake()
        {
            if (deleteConfirmationDialog != null)
            {
                deleteConfirmationDialog.alpha = 0f;
                deleteConfirmationDialog.interactable = false;
                deleteConfirmationDialog.blocksRaycasts = false;
            }
            Debug.Log("[ProfileSelection] Awake called");
            InitializeManagers();
            ValidateReferences();
        }

        private void Start()
        {
            Debug.Log("[ProfileSelection] Start called");
            if (!ValidateManagers()) return;

            InitializeUI();
            SubscribeToEvents();
        }

        private void InitializeManagers()
        {
            authManager = AuthenticationManager.Instance;
            profileManager = ProfileManager.Instance;
            flowManager = AuthenticationFlowManager.Instance;
            profileCardManager = ProfileCardManager.Instance;
        }

        private bool ValidateManagers()
        {
            if (authManager == null || profileManager == null || flowManager == null || profileCardManager == null)
            {
                Debug.LogError("[ProfileSelection] Required managers are null!");
                return false;
            }
            return true;
        }

        private void ValidateReferences()
        {
            if (profilesContainer == null)
                Debug.LogError("[ProfileSelection] profilesContainer is null!");
            if (profileCardPrefab == null)
                Debug.LogError("[ProfileSelection] profileCardPrefab is null!");
            if (createProfileCardPrefab == null)
                Debug.LogError("[ProfileSelection] createProfileCardPrefab is null!");
        }

        private void InitializeUI()
        {
            if (!ValidateManagers()) return;

            Debug.Log("[ProfileSelection] Initializing UI");

            // Only handle the profile-specific UI elements
            mainMenuButtonsGroup.alpha = 0f;
            mainMenuButtonsGroup.interactable = false;

            UpdateHeaderInfo();
            backButton.onClick.AddListener(HandleBackButton);

            // Initialize cards container
            InitializeCreateProfileCard();
        }

        private void InitializeCreateProfileCard()
        {
            GameObject createCardObject = Instantiate(createProfileCardPrefab, profilesContainer);
            createProfileCard = createCardObject.GetComponent<CreateProfileCardController>();
        }

        #endregion

        #region Event Handling

        private void SubscribeToEvents()
        {
            Debug.Log("[ProfileSelectionController] Subscribing to events");

            if (authManager != null)
            {
                Debug.Log("[ProfileSelectionController] Subscribing to AuthManager events");
                authManager.SubscribeToAuthenticationStateChanged(HandleAuthStateChanged);
                authManager.SubscribeToAuthenticationCompleted(HandleAuthenticationCompleted);
            }

            if (profileManager != null)
            {
                Debug.Log("[ProfileSelectionController] Subscribing to ProfileManager events");
                profileManager.SubscribeToNewProfileCreated(HandleProfileCreated);
                profileManager.SubscribeToProfileSwitched(HandleProfileSwitched);
            }

            GameEvents.OnProfileLoadRequested.AddListener(HandleProfileLoadRequested);
            GameEvents.OnProfileNavigationInput.AddListener(HandleProfileNavigation);
        }

        private void UnsubscribeFromEvents()
        {
            if (profileManager != null)
            {
                profileManager.UnsubscribeFromNewProfileCreated(HandleProfileCreated);
                profileManager.UnsubscribeFromProfileSwitched(HandleProfileSwitched);
            }

            if (authManager != null)
            {
                authManager.UnsubscribeFromAuthenticationStateChanged(HandleAuthStateChanged);
                authManager.UnsubscribeFromAuthenticationCompleted(HandleAuthenticationCompleted);
            }

            GameEvents.OnProfileLoadRequested.RemoveListener(HandleProfileLoadRequested);
            GameEvents.OnProfileNavigationInput.RemoveListener(HandleProfileNavigation);
        }

        private void HandleAuthStateChanged(AuthenticationState state)
        {
            Debug.Log($"[ProfileSelectionController] Auth state changed to: {state}");

            if (state == AuthenticationState.Authenticated)
            {
                Debug.Log("[ProfileSelectionController] Authentication completed, waiting for UI readiness");
                GameEvents.OnUIAnimationCompleted.AddListener(OnPanelTransitionComplete);
            }
        }

        private void OnPanelTransitionComplete()
        {
            GameEvents.OnUIAnimationCompleted.RemoveListener(OnPanelTransitionComplete);

            // Only load profiles if our container is active
            if (profilesContainer != null && profilesContainer.gameObject.activeInHierarchy)
            {
                Debug.Log("[ProfileSelection] Panel transition complete, loading profiles");
                LoadProfiles();
            }
        }
       


        private IEnumerator ExecuteCommandCoroutine(IAuthCommand command)
        {
            Task commandTask = flowManager.ExecuteCommand(command);

            while (!commandTask.IsCompleted)
            {
                yield return null;
            }

            if (commandTask.IsFaulted)
            {
                Debug.LogError($"[ProfileSelection] Failed to load profiles: {commandTask.Exception?.InnerException?.Message}");
                ShowTemporaryStatus("Failed to load profiles", true);
                yield break;
            }

            // After profiles are loaded successfully, update UI
            UpdateUIState();
        }
        private void HandleAuthenticationCompleted(string playerId)
        {
            Debug.Log($"[ProfileSelection] Authentication completed for player: {playerId}");
            // Remove this LoadProfiles() call since HandleAuthStateChanged will handle it
        }

        private void HandleProfileCreated(string profileId)
        {
            if (!gameObject.activeInHierarchy) return;

            Debug.Log($"[ProfileSelection] HandleProfileCreated called for profile: {profileId}");

            // Get the new profile and set it as active
            var profiles = profileManager.GetAllProfiles();
            var newProfile = profiles.FirstOrDefault(p => p.ProfileId == profileId);
            if (newProfile != null)
            {
                profileCardManager.SetProfile(newProfile);
                profileCardManager.TransitionToState(ProfileCardState.Minimized);
            }

            // Transition to main menu
            GameEvents.OnGameStateChanged.Invoke(GameState.MainMenu);
        }
        private void HandleProfileLoadRequested()
        {
            Debug.Log("[ProfileSelection] Profile load requested, reloading state");
            ReloadProfileSelectionState();
        }
        private void HandleProfileSwitched(string profileId)
        {
            if (isTransitioning) return;
            UpdateUIState();
        }

        #endregion

        #region Profile Management
        private void ReloadProfileSelectionState()
        {
            Debug.Log("[ProfileSelectionController] Reloading profile selection state");

            // Clear existing cards
            ClearExistingProfiles();

            // Reset create profile card
            if (createProfileCard != null)
            {
                createProfileCard.ResetCard();
            }

            // Force reload all profiles from ProfileManager
            var allProfiles = profileManager.GetAllProfiles();
            Debug.Log($"[ProfileSelectionController] Found {allProfiles.Count} profiles to load");

            foreach (var profile in allProfiles)
            {
                CreateProfileCard(profile);
            }
        }

        private void LoadProfiles()
        {
            if (isTransitioning)
            {
                Debug.LogWarning("[ProfileSelectionController] Cannot load profiles - transitioning");
                return;
            }

            Debug.Log("[ProfileSelectionController] Starting LoadProfiles");
            ClearExistingProfiles();

            var profiles = profileManager.GetAllProfiles();
            if (profiles == null)
            {
                Debug.LogError("[ProfileSelectionController] GetAllProfiles returned null!");
                return;
            }

            Debug.Log($"[ProfileSelectionController] Found {profiles.Count} profiles");

            var sortedProfiles = profiles
                .OrderBy(p => p.ProfileId == "default" ? 0 : 1)
                .ThenBy(p => p.CreatedAt)
                .ToList();

            foreach (var profile in sortedProfiles)
            {
                CreateProfileCard(profile);
            }
        }



        private async void HandleProfileSelection(ProfileData profile)
        {
            if (isTransitioning) return;

            try
            {
                isTransitioning = true;
                var command = new SelectProfileCommand(profileManager, profile.ProfileId);
                await flowManager.ExecuteCommand(command);
                profileCardManager.SetProfile(profile);
                profileCardManager.TransitionToState(ProfileCardState.Minimized);

                // Let's let the MainMenuController handle the state change
                GameEvents.OnGameStateChanged.Invoke(GameState.MainMenu);
            }
            catch (Exception ex)
            {
                Debug.LogError($"[ProfileSelection] Error selecting profile: {ex.Message}");
                ShowTemporaryStatus("Failed to select profile", true);
            }
            finally
            {
                isTransitioning = false;
            }
        }

        private async void HandleProfileDeletion(ProfileData profile)
        {
            if (profile == null) return;

            // Show confirmation dialog first
            var confirmed = await ShowDeleteConfirmationDialog(profile.DisplayName);
            if (!confirmed) return;

            try
            {
                // Execute the delete command
                var command = new DeleteProfileCommand(profileManager, profile.ProfileId);
                await flowManager.ExecuteCommand(command);

                // Just refresh the profiles list
                LoadProfiles();
                ShowTemporaryStatus("Profile deleted successfully");
            }
            catch (Exception ex)
            {
                Debug.LogError($"[ProfileSelection] Error deleting profile: {ex.Message}");
                ShowTemporaryStatus("Failed to delete profile", true);
            }
        }

        private async Task<bool> ShowDeleteConfirmationDialog(string profileName)
        {
            // Create a TaskCompletionSource to handle the async dialog result
            var tcs = new TaskCompletionSource<bool>();

            // Find the dialog in your scene
            var dialogPanel = GameObject.Find("DeleteConfirmationDialog")?.GetComponent<CanvasGroup>();
            if (dialogPanel == null)
            {
                Debug.LogError("[ProfileSelection] DeleteConfirmationDialog not found in scene!");
                return false;
            }

            // Get button references from the dialog panel
            var confirmButton = dialogPanel.GetComponentInChildren<Button>(true);
            var cancelButton = dialogPanel.GetComponentsInChildren<Button>(true)[1];
            var messageText = dialogPanel.GetComponentInChildren<TextMeshProUGUI>(true);

            // Show dialog
            dialogPanel.alpha = 1f;
            dialogPanel.interactable = true;
            dialogPanel.blocksRaycasts = true;

            // Set message
            messageText.text = $"Are you sure you want to delete profile {profileName}?";

            // Setup button listeners
            void OnConfirm()
            {
                tcs.SetResult(true);
                CleanupDialog();
            }

            void OnCancel()
            {
                tcs.SetResult(false);
                CleanupDialog();
            }

            void CleanupDialog()
            {
                // Remove listeners
                confirmButton.onClick.RemoveListener(OnConfirm);
                cancelButton.onClick.RemoveListener(OnCancel);

                // Hide dialog
                dialogPanel.alpha = 0f;
                dialogPanel.interactable = false;
                dialogPanel.blocksRaycasts = false;
            }

            // Add listeners
            confirmButton.onClick.AddListener(OnConfirm);
            cancelButton.onClick.AddListener(OnCancel);

            // Return the task
            return await tcs.Task;
        }
        private void ClearExistingProfiles()
        {
            foreach (var card in instantiatedCards.Where(card => card != null))
            {
                var cardController = card.GetComponent<ProfileCardController>();
                if (cardController != null)
                {
                    cardController.OnProfileSelected -= HandleProfileSelection;
                    cardController.OnProfileDeleted -= HandleProfileDeletion;
                }
                Destroy(card);
            }

            instantiatedCards.Clear();
            Debug.Log("[ProfileSelection] Cleared existing profile cards");
        }

        #endregion

        #region Profile Card Management

        private void CreateProfileCard(ProfileData profile)
        {
            if (profile == null || !gameObject.activeInHierarchy) return;

            Debug.Log($"[ProfileSelection] Creating profile card for {profile.DisplayName}");

            GameObject cardObject = Instantiate(profileCardPrefab, profilesContainer);
            if (cardObject == null)
            {
                Debug.LogError("[ProfileSelection] Failed to instantiate profile card prefab");
                return;
            }

            cardObject.name = $"ProfileCard_{profile.DisplayName}";

            var cardController = cardObject.GetComponent<ProfileCardController>();
            if (cardController != null)
            {
                cardController.Initialize(profile);
                cardController.OnProfileSelected += HandleProfileSelection;
                cardController.OnProfileDeleted += HandleProfileDeletion;
            }
            else
            {
                Debug.LogError("[ProfileSelection] ProfileCardController component not found on prefab");
            }

            instantiatedCards.Add(cardObject);
        }

        #endregion

        #region UI Updates

        private void UpdateHeaderInfo()
        {
            if (playerIdText != null)
                playerIdText.text = $"ID: #{authManager.CurrentPlayerId}";

            if (statusText != null)
                statusText.text = authManager.IsSignedIn ? "SYSTEM STATUS: ONLINE" : "SYSTEM STATUS: OFFLINE";
        }

        private void UpdateUIState()
        {
            if (isTransitioning) return;

            UpdateHeaderInfo();

            if (createProfileCard != null)
                createProfileCard.gameObject.SetActive(authManager.IsSignedIn);
        }

        private void ShowTemporaryStatus(string message, bool isError = false)
        {
            if (statusMessageCoroutine != null)
                StopCoroutine(statusMessageCoroutine);

            statusMessageCoroutine = StartCoroutine(ShowStatusMessageRoutine(message, isError));
        }

        private IEnumerator ShowStatusMessageRoutine(string message, bool isError)
        {
            if (statusText != null)
            {
                statusText.text = message;
                statusText.color = isError ? Color.red : Color.white;
            }

            yield return new WaitForSeconds(statusMessageDuration);

            if (statusText != null)
            {
                statusText.text = authManager.IsSignedIn ? "SYSTEM STATUS: ONLINE" : "SYSTEM STATUS: OFFLINE";
                statusText.color = Color.white;
            }
        }

        private void HandleBackButton()
        {
            if (isTransitioning) return;

            // If there's an active profile, ensure the card is hidden
            if (profileCardManager.CurrentState != ProfileCardState.Hidden)
            {
                profileCardManager.TransitionToState(ProfileCardState.Hidden);
                Debug.Log($"[ProfileCardManagerHandlebackbutton] Card hidden");
            }

            GameEvents.OnProfileLoadRequested.Invoke();
        }

        private void HandleProfileNavigation(float direction)
        {
            if (instantiatedCards.Count == 0) return;

            int currentIndex = -1;

            // Find currently selected card or first card if none selected
            for (int i = 0; i < instantiatedCards.Count; i++)
            {
                var cardController = instantiatedCards[i].GetComponent<ProfileCardController>();
                if (cardController?.ProfileData == profileManager.ActiveProfile)
                {
                    currentIndex = i;
                    break;
                }
            }

            if (currentIndex == -1)
                currentIndex = 0;

            // Calculate new index
            int newIndex = currentIndex;
            if (direction > 0) // Down arrow
            {
                newIndex = Mathf.Min(instantiatedCards.Count - 1, currentIndex + 1);
            }
            else if (direction < 0) // Up arrow
            {
                newIndex = Mathf.Max(0, currentIndex - 1);
            }

            if (newIndex != currentIndex)
            {
                var cardController = instantiatedCards[newIndex].GetComponent<ProfileCardController>();
                if (cardController != null)
                {
                    // Scroll to the selected card
                    ScrollToCard(instantiatedCards[newIndex]);
                }
            }
        }
        private void ScrollToCard(GameObject cardObject)
        {
            if (cardObject == null) return;

            // Get the ScrollRect component
            var scrollRect = profilesContainer.GetComponentInParent<ScrollRect>();
            if (scrollRect == null) return;

            // Get the card's RectTransform
            var cardRect = cardObject.GetComponent<RectTransform>();
            if (cardRect == null) return;

            // Calculate the card's position in the scroll view
            var contentPanel = scrollRect.content;
            var viewportHeight = scrollRect.viewport.rect.height;
            var contentHeight = contentPanel.rect.height;

            // Convert the card's position to normalized coordinates (0-1)
            var cardPosition = contentPanel.InverseTransformPoint(cardRect.position);
            var normalizedPosition = (cardPosition.y + contentHeight / 2) / contentHeight;

            // Adjust scroll position to show the card
            scrollRect.verticalNormalizedPosition = 1 - normalizedPosition;
        }
        #endregion


        #region Cleanup

        private void OnDestroy()
        {
            if (statusMessageCoroutine != null)
                StopCoroutine(statusMessageCoroutine);

            UnsubscribeFromEvents();
            backButton.onClick.RemoveListener(HandleBackButton);

            foreach (var card in instantiatedCards)
            {
                if (card != null)
                {
                    var cardController = card.GetComponent<ProfileCardController>();
                    if (cardController != null)
                    {
                        cardController.OnProfileSelected -= HandleProfileSelection;
                        cardController.OnProfileDeleted -= HandleProfileDeletion;
                    }
                }
            }
        }

        #endregion
    }
}


// --- END FILE ---

// File: UI/Windows/Auth/AuthPanelController.cs
// Size: 7962 characters
// ---
// File: Assets/Code/UI/Windows/Auth/AuthPanelController.cs
// Namespace: CyberPickle.UI.Windows.Auth
//
// Purpose: Controls the authentication panel UI and process.
// Responds to authentication events and manages the terminal display.
//
// Created: 2024-01-13
// Updated: 2024-01-14

using UnityEngine;
using TMPro;
using UnityEngine.UI;
using CyberPickle.Core.Services.Authentication;
using CyberPickle.Core.Events;
using System.Collections;

namespace CyberPickle.UI.Windows.Auth
{
    public class AuthPanelController : MonoBehaviour
    {
        [Header("Panel References")]
        [SerializeField] private GameObject terminalWindowPanel;
        [SerializeField] private TextMeshProUGUI debugConsole;
        [SerializeField] private TextMeshProUGUI resultText;
        [SerializeField] private TextMeshProUGUI statusText;

        [Header("Loading Indicator")]
        [SerializeField] private Slider loadingSlider;
        [SerializeField] private float loadingAnimationSpeed = 1f;

        [Header("Animation Settings")]
        [SerializeField] private float typewriterSpeed = 0.05f;
        [SerializeField] private float messageDisplayDuration = 2f;
        [SerializeField] private float panelFadeInDuration = 0.5f;

        private AuthenticationManager authManager;
        private ProfileManager profileManager;
        private bool isInitialized;
        private Coroutine currentTypewriterCoroutine;
        private Coroutine loadingCoroutine;
        private CanvasGroup panelCanvasGroup;

        private void Awake()
        {
            authManager = AuthenticationManager.Instance;
            profileManager = ProfileManager.Instance;
            SetupCanvasGroup();
        }

        private void OnEnable()
        {
            SubscribeToEvents();
        }

        private void OnDisable()
        {
            UnsubscribeFromEvents();
        }

        private void SetupCanvasGroup()
        {
            panelCanvasGroup = GetComponent<CanvasGroup>();
            if (panelCanvasGroup == null)
            {
                panelCanvasGroup = gameObject.AddComponent<CanvasGroup>();
            }
            panelCanvasGroup.alpha = 0f;
        }

        private void SubscribeToEvents()
        {
            GameEvents.OnAuthenticationRequested.AddListener(InitializeAuthentication);

            if (authManager != null)
            {
                authManager.SubscribeToAuthenticationCompleted(OnAuthenticationCompleted);
                authManager.SubscribeToAuthenticationFailed(OnAuthenticationFailed);
            }

            if (profileManager != null)
            {
                profileManager.SubscribeToProfileSwitched(OnProfileSwitched);
            }
        }

        private void UnsubscribeFromEvents()
        {
            GameEvents.OnAuthenticationRequested.RemoveListener(InitializeAuthentication);

            if (authManager != null)
            {
                authManager.UnsubscribeFromAuthenticationCompleted(OnAuthenticationCompleted);
                authManager.UnsubscribeFromAuthenticationFailed(OnAuthenticationFailed);
            }

            if (profileManager != null)
            {
                profileManager.UnsubscribeFromProfileSwitched(OnProfileSwitched);
            }
        }

        public void InitializeAuthentication()
        {
            if (!isInitialized)
            {
                StartCoroutine(InitializationSequence());
                isInitialized = true;
            }
        }

        private IEnumerator InitializationSequence()
        {
            // Reset state
            isInitialized = false;
            ClearConsole();
            loadingSlider.value = 0f;

            // Fade in the panel
            yield return StartCoroutine(FadeInPanel());

            // Initial boot sequence
            yield return StartCoroutine(TypewriterEffect(debugConsole, "> Initializing terminal..."));
            yield return new WaitForSeconds(messageDisplayDuration);

            yield return StartCoroutine(TypewriterEffect(debugConsole, "> Checking authentication service..."));

            // Start loading animation
            if (loadingCoroutine != null) StopCoroutine(loadingCoroutine);
            loadingCoroutine = StartCoroutine(AnimateLoading());

            // Begin authentication
            StartAuthentication();
        }

        private IEnumerator FadeInPanel()
        {
            float elapsedTime = 0f;
            while (elapsedTime < panelFadeInDuration)
            {
                elapsedTime += Time.deltaTime;
                panelCanvasGroup.alpha = Mathf.Lerp(0f, 1f, elapsedTime / panelFadeInDuration);
                yield return null;
            }
            panelCanvasGroup.alpha = 1f;
        }

        private void StartAuthentication()
        {
            UpdateStatus("Authenticating...");
            _ = authManager.SignInAnonymouslyAsync();
        }

        private IEnumerator AnimateLoading()
        {
            while (true)
            {
                loadingSlider.value = Mathf.PingPong(Time.time * loadingAnimationSpeed, 1f);
                yield return null;
            }
        }

        private IEnumerator TypewriterEffect(TextMeshProUGUI textComponent, string message)
        {
            if (currentTypewriterCoroutine != null)
            {
                StopCoroutine(currentTypewriterCoroutine);
            }

            // Store the existing text
            string existingText = textComponent.text;

            // Add a new line if there's existing text
            if (!string.IsNullOrEmpty(existingText) && !existingText.EndsWith("\n"))
            {
                existingText += "\n";
            }

            // Build the new line character by character
            string currentMessage = "";
            foreach (char c in message)
            {
                currentMessage += c;
                textComponent.text = existingText + currentMessage;
                yield return new WaitForSeconds(typewriterSpeed);
            }

            // Add a new line at the end for the next message
            textComponent.text += "\n";
        }

        #region Event Handlers

        private void OnAuthenticationCompleted(string playerId)
        {
            if (loadingCoroutine != null) StopCoroutine(loadingCoroutine);
            loadingSlider.value = 1f;

            StartCoroutine(TypewriterEffect(debugConsole, $"> Authentication successful. PlayerID: {playerId}"));
            UpdateStatus("Authentication Complete");

            // Trigger profile selection panel or next step
            GameEvents.OnProfileLoadRequested.Invoke();
        }

        private void OnAuthenticationFailed(string error)
        {
            if (loadingCoroutine != null) StopCoroutine(loadingCoroutine);
            loadingSlider.value = 0f;

            StartCoroutine(TypewriterEffect(debugConsole, $"> Authentication failed: {error}"));
            UpdateStatus("Authentication Failed");
        }

        private void OnProfileSwitched(string profileId)
        {
            StartCoroutine(TypewriterEffect(debugConsole, $"> Profile switched to: {profileId}"));
        }

        #endregion

        private void UpdateStatus(string status)
        {
            if (statusText != null)
                statusText.text = $"> {status}";
        }

        private void ClearConsole()
        {
            if (debugConsole != null) debugConsole.text = "";
            if (statusText != null) statusText.text = "";
            if (resultText != null) resultText.text = "";
        }

        private void OnDestroy()
        {
            StopAllCoroutines();
        }
    }
}

// --- END FILE ---

// File: Core/GameFlow/States/ProfileCard/ProfileCardState.cs
// Size: 997 characters
// ---
// File: Assets/Code/Core/GameFlow/States/ProfileCard/ProfileCardState.cs
//
// Purpose: Defines the possible states of the profile card UI component
// Used to manage the card's visibility and interaction states across different game screens
//
// Created: 2024-02-11

namespace CyberPickle.Core.GameFlow.States.ProfileCard
{
    /// <summary>
    /// Represents the different states of the profile card UI component
    /// </summary>
    public enum ProfileCardState
    {
        /// <summary>
        /// Card is not visible
        /// </summary>
        Hidden,

        /// <summary>
        /// Card is visible in minimized form (corner display)
        /// </summary>
        Minimized,

        /// <summary>
        /// Card is visible in expanded form showing full details
        /// </summary>
        Expanded,

        /// <summary>
        /// Card is currently transitioning between states
        /// </summary>
        Transitioning
    }
}

// --- END FILE ---

// File: Core/Services/Authentication/Data/AuthenticationEvents.cs
// Size: 1198 characters
// ---
using System;

namespace CyberPickle.Core.Services.Authentication
{
    public class AuthenticationEvents
    {
        // Authentication state events
        public event Action<AuthenticationState> OnAuthenticationStateChanged;
        public event Action<string> OnAuthenticationCompleted;
        public event Action<string> OnAuthenticationFailed;

        // Session events
        public event Action<string> OnSessionTokenFound;
        public event Action OnSessionExpired;
        public event Action OnSignedOut;

        // Internal methods to invoke events
        internal void InvokeAuthenticationStateChanged(AuthenticationState state) => OnAuthenticationStateChanged?.Invoke(state);
        internal void InvokeAuthenticationCompleted(string playerId) => OnAuthenticationCompleted?.Invoke(playerId);
        internal void InvokeAuthenticationFailed(string error) => OnAuthenticationFailed?.Invoke(error);
        internal void InvokeSessionTokenFound(string token) => OnSessionTokenFound?.Invoke(token);
        internal void InvokeSessionExpired() => OnSessionExpired?.Invoke();
        internal void InvokeSignedOut() => OnSignedOut?.Invoke();
    }
}


// --- END FILE ---

// File: Core/Services/Authentication/Data/AuthenticationState.cs
// Size: 331 characters
// ---
using UnityEngine;

namespace CyberPickle.Core.Services.Authentication
{
    public enum AuthenticationState
    {
        NotInitialized,
        NotAuthenticated,
        AuthenticationInProgress,
        Authenticated,
        AuthenticationFailed,
        ProfileSwitchInProgress,
        SessionExpired
    }
}

// --- END FILE ---

// File: Core/Services/Authentication/Data/CharacterProgressionData_Extension.cs
// Size: 8367 characters
// ---
// File: Assets/Code/Core/Services/Authentication/Data/CharacterProgressionData_Extension.cs
//
// Purpose: Extension methods for the CharacterProgressionData class to support equipment management.
// Adds methods for unequipping items and handling equipment slot management.
//
// Created: 2025-02-25
// Updated: 2025-02-25

using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace CyberPickle.Core.Services.Authentication.Data
{
    /// <summary>
    /// Extension methods for CharacterProgressionData
    /// </summary>
    public static class CharacterProgressionDataExtensions
    {
        /// <summary>
        /// Unequips an item from a character
        /// </summary>
        /// <param name="characterData">The character progression data</param>
        /// <param name="equipmentId">ID of the equipment to unequip</param>
        /// <returns>True if unequipped successfully, false otherwise</returns>
        public static bool UnequipItem(this CharacterProgressionData characterData, string equipmentId)
        {
            if (string.IsNullOrEmpty(equipmentId))
            {
                Debug.LogError("[CharacterProgressionData] Cannot unequip null or empty equipment ID");
                return false;
            }

            // Check if it's a hand weapon
            if (characterData.EquippedHandWeapons.Contains(equipmentId))
            {
                // Get the private field through reflection
                var handWeaponsField = typeof(CharacterProgressionData).GetField("equippedHandWeapons", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance);
                if (handWeaponsField != null)
                {
                    var handWeapons = handWeaponsField.GetValue(characterData) as List<string>;
                    if (handWeapons != null)
                    {
                        handWeapons.Remove(equipmentId);
                        Debug.Log($"[CharacterProgressionData] Unequipped hand weapon: {equipmentId}");
                        return true;
                    }
                }
                Debug.LogError($"[CharacterProgressionData] Failed to access hand weapons field for unequipping {equipmentId}");
                return false;
            }

            // Check if it's a body weapon
            if (characterData.EquippedBodyWeapon == equipmentId)
            {
                var bodyWeaponField = typeof(CharacterProgressionData).GetField("equippedBodyWeapon", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance);
                if (bodyWeaponField != null)
                {
                    bodyWeaponField.SetValue(characterData, string.Empty);
                    Debug.Log($"[CharacterProgressionData] Unequipped body weapon: {equipmentId}");
                    return true;
                }
                Debug.LogError($"[CharacterProgressionData] Failed to access body weapon field for unequipping {equipmentId}");
                return false;
            }

            // Check if it's a power-up
            if (characterData.EquippedPowerupIds.Contains(equipmentId))
            {
                var powerUpsField = typeof(CharacterProgressionData).GetField("equippedPowerupIds", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance);
                if (powerUpsField != null)
                {
                    var powerUps = powerUpsField.GetValue(characterData) as List<string>;
                    if (powerUps != null)
                    {
                        powerUps.Remove(equipmentId);
                        Debug.Log($"[CharacterProgressionData] Unequipped power-up: {equipmentId}");
                        return true;
                    }
                }
                Debug.LogError($"[CharacterProgressionData] Failed to access power-ups field for unequipping {equipmentId}");
                return false;
            }

            // Check if it's armor
            if (characterData.EquippedArmor == equipmentId)
            {
                var armorField = typeof(CharacterProgressionData).GetField("equippedArmor", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance);
                if (armorField != null)
                {
                    armorField.SetValue(characterData, string.Empty);
                    Debug.Log($"[CharacterProgressionData] Unequipped armor: {equipmentId}");
                    return true;
                }
                Debug.LogError($"[CharacterProgressionData] Failed to access armor field for unequipping {equipmentId}");
                return false;
            }

            // Check if it's an amulet
            if (characterData.EquippedAmulet == equipmentId)
            {
                var amuletField = typeof(CharacterProgressionData).GetField("equippedAmulet", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance);
                if (amuletField != null)
                {
                    amuletField.SetValue(characterData, string.Empty);
                    Debug.Log($"[CharacterProgressionData] Unequipped amulet: {equipmentId}");
                    return true;
                }
                Debug.LogError($"[CharacterProgressionData] Failed to access amulet field for unequipping {equipmentId}");
                return false;
            }

            // Item not found equipped on the character
            Debug.LogWarning($"[CharacterProgressionData] Equipment {equipmentId} is not equipped");
            return false;
        }

        /// <summary>
        /// Checks if a specific equipment is equipped
        /// </summary>
        /// <param name="characterData">The character progression data</param>
        /// <param name="equipmentId">ID of the equipment to check</param>
        /// <returns>True if equipped, false otherwise</returns>
        public static bool IsEquipped(this CharacterProgressionData characterData, string equipmentId)
        {
            if (string.IsNullOrEmpty(equipmentId))
                return false;

            // Check hand weapons
            if (characterData.EquippedHandWeapons.Contains(equipmentId))
                return true;

            // Check body weapon
            if (characterData.EquippedBodyWeapon == equipmentId)
                return true;

            // Check power-ups
            if (characterData.EquippedPowerupIds.Contains(equipmentId))
                return true;

            // Check armor
            if (characterData.EquippedArmor == equipmentId)
                return true;

            // Check amulet
            if (characterData.EquippedAmulet == equipmentId)
                return true;

            return false;
        }

        /// <summary>
        /// Get the slot type where an item is equipped, or null if not equipped
        /// </summary>
        /// <param name="characterData">The character progression data</param>
        /// <param name="equipmentId">ID of the equipment to check</param>
        /// <returns>The slot type, or null if not equipped</returns>
        public static EquipmentSlotType? GetEquippedSlotType(this CharacterProgressionData characterData, string equipmentId)
        {
            if (string.IsNullOrEmpty(equipmentId))
                return null;

            // Check hand weapons
            if (characterData.EquippedHandWeapons.Contains(equipmentId))
                return EquipmentSlotType.HandWeapon;

            // Check body weapon
            if (characterData.EquippedBodyWeapon == equipmentId)
                return EquipmentSlotType.BodyWeapon;

            // Check power-ups
            if (characterData.EquippedPowerupIds.Contains(equipmentId))
                return EquipmentSlotType.PowerUp;

            // Check armor
            if (characterData.EquippedArmor == equipmentId)
                return EquipmentSlotType.Armor;

            // Check amulet
            if (characterData.EquippedAmulet == equipmentId)
                return EquipmentSlotType.Amulet;

            return null;
        }
    }
}

// --- END FILE ---

// File: Core/Services/Authentication/Data/EquipmentProgressionData.cs
// Size: 4328 characters
// ---
// File: Assets/Code/Core/Services/Authentication/Data/EquipmentProgressionData.cs
//
// Purpose: Defines the data structure for equipment progression tracking.
// Stores the upgrade level and other persistent stats for equipment items.
// Used by ProfileData to track permanent equipment upgrades between sessions.
//
// Created: 2025-02-25
// Updated: 2025-02-25

using System;
using Newtonsoft.Json;

namespace CyberPickle.Core.Services.Authentication.Data
{
    /// <summary>
    /// Stores progression data for a single equipment item
    /// </summary>
    [Serializable]
    public class EquipmentProgressionData
    {
        [JsonProperty("equipmentId")]
        private string equipmentId;

        [JsonProperty("currentLevel")]
        private int currentLevel;

        [JsonProperty("purchaseTimeTicks")]
        private long purchaseTimeTicks;

        [JsonProperty("lastUpgradeTimeTicks")]
        private long lastUpgradeTimeTicks;

        [JsonProperty("timesUsed")]
        private int timesUsed;

        [JsonProperty("totalKills")]
        private int totalKills;

        [JsonProperty("totalDamage")]
        private float totalDamage;

        /// <summary>
        /// The equipment ID this progression data is for
        /// </summary>
        [JsonIgnore]
        public string EquipmentId => equipmentId;

        /// <summary>
        /// The current upgrade level of the equipment
        /// </summary>
        [JsonIgnore]
        public int CurrentLevel => currentLevel;

        /// <summary>
        /// When the equipment was first purchased
        /// </summary>
        [JsonIgnore]
        public DateTime PurchaseTime => new DateTime(purchaseTimeTicks);

        /// <summary>
        /// When the equipment was last upgraded
        /// </summary>
        [JsonIgnore]
        public DateTime LastUpgradeTime => new DateTime(lastUpgradeTimeTicks);

        /// <summary>
        /// How many times the equipment has been used
        /// </summary>
        [JsonIgnore]
        public int TimesUsed => timesUsed;

        /// <summary>
        /// How many kills the equipment has gotten
        /// </summary>
        [JsonIgnore]
        public int TotalKills => totalKills;

        /// <summary>
        /// Total damage dealt with this equipment
        /// </summary>
        [JsonIgnore]
        public float TotalDamage => totalDamage;

        /// <summary>
        /// Creates new equipment progression data
        /// </summary>
        /// <param name="equipmentId">The ID of the equipment</param>
        public EquipmentProgressionData(string equipmentId)
        {
            this.equipmentId = equipmentId;
            this.currentLevel = 1;
            this.purchaseTimeTicks = DateTime.UtcNow.Ticks;
            this.lastUpgradeTimeTicks = this.purchaseTimeTicks;
            this.timesUsed = 0;
            this.totalKills = 0;
            this.totalDamage = 0;
        }

        /// <summary>
        /// Upgrade the equipment to the specified level
        /// </summary>
        /// <param name="newLevel">The new level to upgrade to</param>
        /// <returns>True if upgraded successfully</returns>
        public bool Upgrade(int newLevel)
        {
            if (newLevel <= currentLevel)
                return false;

            currentLevel = newLevel;
            lastUpgradeTimeTicks = DateTime.UtcNow.Ticks;
            return true;
        }

        /// <summary>
        /// Record usage of this equipment
        /// </summary>
        public void RecordUse()
        {
            timesUsed++;
        }

        /// <summary>
        /// Record kills made with this equipment
        /// </summary>
        /// <param name="kills">Number of kills to add</param>
        public void RecordKills(int kills)
        {
            if (kills > 0)
                totalKills += kills;
        }

        /// <summary>
        /// Record damage dealt with this equipment
        /// </summary>
        /// <param name="damage">Amount of damage to add</param>
        public void RecordDamage(float damage)
        {
            if (damage > 0)
                totalDamage += damage;
        }
    }
}

// --- END FILE ---

// File: Core/Services/Authentication/Data/ProfileContainer.cs
// Size: 8664 characters
// ---
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using UnityEngine;

namespace CyberPickle.Core.Services.Authentication.Data
{
    /// <summary>
    /// Container class for managing player profiles with Json.NET serialization support.
    /// Handles profile storage, retrieval, and persistence.
    /// </summary>
    [Serializable]
    public class ProfileContainer
    {
        [JsonProperty("Profiles")]
        private List<ProfileData> profiles = new List<ProfileData>();

        private static string profilesFilePath;

        /// <summary>
        /// Lazy-initialized file path for profile storage
        /// </summary>
        private static string ProfilesFilePath
        {
            get
            {
                if (string.IsNullOrEmpty(profilesFilePath))
                {
                    profilesFilePath = Path.Combine(Application.persistentDataPath, "profiles.json");
                }
                return profilesFilePath;
            }
        }

        /// <summary>
        /// Read-only access to all profiles
        /// </summary>
        [JsonIgnore]
        public IReadOnlyList<ProfileData> Profiles => profiles.AsReadOnly();

        /// <summary>
        /// Currently active profile
        /// </summary>
        [JsonIgnore]
        public ProfileData ActiveProfile => profiles.FirstOrDefault(p => p.IsActive);

        /// <summary>
        /// Adds a new profile if it doesn't exist
        /// </summary>
        public void AddProfile(ProfileData profile)
        {
            if (!profiles.Any(p => p.ProfileId == profile.ProfileId))
            {
                Debug.Log($"[ProfileContainer] Adding new profile: {profile.ProfileId}");
                profiles.Add(profile);
                SaveProfiles();
            }
        }

        /// <summary>
        /// Retrieves a profile by ID
        /// </summary>
        public ProfileData GetProfile(string profileId)
        {
            return profiles.FirstOrDefault(p => p.ProfileId == profileId);
        }

        /// <summary>
        /// Sets the active profile and deactivates all others
        /// </summary>
        public void SetActiveProfile(string profileId)
        {
            Debug.Log($"[ProfileContainer] Setting active profile to {profileId}. Before change - Active profile: {ActiveProfile?.ProfileId}");

            foreach (var profile in profiles)
            {
                bool shouldBeActive = profile.ProfileId == profileId;
                profile.SetActive(shouldBeActive);
                Debug.Log($"[ProfileContainer] Profile {profile.ProfileId} - Setting active to: {shouldBeActive}");
            }

            SaveProfiles();

            // Verify the change
            var activeProfile = ActiveProfile;
            if (activeProfile != null)
            {
                Debug.Log($"[ProfileContainer] Active profile is now: {activeProfile.ProfileId}");
            }
            else
            {
                Debug.LogError("[ProfileContainer] No active profile found after setting active profile.");
            }
        }

        /// <summary>
        /// Updates an existing profile
        /// </summary>
        public void UpdateProfile(ProfileData updatedProfile)
        {
            var index = profiles.FindIndex(p => p.ProfileId == updatedProfile.ProfileId);
            if (index != -1)
            {
                Debug.Log($"[ProfileContainer] Updating profile: {updatedProfile.ProfileId}");
                profiles[index] = updatedProfile;
                SaveProfiles();
            }
        }

        /// <summary>
        /// Removes a profile by ID
        /// </summary>
        public void RemoveProfile(string profileId)
        {
            profiles.RemoveAll(p => p.ProfileId == profileId);
            SaveProfiles();
        }

        /// <summary>
        /// Saves all profiles to disk using Json.NET
        /// </summary>
        public void SaveProfiles()
        {
            try
            {
                var settings = new JsonSerializerSettings
                {
                    Formatting = Formatting.Indented,
                    ReferenceLoopHandling = ReferenceLoopHandling.Ignore,
                    NullValueHandling = NullValueHandling.Include,
                    ObjectCreationHandling = ObjectCreationHandling.Replace
                };

                var json = JsonConvert.SerializeObject(this, settings);
                File.WriteAllText(ProfilesFilePath, json);

                Debug.Log($"[ProfileContainer] Profiles saved successfully to {ProfilesFilePath}");
                Debug.Log($"[ProfileContainer] Saved {profiles.Count} profiles, Active profile: {ActiveProfile?.ProfileId}");
            }
            catch (Exception e)
            {
                Debug.LogError($"[ProfileContainer] Failed to save profiles: {e.Message}\nStack trace: {e.StackTrace}");
            }
        }

        /// <summary>
        /// Loads profiles from disk using Json.NET
        /// </summary>
        public static ProfileContainer Load()
        {
            try
            {
                Debug.Log($"[ProfileContainer] Attempting to load from: {ProfilesFilePath}");

                if (!File.Exists(ProfilesFilePath))
                {
                    Debug.Log($"[ProfileContainer] No profile file found at: {ProfilesFilePath}");
                    return new ProfileContainer();
                }

                var json = File.ReadAllText(ProfilesFilePath);
                Debug.Log($"[ProfileContainer] Loaded JSON content: {json}");

                var settings = new JsonSerializerSettings
                {
                    ObjectCreationHandling = ObjectCreationHandling.Replace,
                    NullValueHandling = NullValueHandling.Ignore,
                    DefaultValueHandling = DefaultValueHandling.Populate
                };

                var container = JsonConvert.DeserializeObject<ProfileContainer>(json, settings);

                if (container == null)
                {
                    Debug.LogError("[ProfileContainer] Deserialization returned null container");
                    return new ProfileContainer();
                }

                Debug.Log($"[ProfileContainer] Successfully loaded {container.profiles.Count} profiles");
                foreach (var profile in container.profiles)
                {
                    // Initialize collections if they're null
                    profile.InitializeCollectionsIfNeeded();
                    Debug.Log($"[ProfileContainer] Loaded profile: {profile.ProfileId}, Active: {profile.IsActive}");
                }

                return container;
            }
            catch (Exception e)
            {
                Debug.LogError($"[ProfileContainer] Error loading profiles: {e.Message}\nStack trace: {e.StackTrace}");
                return new ProfileContainer();
            }
        }

        /// <summary>
        /// Clears all profiles and deletes the save file
        /// </summary>
        public void ClearAll()
        {
            Debug.Log("[ProfileContainer] Clearing all profiles");
            profiles.Clear();
            if (File.Exists(ProfilesFilePath))
            {
                File.Delete(ProfilesFilePath);
            }
        }

        /// <summary>
        /// Verifies the integrity of the profile container and repairs if needed
        /// </summary>
        public void VerifyIntegrity()
        {
            Debug.Log("[ProfileContainer] Verifying profile container integrity");

            // Ensure no duplicate active profiles
            var activeProfiles = profiles.Count(p => p.IsActive);
            if (activeProfiles > 1)
            {
                Debug.LogWarning("[ProfileContainer] Found multiple active profiles, fixing...");
                var firstActive = profiles.First(p => p.IsActive);
                foreach (var profile in profiles.Where(p => p.IsActive && p.ProfileId != firstActive.ProfileId))
                {
                    profile.SetActive(false);
                }
            }

            // Initialize collections for all profiles
            foreach (var profile in profiles)
            {
                profile.InitializeCollectionsIfNeeded();
            }

            SaveProfiles();
        }
    }
}
// --- END FILE ---

// File: Core/Services/Authentication/Data/ProfileData.cs
// Size: 29268 characters
// ---
// File: Core/Services/Authentication/Data/ProfileData.cs
//
// Purpose: Defines the data structures for player profiles, character progression,
// and mining nodes. Enhanced to support shop items, global currencies, and expanded
// equipment systems.
//
// Created: 2024-02-11
// Updated: 2024-02-24

using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using UnityEngine;

namespace CyberPickle.Core.Services.Authentication.Data
{
    /// <summary>
    /// Defines the available equipment slot types
    /// </summary>
    [Serializable]
    public enum EquipmentSlotType
    {
        /// <summary>Hand weapon slot (max 2)</summary>
        HandWeapon,
        /// <summary>Body weapon slot (max 1)</summary>
        BodyWeapon,
        /// <summary>Power-up slot (max 3)</summary>
        PowerUp,
        /// <summary>Armor slot (max 1)</summary>
        Armor,
        /// <summary>Amulet slot (max 1)</summary>
        Amulet
    }

    /// <summary>
    /// Defines the types of currency available in the game
    /// </summary>
    [Serializable]
    public enum CurrencyType
    {
        /// <summary>
        /// Primary currency earned through gameplay, destroying objects and defeating enemies
        /// </summary>
        NeuralCredits,

        /// <summary>
        /// Special cryptocurrency used for character unlocks, earned through Neural Mining
        /// </summary>
        CyberCoins
    }

    /// <summary>
    /// Represents character-specific progression data including stats, experience, and equipment
    /// </summary>
    [Serializable]
    public class CharacterProgressionData
    {
        [JsonProperty("characterId")]
        private string characterId;

        [JsonProperty("characterLevel")]
        private int characterLevel;

        [JsonProperty("experience")]
        private float experience;

        [JsonProperty("stats")]
        private Dictionary<string, float> stats;

        [JsonProperty("unlockedSkills")]
        private List<string> unlockedSkills;

        // Keep existing properties
        [JsonProperty("equippedWeaponId")]
        private string equippedWeaponId;

        [JsonProperty("equippedPowerupIds")]
        private List<string> equippedPowerupIds;

        // Add new equipment slots
        [JsonProperty("equippedHandWeapons")]
        private List<string> equippedHandWeapons;

        [JsonProperty("equippedBodyWeapon")]
        private string equippedBodyWeapon;

        [JsonProperty("equippedArmor")]
        private string equippedArmor;

        [JsonProperty("equippedAmulet")]
        private string equippedAmulet;

        // Constants defining equipment slot limits
        private const int MAX_HAND_WEAPONS = 2;
        private const int MAX_BODY_WEAPONS = 1;
        private const int MAX_POWER_UPS = 3;

        // Public Properties - keep existing ones
        [JsonIgnore] public string CharacterId => characterId;
        [JsonIgnore] public int CharacterLevel => characterLevel;
        [JsonIgnore] public float Experience => experience;
        [JsonIgnore] public IReadOnlyDictionary<string, float> Stats => stats;
        [JsonIgnore] public IReadOnlyList<string> UnlockedSkills => unlockedSkills;
        [JsonIgnore] public string EquippedWeaponId => equippedWeaponId;
        [JsonIgnore] public IReadOnlyList<string> EquippedPowerupIds => equippedPowerupIds;

        // Add new properties
        [JsonIgnore] public IReadOnlyList<string> EquippedHandWeapons => equippedHandWeapons;
        [JsonIgnore] public string EquippedBodyWeapon => equippedBodyWeapon;
        [JsonIgnore] public string EquippedArmor => equippedArmor;
        [JsonIgnore] public string EquippedAmulet => equippedAmulet;

        public CharacterProgressionData(string characterId)
        {
            this.characterId = characterId;
            InitializeCollections();
        }

        private void InitializeCollections()
        {
            characterLevel = 1;
            experience = 0f;
            stats = new Dictionary<string, float>();
            unlockedSkills = new List<string>();
            equippedPowerupIds = new List<string>();

            // Initialize new collections
            equippedHandWeapons = new List<string>(MAX_HAND_WEAPONS);
            equippedBodyWeapon = string.Empty;
            equippedArmor = string.Empty;
            equippedAmulet = string.Empty;

            // Set default stats
            InitializeDefaultStats();
        }

        /// <summary>
        /// Sets up default stats for a new character
        /// </summary>
        private void InitializeDefaultStats()
        {
            // Initialize with basic stats if stats dictionary is empty
            if (stats.Count == 0)
            {
                stats["Health"] = 100f;
                stats["Defense"] = 10f;
                stats["Power"] = 10f;
                stats["Speed"] = 5f;
                stats["MagneticField"] = 1f;
                stats["Dexterity"] = 10f;
                stats["Luck"] = 1f;
                stats["AreaOfEffect"] = 1f;
            }
        }

        #region Experience and Leveling

        /// <summary>
        /// Adds experience points to the character
        /// </summary>
        /// <param name="amount">Amount of experience to add</param>
        /// <returns>True if the character leveled up, false otherwise</returns>
        public bool AddExperience(float amount)
        {
            if (amount <= 0) return false;

            int oldLevel = characterLevel;
            experience += amount;

            // Calculate new level based on experience
            // XP needed for next level = level * 1000
            while (experience >= characterLevel * 1000)
            {
                experience -= characterLevel * 1000;
                characterLevel++;

                // When leveling up, increase stats automatically
                IncreaseLevelStats();
            }

            Debug.Log($"[CharacterProgressionData] Added {amount} XP to {characterId}. Level: {characterLevel}, XP: {experience}");
            return characterLevel > oldLevel;
        }

        /// <summary>
        /// Increases character stats when leveling up
        /// </summary>
        private void IncreaseLevelStats()
        {
            // Apply stat increases on level up
            if (stats.ContainsKey("Health")) stats["Health"] += 10f;
            if (stats.ContainsKey("Defense")) stats["Defense"] += 1f;
            if (stats.ContainsKey("Power")) stats["Power"] += 1f;

            Debug.Log($"[CharacterProgressionData] {characterId} leveled up to level {characterLevel}");
        }

        #endregion

        #region Equipment Management

        /// <summary>
        /// Equips an item in the specified slot
        /// </summary>
        /// <param name="equipmentId">The unique identifier of the equipment</param>
        /// <param name="slotType">The slot type to equip in</param>
        /// <returns>True if successful, false otherwise</returns>
        public bool EquipItem(string equipmentId, EquipmentSlotType slotType)
        {
            if (string.IsNullOrEmpty(equipmentId))
            {
                Debug.LogError("[CharacterProgressionData] Cannot equip null or empty equipment ID");
                return false;
            }

            try
            {
                switch (slotType)
                {
                    case EquipmentSlotType.HandWeapon:
                        return EquipHandWeapon(equipmentId);

                    case EquipmentSlotType.BodyWeapon:
                        equippedBodyWeapon = equipmentId;
                        Debug.Log($"[CharacterProgressionData] Equipped body weapon: {equipmentId}");
                        return true;

                    case EquipmentSlotType.PowerUp:
                        return EquipPowerUp(equipmentId);

                    case EquipmentSlotType.Armor:
                        equippedArmor = equipmentId;
                        Debug.Log($"[CharacterProgressionData] Equipped armor: {equipmentId}");
                        return true;

                    case EquipmentSlotType.Amulet:
                        equippedAmulet = equipmentId;
                        Debug.Log($"[CharacterProgressionData] Equipped amulet: {equipmentId}");
                        return true;

                    default:
                        Debug.LogError($"[CharacterProgressionData] Unknown equipment slot type: {slotType}");
                        return false;
                }
            }
            catch (Exception ex)
            {
                Debug.LogError($"[CharacterProgressionData] Error equipping item: {ex.Message}");
                return false;
            }
        }

        /// <summary>
        /// Equips a hand weapon while respecting the maximum limit
        /// </summary>
        /// <param name="weaponId">Hand weapon ID to equip</param>
        /// <returns>True if equipped successfully</returns>
        private bool EquipHandWeapon(string weaponId)
        {
            // Check if already equipped
            if (equippedHandWeapons.Contains(weaponId))
            {
                Debug.LogWarning($"[CharacterProgressionData] Hand weapon {weaponId} is already equipped");
                return false;
            }

            // Check if at max capacity
            if (equippedHandWeapons.Count >= MAX_HAND_WEAPONS)
            {
                Debug.LogWarning($"[CharacterProgressionData] Cannot equip more than {MAX_HAND_WEAPONS} hand weapons");
                return false;
            }

            equippedHandWeapons.Add(weaponId);
            Debug.Log($"[CharacterProgressionData] Equipped hand weapon: {weaponId}");
            return true;
        }

        /// <summary>
        /// Equips a power-up while respecting the maximum limit
        /// </summary>
        /// <param name="powerUpId">Power-up ID to equip</param>
        /// <returns>True if equipped successfully</returns>
        private bool EquipPowerUp(string powerUpId)
        {
            // Check if already equipped
            if (equippedPowerupIds.Contains(powerUpId))
            {
                Debug.LogWarning($"[CharacterProgressionData] Power-up {powerUpId} is already equipped");
                return false;
            }

            // Check if at max capacity
            if (equippedPowerupIds.Count >= MAX_POWER_UPS)
            {
                Debug.LogWarning($"[CharacterProgressionData] Cannot equip more than {MAX_POWER_UPS} power-ups");
                return false;
            }

            equippedPowerupIds.Add(powerUpId);
            Debug.Log($"[CharacterProgressionData] Equipped power-up: {powerUpId}");
            return true;
        }

        #endregion
    }

    /// <summary>
    /// Represents a single Neural Mining Node that passively generates CyberCoins
    /// </summary>
    [Serializable]
    public class MiningNodeData
    {
        [JsonProperty("nodeId")]
        private string nodeId;

        [JsonProperty("level")]
        private int level;

        [JsonProperty("baseRate")]
        private float baseRate;

        [JsonProperty("multiplier")]
        private float multiplier;

        [JsonProperty("lastMiningTimeTicks")]
        private long lastMiningTimeTicks;

        // Maximum level a node can be upgraded to
        private const int MAX_NODE_LEVEL = 10;

        // Maximum hours that mining resources can accumulate while offline
        private const float MAX_OFFLINE_HOURS = 24f;

        // Public Properties
        [JsonIgnore] public string NodeId => nodeId;
        [JsonIgnore] public int Level => level;
        [JsonIgnore] public float BaseRate => baseRate;
        [JsonIgnore] public float Multiplier => multiplier;
        [JsonIgnore] public DateTime LastMiningTime => new DateTime(lastMiningTimeTicks);

        /// <summary>
        /// Calculate the current mining rate including level bonuses and multipliers
        /// </summary>
        [JsonIgnore] public float CurrentMiningRate => baseRate * (1 + (level - 1) * 0.2f) * multiplier;

        /// <summary>
        /// How many CyberCoins have accumulated since last collection
        /// </summary>
        [JsonIgnore]
        public float PendingCoins
        {
            get
            {
                DateTime now = DateTime.UtcNow;
                TimeSpan timeSinceLastMining = now - LastMiningTime;

                // Calculate how many hours have passed (up to a maximum of MAX_OFFLINE_HOURS)
                float hoursElapsed = Mathf.Min((float)timeSinceLastMining.TotalHours, MAX_OFFLINE_HOURS);

                // Calculate earnings
                return hoursElapsed * CurrentMiningRate;
            }
        }

        public MiningNodeData(string nodeId)
        {
            this.nodeId = nodeId;
            this.level = 1;
            this.baseRate = 10f;
            this.multiplier = 1f;
            this.lastMiningTimeTicks = DateTime.UtcNow.Ticks;
        }

        /// <summary>
        /// Upgrades the mining node to the next level if possible
        /// </summary>
        /// <returns>True if the upgrade was successful, false if already at max level</returns>
        public bool Upgrade()
        {
            if (level >= MAX_NODE_LEVEL)
            {
                Debug.Log($"[MiningNodeData] Cannot upgrade node {nodeId}: already at maximum level {MAX_NODE_LEVEL}");
                return false;
            }

            level++;
            Debug.Log($"[MiningNodeData] Node {nodeId} upgraded to level {level}");
            return true;
        }

        /// <summary>
        /// Collects accumulated CyberCoins from this mining node
        /// </summary>
        /// <returns>The amount of CyberCoins collected</returns>
        public float CollectMining()
        {
            float earnings = PendingCoins;

            // Update last mining time to now
            lastMiningTimeTicks = DateTime.UtcNow.Ticks;

            Debug.Log($"[MiningNodeData] Collected {earnings} CyberCoins from node {nodeId}");
            return earnings;
        }
    }

    /// <summary>
    /// Main profile data class containing global and character-specific information
    /// </summary>
    [Serializable]
    public class ProfileData
    {
        #region Private Fields
        [JsonProperty("equipmentProgressionData")]
        private Dictionary<string, EquipmentProgressionData> equipmentProgressionData = new Dictionary<string, EquipmentProgressionData>();

        [JsonProperty("ProfileId")]
        private string profileId;

        [JsonProperty("PlayerId")]
        private string playerId;

        [JsonProperty("DisplayName")]
        private string displayName;

        [JsonProperty("IsActive")]
        private bool isActive;

        [JsonProperty("CreatedAtTicks")]
        private long createdAtTicks;

        [JsonProperty("LastLoginAtTicks")]
        private long lastLoginAtTicks;

        [JsonProperty("TotalPlayTime")]
        private float totalPlayTime;

        [JsonProperty("HighestScore")]
        private int highestScore;

        [JsonProperty("FurthestDistance")]
        private float furthestDistance;

        [JsonProperty("Level")]
        private int level;

        [JsonProperty("HasSaveData")]
        private bool hasSaveData;

        [JsonProperty("CyberCoins")]
        private float cyberCoins;

        [JsonProperty("NeuralCredits")]
        private float neuralCredits;

        [JsonProperty("CharacterProgress")]
        private Dictionary<string, CharacterProgressionData> characterProgress;

        [JsonProperty("MiningNodes")]
        private Dictionary<string, MiningNodeData> miningNodes;

        [JsonProperty("UnlockedEquipment")]
        private HashSet<string> unlockedEquipment;

        [JsonProperty("Achievements")]
        private HashSet<string> achievements;

        [JsonProperty("GlobalMultipliers")]
        private Dictionary<string, float> globalMultipliers;

        [JsonProperty("UnlockedLevels")]
        private HashSet<string> unlockedLevels;

        #endregion

        #region Public Properties

        [JsonIgnore] public string ProfileId => profileId;
        [JsonIgnore] public string PlayerId => playerId;
        [JsonIgnore] public string DisplayName => displayName;
        [JsonIgnore] public bool HasSaveData => hasSaveData;
        [JsonIgnore] public float TotalPlayTime => totalPlayTime;
        [JsonIgnore] public int HighestScore => highestScore;
        [JsonIgnore] public float FurthestDistance => furthestDistance;
        [JsonIgnore] public int Level => level;
        [JsonIgnore] public bool IsActive => isActive;
        [JsonIgnore] public DateTime CreatedAt => new DateTime(createdAtTicks);
        [JsonIgnore] public DateTime LastLoginTime => new DateTime(lastLoginAtTicks);
        [JsonIgnore] public float CyberCoins => cyberCoins;
        [JsonIgnore] public float NeuralCredits => neuralCredits;

        [JsonIgnore] public IReadOnlyDictionary<string, CharacterProgressionData> CharacterProgress => characterProgress;
        [JsonIgnore] public IReadOnlyDictionary<string, MiningNodeData> MiningNodes => miningNodes;
        [JsonIgnore] public IReadOnlyCollection<string> UnlockedEquipment => unlockedEquipment;
        [JsonIgnore] public IReadOnlyCollection<string> Achievements => achievements;
        [JsonIgnore] public IReadOnlyDictionary<string, float> GlobalMultipliers => globalMultipliers;
        [JsonIgnore] public IReadOnlyCollection<string> UnlockedLevels => unlockedLevels;

        #endregion

        #region Constructor and Initialization

        public ProfileData(string profileId, string playerId, string displayName)
        {
            this.profileId = profileId;
            this.playerId = playerId;
            this.displayName = displayName;
            this.createdAtTicks = DateTime.UtcNow.Ticks;
            this.lastLoginAtTicks = DateTime.UtcNow.Ticks;

            InitializeCollectionsIfNeeded();
            SetDefaultValues();
        }

        /// <summary>
        /// Ensures all collections are properly initialized
        /// Called after deserialization to prevent null collections
        /// </summary>
        public void InitializeCollectionsIfNeeded()
        {
            Debug.Log($"[ProfileData] Initializing collections for profile: {profileId}");

            characterProgress ??= new Dictionary<string, CharacterProgressionData>();
            miningNodes ??= new Dictionary<string, MiningNodeData>();
            unlockedEquipment ??= new HashSet<string>();
            achievements ??= new HashSet<string>();
            globalMultipliers ??= new Dictionary<string, float>();
            unlockedLevels ??= new HashSet<string>();
        }

        private void SetDefaultValues()
        {
            isActive = false;
            hasSaveData = false;
            totalPlayTime = 0f;
            highestScore = 0;
            furthestDistance = 0f;
            level = 1;
            cyberCoins = 0f;
            neuralCredits = 0f;
        }

        #endregion

        #region Public Methods

        // Keep existing methods
        public void UpdateLoginTime()
        {
            lastLoginAtTicks = DateTime.UtcNow.Ticks;
        }

        public void UpdateDisplayName(string name)
        {
            if (!string.IsNullOrEmpty(name))
            {
                displayName = name;
            }
        }

        public void UpdateProgress(float playTime, int score, float distance, int level)
        {
            totalPlayTime = playTime;
            if (score > highestScore) highestScore = score;
            if (distance > furthestDistance) furthestDistance = distance;
            this.level = level;
            hasSaveData = true;
        }

        public void UpdateCharacterProgress(string characterId, CharacterProgressionData progression)
        {
            InitializeCollectionsIfNeeded();
            characterProgress[characterId] = progression;
            Debug.Log($"[ProfileData] Updated character progress for {characterId} in profile {profileId}");
        }

        public void UpdateMiningNode(string nodeId, MiningNodeData nodeData)
        {
            InitializeCollectionsIfNeeded();
            miningNodes[nodeId] = nodeData;
        }

        public void UpdateCurrency(float cyberCoins, float neuralCredits)
        {
            this.cyberCoins = cyberCoins;
            this.neuralCredits = neuralCredits;
        }

        public void ClearProgress()
        {
            totalPlayTime = 0f;
            highestScore = 0;
            furthestDistance = 0f;
            level = 1;
            cyberCoins = 0f;
            neuralCredits = 0f;

            InitializeCollectionsIfNeeded();
            characterProgress.Clear();
            miningNodes.Clear();
            unlockedEquipment.Clear();
            achievements.Clear();
            globalMultipliers.Clear();
            unlockedLevels.Clear();

            hasSaveData = false;
            Debug.Log($"[ProfileData] Cleared progress for profile: {profileId}");
        }

        public void SetActive(bool active)
        {
            isActive = active;
            Debug.Log($"[ProfileData] Profile {profileId} active state set to: {active}");
        }

        // Add new methods

        #region Currency Methods

        /// <summary>
        /// Adds currency to the player's balance
        /// </summary>
        /// <param name="amount">Amount to add (must be positive)</param>
        /// <param name="type">Type of currency to add</param>
        /// <returns>True if the currency was added successfully</returns>
        public bool AddCurrency(float amount, CurrencyType type)
        {
            if (amount <= 0) return false;

            switch (type)
            {
                case CurrencyType.NeuralCredits:
                    neuralCredits += amount;
                    Debug.Log($"[ProfileData] Added {amount} Neural Credits. New balance: {neuralCredits}");
                    return true;

                case CurrencyType.CyberCoins:
                    cyberCoins += amount;
                    Debug.Log($"[ProfileData] Added {amount} CyberCoins. New balance: {cyberCoins}");
                    return true;

                default:
                    Debug.LogError($"[ProfileData] Unknown currency type: {type}");
                    return false;
            }
        }

        /// <summary>
        /// Attempts to spend currency from the player's balance
        /// </summary>
        /// <param name="amount">Amount to spend</param>
        /// <param name="type">Type of currency to spend</param>
        /// <returns>True if sufficient funds were available and spent, false otherwise</returns>
        public bool SpendCurrency(float amount, CurrencyType type)
        {
            if (amount <= 0) return false;

            switch (type)
            {
                case CurrencyType.NeuralCredits:
                    if (neuralCredits >= amount)
                    {
                        neuralCredits -= amount;
                        Debug.Log($"[ProfileData] Spent {amount} Neural Credits. Remaining balance: {neuralCredits}");
                        return true;
                    }
                    Debug.Log($"[ProfileData] Insufficient Neural Credits. Required: {amount}, Available: {neuralCredits}");
                    return false;

                case CurrencyType.CyberCoins:
                    if (cyberCoins >= amount)
                    {
                        cyberCoins -= amount;
                        Debug.Log($"[ProfileData] Spent {amount} CyberCoins. Remaining balance: {cyberCoins}");
                        return true;
                    }
                    Debug.Log($"[ProfileData] Insufficient CyberCoins. Required: {amount}, Available: {cyberCoins}");
                    return false;

                default:
                    Debug.LogError($"[ProfileData] Unknown currency type: {type}");
                    return false;
            }
        }

        #endregion

        #region Equipment Methods

        /// <summary>
        /// Unlocks a piece of equipment for use by any character
        /// </summary>
        /// <param name="equipmentId">The unique identifier of the equipment</param>
        /// <returns>True if newly unlocked, false if already unlocked</returns>
        public bool UnlockEquipment(string equipmentId)
        {
            if (string.IsNullOrEmpty(equipmentId)) return false;

            InitializeCollectionsIfNeeded();

            if (unlockedEquipment.Contains(equipmentId))
            {
                Debug.LogWarning($"[ProfileData] Equipment {equipmentId} is already unlocked");
                return false;
            }

            unlockedEquipment.Add(equipmentId);
            Debug.Log($"[ProfileData] Unlocked equipment: {equipmentId}");
            return true;
        }

        /// <summary>
        /// Checks if a piece of equipment is unlocked
        /// </summary>
        /// <param name="equipmentId">The equipment ID to check</param>
        /// <returns>True if unlocked, false otherwise</returns>
        public bool IsEquipmentUnlocked(string equipmentId)
        {
            if (string.IsNullOrEmpty(equipmentId)) return false;

            InitializeCollectionsIfNeeded();
            return unlockedEquipment.Contains(equipmentId);
        }

        #endregion

        #region Level Methods

        /// <summary>
        /// Unlocks a level for play
        /// </summary>
        /// <param name="levelId">The unique identifier of the level</param>
        /// <returns>True if newly unlocked, false if already unlocked</returns>
        public bool UnlockLevel(string levelId)
        {
            if (string.IsNullOrEmpty(levelId)) return false;

            InitializeCollectionsIfNeeded();

            if (unlockedLevels.Contains(levelId))
            {
                Debug.LogWarning($"[ProfileData] Level {levelId} is already unlocked");
                return false;
            }

            unlockedLevels.Add(levelId);
            Debug.Log($"[ProfileData] Unlocked level: {levelId}");
            return true;
        }

        /// <summary>
        /// Checks if a level is unlocked
        /// </summary>
        /// <param name="levelId">The level ID to check</param>
        /// <returns>True if unlocked, false otherwise</returns>
        public bool IsLevelUnlocked(string levelId)
        {
            if (string.IsNullOrEmpty(levelId)) return false;

            InitializeCollectionsIfNeeded();
            return unlockedLevels.Contains(levelId);
        }

        #endregion

        #region Mining Methods

        /// <summary>
        /// Adds a new mining node to the player's collection
        /// </summary>
        /// <param name="nodeId">The unique identifier for the node</param>
        /// <param name="level">Starting level for the node (default: 1)</param>
        public void AddMiningNode(string nodeId, int level = 1)
        {
            if (string.IsNullOrEmpty(nodeId)) return;

            InitializeCollectionsIfNeeded();

            if (!miningNodes.ContainsKey(nodeId))
            {
                miningNodes[nodeId] = new MiningNodeData(nodeId)
                {
                    // If needed, set additional properties here
                };
                Debug.Log($"[ProfileData] Added mining node: {nodeId} at level {level}");
            }
        }

        /// <summary>
        /// Collects all pending CyberCoins from all mining nodes
        /// </summary>
        /// <returns>The total amount of CyberCoins collected</returns>
        public float CollectAllMining()
        {
            InitializeCollectionsIfNeeded();

            float totalCollected = 0f;
            foreach (var node in miningNodes.Values)
            {
                totalCollected += node.CollectMining();
            }

            // Add the collected coins to the player's balance
            cyberCoins += totalCollected;

            Debug.Log($"[ProfileData] Collected a total of {totalCollected} CyberCoins from all mining nodes");
            return totalCollected;
        }

        #endregion

        #endregion
    }
}
// --- END FILE ---

// File: Core/Services/Authentication/Data/ProfileDataEquipmentExtension.cs
// Size: 10294 characters
// ---
// File: Assets/Code/Core/Services/Authentication/Data/ProfileDataEquipmentExtension.cs
//
// Purpose: Extends the ProfileData class with equipment progression tracking.
// Adds methods to get, set, and update equipment progression data.
//
// Created: 2025-02-25
// Updated: 2025-02-25

using System;
using System.Collections.Generic;
using System.Reflection;
using UnityEngine;
using Newtonsoft.Json;

namespace CyberPickle.Core.Services.Authentication.Data
{
    /// <summary>
    /// Extension class for ProfileData to add equipment progression tracking
    /// </summary>
    public static class ProfileDataEquipmentExtension
    {
        // Private field name in ProfileData that will store our equipment progression data
        private const string EquipmentProgressionFieldName = "equipmentProgressionData";

        /// <summary>
        /// Initializes equipment progression tracking for a profile if not already initialized
        /// </summary>
        /// <param name="profile">The profile to initialize</param>
        public static void InitializeEquipmentProgression(this ProfileData profile)
        {
            // Get or create the equipment progression dictionary using reflection
            var equipmentProgressionField = GetEquipmentProgressionField(profile);
            if (equipmentProgressionField == null)
                return;

            var equipmentProgression = equipmentProgressionField.GetValue(profile) as Dictionary<string, EquipmentProgressionData>;

            if (equipmentProgression == null)
            {
                equipmentProgression = new Dictionary<string, EquipmentProgressionData>();
                equipmentProgressionField.SetValue(profile, equipmentProgression);
                Debug.Log($"[ProfileData] Initialized equipment progression tracking for profile {profile.ProfileId}");
            }
        }

        /// <summary>
        /// Gets equipment progression data for a specific equipment item
        /// </summary>
        /// <param name="profile">The profile to get data from</param>
        /// <param name="equipmentId">The ID of the equipment</param>
        /// <returns>Equipment progression data or null if not found</returns>
        public static EquipmentProgressionData GetEquipmentProgression(this ProfileData profile, string equipmentId)
        {
            if (string.IsNullOrEmpty(equipmentId))
                return null;

            var equipmentProgressionField = GetEquipmentProgressionField(profile);
            if (equipmentProgressionField == null)
                return null;

            var equipmentProgression = equipmentProgressionField.GetValue(profile) as Dictionary<string, EquipmentProgressionData>;
            if (equipmentProgression == null)
            {
                profile.InitializeEquipmentProgression();
                equipmentProgression = equipmentProgressionField.GetValue(profile) as Dictionary<string, EquipmentProgressionData>;

                if (equipmentProgression == null)
                    return null;
            }

            // Try to get existing progression data
            if (equipmentProgression.TryGetValue(equipmentId, out var progressionData))
                return progressionData;

            return null;
        }

        /// <summary>
        /// Gets or creates equipment progression data for a specific equipment item
        /// </summary>
        /// <param name="profile">The profile to get data from</param>
        /// <param name="equipmentId">The ID of the equipment</param>
        /// <returns>Equipment progression data</returns>
        public static EquipmentProgressionData GetOrCreateEquipmentProgression(this ProfileData profile, string equipmentId)
        {
            if (string.IsNullOrEmpty(equipmentId))
                return null;

            // Try to get existing progression data
            var progressionData = profile.GetEquipmentProgression(equipmentId);
            if (progressionData != null)
                return progressionData;

            // Create new progression data
            var equipmentProgressionField = GetEquipmentProgressionField(profile);
            if (equipmentProgressionField == null)
                return null;

            var equipmentProgression = equipmentProgressionField.GetValue(profile) as Dictionary<string, EquipmentProgressionData>;
            if (equipmentProgression == null)
            {
                profile.InitializeEquipmentProgression();
                equipmentProgression = equipmentProgressionField.GetValue(profile) as Dictionary<string, EquipmentProgressionData>;

                if (equipmentProgression == null)
                    return null;
            }

            // Create new progression data
            progressionData = new EquipmentProgressionData(equipmentId);
            equipmentProgression[equipmentId] = progressionData;

            Debug.Log($"[ProfileData] Created equipment progression data for {equipmentId} in profile {profile.ProfileId}");

            return progressionData;
        }

        /// <summary>
        /// Gets the current level of a specific equipment item
        /// </summary>
        /// <param name="profile">The profile to get data from</param>
        /// <param name="equipmentId">The ID of the equipment</param>
        /// <returns>The current level or 0 if not found</returns>
        public static int GetEquipmentLevel(this ProfileData profile, string equipmentId)
        {
            var progressionData = profile.GetEquipmentProgression(equipmentId);
            return progressionData?.CurrentLevel ?? 0;
        }

        /// <summary>
        /// Upgrades a specific equipment item to a new level
        /// </summary>
        /// <param name="profile">The profile to upgrade in</param>
        /// <param name="equipmentId">The ID of the equipment</param>
        /// <param name="newLevel">The new level</param>
        /// <returns>True if upgraded successfully</returns>
        public static bool UpgradeEquipment(this ProfileData profile, string equipmentId, int newLevel)
        {
            if (string.IsNullOrEmpty(equipmentId) || newLevel <= 1)
                return false;

            var progressionData = profile.GetOrCreateEquipmentProgression(equipmentId);
            if (progressionData == null)
                return false;

            return progressionData.Upgrade(newLevel);
        }

        /// <summary>
        /// Records usage statistics for a specific equipment item
        /// </summary>
        /// <param name="profile">The profile to record in</param>
        /// <param name="equipmentId">The ID of the equipment</param>
        /// <param name="kills">Number of kills to record</param>
        /// <param name="damage">Amount of damage to record</param>
        public static void RecordEquipmentUsage(this ProfileData profile, string equipmentId, int kills = 0, float damage = 0)
        {
            if (string.IsNullOrEmpty(equipmentId))
                return;

            var progressionData = profile.GetOrCreateEquipmentProgression(equipmentId);
            if (progressionData == null)
                return;

            progressionData.RecordUse();

            if (kills > 0)
                progressionData.RecordKills(kills);

            if (damage > 0)
                progressionData.RecordDamage(damage);
        }

        /// <summary>
        /// Gets all equipment progression data for a profile
        /// </summary>
        /// <param name="profile">The profile to get data from</param>
        /// <returns>Dictionary of equipment progression data</returns>
        public static Dictionary<string, EquipmentProgressionData> GetAllEquipmentProgression(this ProfileData profile)
        {
            var equipmentProgressionField = GetEquipmentProgressionField(profile);
            if (equipmentProgressionField == null)
                return new Dictionary<string, EquipmentProgressionData>();

            var equipmentProgression = equipmentProgressionField.GetValue(profile) as Dictionary<string, EquipmentProgressionData>;
            if (equipmentProgression == null)
            {
                profile.InitializeEquipmentProgression();
                equipmentProgression = equipmentProgressionField.GetValue(profile) as Dictionary<string, EquipmentProgressionData>;

                if (equipmentProgression == null)
                    return new Dictionary<string, EquipmentProgressionData>();
            }

            return equipmentProgression;
        }

        /// <summary>
        /// Gets the field info for the equipment progression field in ProfileData
        /// </summary>
        /// <param name="profile">The profile to get field info for</param>
        /// <returns>Field info or null if not found</returns>
        private static FieldInfo GetEquipmentProgressionField(ProfileData profile)
        {
            // First check if the field already exists
            var field = typeof(ProfileData).GetField(EquipmentProgressionFieldName,
                BindingFlags.NonPublic | BindingFlags.Instance);

            if (field != null)
                return field;

            // If not, use reflection to get a private field that might hold a dictionary (fallback)
            var fields = typeof(ProfileData).GetFields(BindingFlags.NonPublic | BindingFlags.Instance);
            foreach (var f in fields)
            {
                if (f.FieldType == typeof(Dictionary<string, EquipmentProgressionData>))
                    return f;
            }

            // If we still haven't found it, we'll need to add the field using reflection
            // However, adding fields at runtime is not possible in C#
            // So we'll log a warning and return null
            Debug.LogWarning($"[ProfileData] Equipment progression field not found for profile {profile.ProfileId}. Make sure to add a private field named {EquipmentProgressionFieldName} to ProfileData.");

            return null;
        }
    }
}
// --- END FILE ---

// File: Core/Services/Authentication/Data/ProfileManagementEvents.cs
// Size: 843 characters
// ---
using System;

namespace CyberPickle.Core.Services.Authentication
{
    public class ProfileManagementEvents
    {
        // Profile events
        public event Action<string> OnProfileLoaded;
        public event Action<string> OnProfileSwitched;
        public event Action<string> OnNewProfileCreated;
        public event Action<string> OnProfileDeleted;

        // Internal methods to invoke events
        internal void InvokeProfileLoaded(string profileId) => OnProfileLoaded?.Invoke(profileId);
        internal void InvokeProfileSwitched(string profileId) => OnProfileSwitched?.Invoke(profileId);
        internal void InvokeNewProfileCreated(string profileId) => OnNewProfileCreated?.Invoke(profileId);
        internal void InvokeProfileDeleted(string profileId) => OnProfileDeleted?.Invoke(profileId);
    }
}

// --- END FILE ---

// File: Core/Services/Authentication/Flow/AuthenticationFlowManager.cs
// Size: 3288 characters
// ---
// File: Assets/_CyberPickle/Code/Core/Services/Authentication/Flow/AuthenticationFlowManager.cs
using UnityEngine;
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using CyberPickle.Core.Management;
using CyberPickle.Core.Events;
using CyberPickle.Core.Interfaces;
using CyberPickle.Core.Services.Authentication.Flow.States;
using CyberPickle.Core.Services.Authentication.Flow.Commands;



namespace CyberPickle.Core.Services.Authentication.Flow
{
    public class AuthenticationFlowManager : Manager<AuthenticationFlowManager>, IInitializable
    {
        private IAuthenticationState currentState;
        private Stack<IAuthCommand> executedCommands = new Stack<IAuthCommand>();
        private Dictionary<Type, IAuthenticationState> states;
        private bool isInitialized;

        public IAuthenticationState CurrentState => currentState;
        public event Action<IAuthenticationState> OnStateChanged;

        public void Initialize()
        {
            if (isInitialized) return;

            Debug.Log("[AuthFlowManager] Initializing");
            InitializeStates();
            isInitialized = true;
            TransitionTo<InitialState>();
        }

        private void InitializeStates()
        {
            states = new Dictionary<Type, IAuthenticationState>
            {
                { typeof(InitialState), new InitialState(this) },
                { typeof(AuthenticatingState), new AuthenticatingState(this) },
                { typeof(ProfileSelectionState), new ProfileSelectionState(this) },
                { typeof(MainMenuState), new MainMenuState(this) }
            };
        }

        public async Task ExecuteCommand(IAuthCommand command)
        {
            try
            {
                Debug.Log($"[AuthFlowManager] Executing command: {command.GetType().Name}");
                await command.Execute();
                executedCommands.Push(command);
                Debug.Log($"[AuthFlowManager] Command executed successfully: {command.GetType().Name}");
            }
            catch (Exception ex)
            {
                Debug.LogError($"[AuthFlowManager] Command execution failed: {ex.Message}");
                throw;
            }
        }

        public void TransitionTo<T>() where T : IAuthenticationState
        {
            var nextState = states[typeof(T)];

            Debug.Log($"[AuthFlowManager] Attempting transition from {currentState?.GetType().Name ?? "null"} to {typeof(T).Name}");

            if (currentState?.CanTransitionTo(nextState) ?? true)
            {
                currentState?.Exit();
                currentState = nextState;
                OnStateChanged?.Invoke(currentState);
                currentState.Enter();

                Debug.Log($"[AuthFlowManager] Transitioned to {typeof(T).Name}");
            }
            else
            {
                Debug.LogWarning($"[AuthFlowManager] Invalid state transition from {currentState.GetType().Name} to {typeof(T).Name}");
            }
        }

        public bool IsInState<T>() where T : IAuthenticationState
        {
            return currentState?.GetType() == typeof(T);
        }
    }
}
// --- END FILE ---

// File: Core/Services/Authentication/Flow/IAuthenticationState.cs
// Size: 345 characters
// ---
// File: Assets/_CyberPickle/Code/Core/Services/Authentication/Flow/IAuthenticationState.cs
namespace CyberPickle.Core.Services.Authentication.Flow
{
    public interface IAuthenticationState
    {
        void Enter();
        void Exit();
        void Update();
        bool CanTransitionTo(IAuthenticationState nextState);
    }
}

// --- END FILE ---

// File: Core/Services/Authentication/Flow/Commands/ClearProfilesCommand.cs
// Size: 1860 characters
// ---
// File: Assets/_CyberPickle/Code/Core/Services/Authentication/Flow/Commands/ClearProfilesCommand.cs
using UnityEngine;
using System;
using System.Threading.Tasks;
using System.Collections.Generic;
using System.Linq;
using CyberPickle.Core.Services.Authentication.Data;

namespace CyberPickle.Core.Services.Authentication.Flow.Commands
{
    public class ClearProfilesCommand : IAuthCommand
    {
        private readonly ProfileManager profileManager;
        private List<ProfileData> backupProfiles;

        public ClearProfilesCommand(ProfileManager profileManager)
        {
            this.profileManager = profileManager;
        }

        public async Task Execute()
        {
            Debug.Log("[ClearProfilesCommand] Executing profile clear");
            // Backup current profiles before clearing
            backupProfiles = profileManager.GetAllProfiles().ToList();
            await profileManager.ClearAllProfilesAsync();
            Debug.Log("[ClearProfilesCommand] Profiles cleared successfully");
        }

        public void Undo()
        {
            if (backupProfiles != null)
            {
                Debug.Log("[ClearProfilesCommand] Undoing profile clear");
                foreach (var profile in backupProfiles)
                {
                    try
                    {
                        var addTask = profileManager.AddProfileAsync(profile);
                        addTask.Wait();
                    }
                    catch (Exception ex)
                    {
                        Debug.LogError($"[ClearProfilesCommand] Failed to restore profile during undo: {ex.Message}");
                    }
                }
                Debug.Log($"[ClearProfilesCommand] Restored {backupProfiles.Count} profiles");
            }
        }
    }
}
// --- END FILE ---

// File: Core/Services/Authentication/Flow/Commands/CreateProfileCommand.cs
// Size: 2706 characters
// ---
// File: Assets/_CyberPickle/Code/Core/Services/Authentication/Flow/Commands/CreateProfileCommand.cs
using UnityEngine;
using System;
using System.Threading.Tasks;

namespace CyberPickle.Core.Services.Authentication.Flow.Commands
{
    public class CreateProfileCommand : IAuthCommand
    {
        private readonly ProfileManager profileManager;
        private readonly string displayName;
        private string createdProfileId;
        private bool wasSuccessful;

        public CreateProfileCommand(ProfileManager profileManager, string displayName)
        {
            this.profileManager = profileManager;
            this.displayName = displayName;
        }

        public async Task Execute()
        {
            Debug.Log($"[CreateProfileCommand] Creating profile for: {displayName}");

            try
            {
                // Generate a unique profile ID
                createdProfileId = $"{displayName.ToLower()}_{DateTime.UtcNow.Ticks}";

                // Get the current authenticated player ID
                string playerId = AuthenticationManager.Instance.CurrentPlayerId;

                // Create the profile
                var result = await profileManager.CreateProfileAsync(createdProfileId, playerId, displayName);

                if (!result.Success)
                {
                    throw new Exception(result.Message);
                }

                wasSuccessful = true;
                Debug.Log($"[CreateProfileCommand] Profile created successfully: {createdProfileId}");
            }
            catch (Exception ex)
            {
                Debug.LogError($"[CreateProfileCommand] Failed to create profile: {ex.Message}");
                wasSuccessful = false;
                throw;
            }
        }

        public void Undo()
        {
            if (wasSuccessful && !string.IsNullOrEmpty(createdProfileId))
            {
                try
                {
                    Debug.Log($"[CreateProfileCommand] Undoing profile creation: {createdProfileId}");

                    // Execute synchronously since we're in Undo
                    var deleteTask = profileManager.DeleteProfileAsync(createdProfileId);
                    deleteTask.Wait(); // Wait for the async operation to complete

                    Debug.Log($"[CreateProfileCommand] Successfully undid profile creation: {createdProfileId}");
                }
                catch (Exception ex)
                {
                    Debug.LogError($"[CreateProfileCommand] Failed to undo profile creation: {ex.Message}");
                }
            }
        }
    }
}

// --- END FILE ---

// File: Core/Services/Authentication/Flow/Commands/DeleteProfileCommand.cs
// Size: 3331 characters
// ---
// File: Assets/_CyberPickle/Code/Core/Services/Authentication/Flow/Commands/DeleteProfileCommand.cs
using UnityEngine;
using System;
using System.Threading.Tasks;
using System.Linq;
using CyberPickle.Core.Events;
using CyberPickle.Core.Services.Authentication.Data;

namespace CyberPickle.Core.Services.Authentication.Flow.Commands
{
    public class DeleteProfileCommand : IAuthCommand
    {
        private readonly ProfileManager profileManager;
        private readonly string profileId;
        private ProfileData deletedProfileBackup;
        private bool wasActiveProfile;

        public DeleteProfileCommand(ProfileManager profileManager, string profileId)
        {
            this.profileManager = profileManager;
            this.profileId = profileId;
        }

        public async Task Execute()
        {
            Debug.Log($"[DeleteProfileCommand] Preparing to delete profile: {profileId}");

            try
            {
                // Store a backup of the profile before deletion
                var profileToDelete = profileManager.GetProfile(profileId);
                if (profileToDelete == null)
                {
                    throw new Exception($"Profile not found: {profileId}");
                }

                // Create backup
                deletedProfileBackup = profileToDelete;

                // Execute the delete operation
                var result = await profileManager.DeleteProfileAsync(profileId);
                if (!result.Success)
                {
                    throw new Exception(result.Message);
                }

                // Notify that the profile was deleted
                GameEvents.OnProfileDeleted.Invoke(profileId);
            }
            catch (Exception ex)
            {
                Debug.LogError($"[DeleteProfileCommand] Failed to delete profile: {ex.Message}");
                throw;
            }
        }


        public void Undo()
        {
            if (deletedProfileBackup != null)
            {
                try
                {
                    Debug.Log($"[DeleteProfileCommand] Restoring deleted profile: {profileId}");

                    // Restore the profile
                    RestoreProfileCommand restoreCommand = new RestoreProfileCommand(
                        profileManager,
                        deletedProfileBackup);

                    // Execute synchronously since we're in Undo
                    restoreCommand.Execute().GetAwaiter().GetResult();

                    // If this was the active profile, switch back to it
                    if (wasActiveProfile)
                    {
                        SelectProfileCommand selectCommand = new SelectProfileCommand(
                            profileManager,
                            profileId);
                        selectCommand.Execute().GetAwaiter().GetResult();
                    }

                    Debug.Log($"[DeleteProfileCommand] Profile restored successfully: {profileId}");
                }
                catch (Exception ex)
                {
                    Debug.LogError($"[DeleteProfileCommand] Failed to restore profile: {ex.Message}");
                }
            }
        }
    }
}
// --- END FILE ---

// File: Core/Services/Authentication/Flow/Commands/IAuthCommand.cs
// Size: 295 characters
// ---
// File: Assets/_CyberPickle/Code/Core/Services/Authentication/Flow/Commands/IAuthCommand.cs
using System.Threading.Tasks;

namespace CyberPickle.Core.Services.Authentication.Flow.Commands
{
    public interface IAuthCommand
    {
        Task Execute();
        void Undo();
    }
}

// --- END FILE ---

// File: Core/Services/Authentication/Flow/Commands/LoadProfilesCommand.cs
// Size: 1781 characters
// ---
// File: Assets/_CyberPickle/Code/Core/Services/Authentication/Flow/Commands/LoadProfilesCommand.cs
using UnityEngine;
using System;
using System.Threading.Tasks;
using System.Collections.Generic;
using System.Linq;
using CyberPickle.Core.Events;
using CyberPickle.Core.Services.Authentication.Data;

namespace CyberPickle.Core.Services.Authentication.Flow.Commands
{
    public class LoadProfilesCommand : IAuthCommand
    {
        private readonly ProfileManager profileManager;
        private List<ProfileData> loadedProfiles;

        public LoadProfilesCommand(ProfileManager profileManager)
        {
            this.profileManager = profileManager;
        }

        public async Task Execute()
        {
            Debug.Log("[LoadProfilesCommand] Loading profiles");

            try
            {
                // Wait for profile container to load
                await Task.Yield(); // Ensure we're not blocking the main thread

                loadedProfiles = profileManager.GetAllProfiles().ToList();
                Debug.Log($"[LoadProfilesCommand] Successfully loaded {loadedProfiles.Count} profiles");

                // Notify UI that profiles are loaded
                GameEvents.OnProfilesLoaded?.Invoke(loadedProfiles);

                // Give time for any UI updates to complete
                await Task.Yield();
            }
            catch (Exception ex)
            {
                Debug.LogError($"[LoadProfilesCommand] Failed to load profiles: {ex.Message}");
                throw;
            }
        }

        public void Undo()
        {
            Debug.Log("[LoadProfilesCommand] Undoing profile load");
            GameEvents.OnProfilesCleared?.Invoke();
        }
    }
}
// --- END FILE ---

// File: Core/Services/Authentication/Flow/Commands/RestoreProfileCommand.cs
// Size: 3566 characters
// ---
// File: Assets/_CyberPickle/Code/Core/Services/Authentication/Flow/Commands/RestoreProfileCommand.cs
using UnityEngine;
using System;
using System.Threading.Tasks;
using CyberPickle.Core.Events;
using CyberPickle.Core.Services.Authentication.Data;

namespace CyberPickle.Core.Services.Authentication.Flow.Commands
{
    public class RestoreProfileCommand : IAuthCommand
    {
        private readonly ProfileManager profileManager;
        private readonly ProfileData profileToRestore;
        private ProfileData existingProfileBackup;

        public RestoreProfileCommand(ProfileManager profileManager, ProfileData profileToRestore)
        {
            this.profileManager = profileManager;
            this.profileToRestore = profileToRestore;
        }

        public async Task Execute()
        {
            Debug.Log($"[RestoreProfileCommand] Restoring profile: {profileToRestore.ProfileId}");

            try
            {
                // Check if a profile with this ID already exists
                var existingProfile = profileManager.GetProfile(profileToRestore.ProfileId);
                if (existingProfile != null)
                {
                    // Backup the existing profile before overwriting
                    existingProfileBackup = existingProfile;

                    // Delete existing profile
                    var deleteResult = await profileManager.DeleteProfileAsync(existingProfile.ProfileId);
                    if (!deleteResult.Success)
                    {
                        throw new Exception($"Failed to delete existing profile: {deleteResult.Message}");
                    }
                }

                // Restore the profile
                var addResult = await profileManager.AddProfileAsync(profileToRestore);
                if (!addResult.Success)
                {
                    throw new Exception($"Failed to restore profile: {addResult.Message}");
                }

                // Notify that the profile was restored
                GameEvents.OnProfileRestored?.Invoke(profileToRestore.ProfileId);

                Debug.Log($"[RestoreProfileCommand] Profile restored successfully: {profileToRestore.ProfileId}");
            }
            catch (Exception ex)
            {
                Debug.LogError($"[RestoreProfileCommand] Failed to restore profile: {ex.Message}");
                throw;
            }
        }

        public void Undo()
        {
            try
            {
                Debug.Log($"[RestoreProfileCommand] Undoing profile restoration: {profileToRestore.ProfileId}");

                // Remove the restored profile
                var deleteTask = profileManager.DeleteProfileAsync(profileToRestore.ProfileId);
                deleteTask.Wait(); // Wait for the async operation to complete

                // If we backed up an existing profile, restore it
                if (existingProfileBackup != null)
                {
                    var restoreTask = profileManager.AddProfileAsync(existingProfileBackup);
                    restoreTask.Wait(); // Wait for the async operation to complete
                }

                Debug.Log($"[RestoreProfileCommand] Restoration undone for profile: {profileToRestore.ProfileId}");
            }
            catch (Exception ex)
            {
                Debug.LogError($"[RestoreProfileCommand] Failed to undo profile restoration: {ex.Message}");
            }
        }
    }
}


// --- END FILE ---

// File: Core/Services/Authentication/Flow/Commands/SelectProfileCommand.cs
// Size: 2459 characters
// ---
// File: Assets/_CyberPickle/Code/Core/Services/Authentication/Flow/Commands/SelectProfileCommand.cs
using UnityEngine;
using System;
using System.Threading.Tasks;

namespace CyberPickle.Core.Services.Authentication.Flow.Commands
{
    public class SelectProfileCommand : IAuthCommand
    {
        private readonly ProfileManager profileManager;
        private readonly string profileId;
        private string previousProfileId;

        public SelectProfileCommand(ProfileManager profileManager, string profileId)
        {
            this.profileManager = profileManager;
            this.profileId = profileId;
        }

        public async Task Execute()
        {
            Debug.Log($"[SelectProfileCommand] Selecting profile: {profileId}");

            try
            {
                // Store the previously active profile ID for undo
                previousProfileId = profileManager.ActiveProfile?.ProfileId;

                // Switch to the new profile
                var result = await profileManager.SwitchActiveProfileAsync(profileId);

                if (!result.Success)
                {
                    throw new Exception($"Failed to switch profile: {result.Message}");
                }

                Debug.Log($"[SelectProfileCommand] Profile selected successfully: {profileId}");
            }
            catch (Exception ex)
            {
                Debug.LogError($"[SelectProfileCommand] Failed to select profile: {ex.Message}");
                throw;
            }
        }

        public void Undo()
        {
            if (!string.IsNullOrEmpty(previousProfileId))
            {
                try
                {
                    Debug.Log($"[SelectProfileCommand] Reverting to previous profile: {previousProfileId}");

                    // Execute synchronously since we're in Undo
                    var switchTask = profileManager.SwitchActiveProfileAsync(previousProfileId);
                    switchTask.Wait(); // Wait for the async operation to complete

                    Debug.Log($"[SelectProfileCommand] Successfully reverted to previous profile: {previousProfileId}");
                }
                catch (Exception ex)
                {
                    Debug.LogError($"[SelectProfileCommand] Failed to revert to previous profile: {ex.Message}");
                }
            }
        }
    }
}

// --- END FILE ---

// File: Core/Services/Authentication/Flow/Commands/StartAuthenticationCommand.cs
// Size: 1261 characters
// ---
// File: Assets/_CyberPickle/Code/Core/Services/Authentication/Flow/Commands/StartAuthenticationCommand.cs
using UnityEngine;
using System;
using System.Threading.Tasks;

namespace CyberPickle.Core.Services.Authentication.Flow.Commands
{
    public class StartAuthenticationCommand : IAuthCommand
    {
        private readonly AuthenticationManager authManager;
        private bool isAuthenticated;

        public StartAuthenticationCommand(AuthenticationManager authManager)
        {
            this.authManager = authManager;
        }

        public async Task Execute()
        {
            Debug.Log("[StartAuthCommand] Starting authentication");
            isAuthenticated = await authManager.SignInAnonymouslyAsync();

            if (isAuthenticated)
            {
                Debug.Log("[StartAuthCommand] Authentication successful");
            }
            else
            {
                Debug.LogError("[StartAuthCommand] Authentication failed");
                throw new Exception("Authentication failed");
            }
        }

        public void Undo()
        {
            if (isAuthenticated)
            {
                authManager.SignOut();
            }
        }
    }
}

// --- END FILE ---

// File: Core/Services/Authentication/Flow/States/AuthenticatingState.cs
// Size: 1599 characters
// ---
// File: Assets/_CyberPickle/Code/Core/Services/Authentication/Flow/States/AuthenticatingState.cs
using UnityEngine;
using System.Threading.Tasks;
using CyberPickle.Core.Services.Authentication.Flow.Commands;

namespace CyberPickle.Core.Services.Authentication.Flow.States
{
    public class AuthenticatingState : IAuthenticationState
    {
        private readonly AuthenticationFlowManager flowManager;
        private readonly AuthenticationManager authManager;

        public AuthenticatingState(AuthenticationFlowManager flowManager)
        {
            this.flowManager = flowManager;
            this.authManager = AuthenticationManager.Instance;
        }

        public async void Enter()
        {
            Debug.Log("[AuthenticatingState] Starting authentication");
            var command = new StartAuthenticationCommand(authManager);
            await flowManager.ExecuteCommand(command);

            // Only transition to ProfileSelectionState after successful authentication
            if (authManager.IsSignedIn)
            {
                flowManager.TransitionTo<ProfileSelectionState>();
            }
        }

        public void Exit()
        {
            Debug.Log("[AuthenticatingState] Authentication completed");
        }

        public void Update() { }

        public bool CanTransitionTo(IAuthenticationState nextState)
        {
            // Can only transition to ProfileSelectionState if authenticated
            return nextState is ProfileSelectionState && authManager.IsSignedIn;
        }
    }
}

// --- END FILE ---

// File: Core/Services/Authentication/Flow/States/InitialState.cs
// Size: 902 characters
// ---
// File: Assets/_CyberPickle/Code/Core/Services/Authentication/Flow/States/InitialState.cs
using UnityEngine;

namespace CyberPickle.Core.Services.Authentication.Flow.States
{
    public class InitialState : IAuthenticationState
    {
        private readonly AuthenticationFlowManager flowManager;

        public InitialState(AuthenticationFlowManager flowManager)
        {
            this.flowManager = flowManager;
        }

        public void Enter()
        {
            Debug.Log("[InitialState] Entered");
        }

        public void Exit()
        {
            Debug.Log("[InitialState] Exited");
        }

        public void Update() { }

        public bool CanTransitionTo(IAuthenticationState nextState)
        {
            // Allow transition to AuthenticatingState only
            return nextState is AuthenticatingState;
        }
    }
}

// --- END FILE ---

// File: Core/Services/Authentication/Flow/States/MainMenuState.cs
// Size: 1005 characters
// ---
// File: Assets/_CyberPickle/Code/Core/Services/Authentication/Flow/States/MainMenuState.cs
using CyberPickle.Core.Events;
using CyberPickle.Core.States;
using UnityEngine;

namespace CyberPickle.Core.Services.Authentication.Flow.States
{
    public class MainMenuState : IAuthenticationState
    {
        private readonly AuthenticationFlowManager flowManager;

        public MainMenuState(AuthenticationFlowManager flowManager)
        {
            this.flowManager = flowManager;
        }

        public void Enter()
        {
            Debug.Log("[MainMenuState] Entering main menu");
            GameEvents.OnGameStateChanged.Invoke(GameState.MainMenu);
        }

        public void Exit()
        {
            Debug.Log("[MainMenuState] Exiting main menu");
        }

        public void Update() { }

        public bool CanTransitionTo(IAuthenticationState nextState)
        {
            return nextState is ProfileSelectionState;
        }
    }
}

// --- END FILE ---

// File: Core/Services/Authentication/Flow/States/ProfileSelectionState.cs
// Size: 1266 characters
// ---
// File: Assets/_CyberPickle/Code/Core/Services/Authentication/Flow/States/ProfileSelectionState.cs
using UnityEngine;
using CyberPickle.Core.Services.Authentication.Flow.Commands;

namespace CyberPickle.Core.Services.Authentication.Flow.States
{
    public class ProfileSelectionState : IAuthenticationState
    {
        private readonly AuthenticationFlowManager flowManager;
        private readonly ProfileManager profileManager;

        public ProfileSelectionState(AuthenticationFlowManager flowManager)
        {
            this.flowManager = flowManager;
            this.profileManager = ProfileManager.Instance;
        }

        public async void Enter()
        {
            Debug.Log("[ProfileSelectionState] Entering profile selection");
            var command = new LoadProfilesCommand(profileManager);
            await flowManager.ExecuteCommand(command);
        }

        public void Exit()
        {
            Debug.Log("[ProfileSelectionState] Exiting profile selection");
        }

        public void Update() { }

        public bool CanTransitionTo(IAuthenticationState nextState)
        {
            return nextState is MainMenuState || nextState is AuthenticatingState;
        }
    }
}


// --- END FILE ---

